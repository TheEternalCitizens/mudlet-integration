<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Variables Data Themese</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--[[
Used for creating variables that should be global.
Anything in the tecSettings table WILL be saved from file.
Meaning it WILL be loaded from file on a load.
]]--

function tecClientReset(displayToScreen) --reset all client settings to defaults
  --Creating a table that will be used to easily save these
  --Variables to file. So NOT putting tec.Settings. before
  --a variable will mean that it does not get saved to file.
  tecSettings = {}
  
  --folder where settings are kept. 
  --tecUpdate.versionsRespitory is in tec Auto Updates script
  tecSettingsFolder = getMudletHomeDir().."/settings/"
  
  --set primary text color in game
  --needs to be a hex number WITH # before it.
  --If the back ground is dark this will AUTOMATICALLY be changed
  --in the text filter trigger.
  tecSettings.tecTextColor = "#c0c0c0"
  
  --Changes colors because defaults have too much contrast.
  tecSettings.GreenTextColor = "#77dd77"
  tecSettings.BlueTextColor = "#8888ff"
  tecSettings.PurpleTextColor = "#cca9dd"
  tecSettings.notApproachedCharacter = "#77dd77"
  tecSettings.ApproachedCharacters = "#ff6666"
  
  --background color for labels.
  tecSettings.labelBackgroundColor = "#537dC0"
  
  --background color for tabs.
  tecSettings.tabsBackgroundColor = "#436db0"
  
  --Color of label backgrounds and tabs as mouse hovers over them.
  tecSettings.hoverColor = "#5e8eff"
  
  --color that help text is highlighted in
  tecSettings.helpHighlightColor = "SteelBlue"
  
  --default font size. Do not save it to file.
  tecDefaultFontSize = 14
  
  --adjustable font size
  tecSettings.tecFontSize = 14
  
  --Text size applied to tabs.
  tecSettings.tecTabsFontSize = 18
  
  --enable or disable debug mode.
  --Currently display red background main line to screen.
  --The code for this is at the bottom of
  --tec client triggers - text filters - text filters
  tecSettings.tecDebugMode = false
  
  --For gui messages debug, having all this put to screen when not needed muxs things up.
  tecSettings.tecDisplayDebugMode = false
  
  --for map debug messages.
  tecSettings.tecMapDebugMode = false
  
  --Height of the communications window text area.
  tecSettings.comTextWindowHeight = 100
  
  --This line is used to buffer the main line.
  --Than we filter this line in triggers - filter text 
  --It is important that this variable be global.
  --DO NOT SAVE THIS TO FILE
  filteredLine = "Reset filteredLine."
  
  --Zoom level of the map. 
  mapZoom = 1
  
  --used to keep track of characters in current room.
  	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
  
  --stores a command list for the room character window
  --Done this way so it can be customized. 
  tecSettings.commandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.commandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  tecSettings.approachedCommandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.approachedCommandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  	
  --Used to check if a room Character check is needed.
  doRoomCharacterCheck = false

  --used for if timer debug is or is not wanted.
  tecSettings.tecTimerDebugMode = false
  
  --controls if scroll bars are of are now viewd.
  tecSettings.showScrollBars = true
  
  --Spaces inventory list 
  tecInventorySpacer = ""
  
  --use for functions that need to loop through all text windows 
  tecTextWindowNames = {"main", "tecSettingsConsole"
    ,"roomCharacters.console" , "Communication"
    ,"Thoughts", "Speech"}
    
  --Holds list of labels that use default lable stylesheet 
  tecWindowLabels = {} --normally configured with tecGetWindowLabelList
    
  tecGUIFrameTabNames = { "Compass", "Settings", "Macros", 
    "Room Characters", "TEC Map" }

	tecDebugSaveDir = getMudletHomeDir().."\/DebugingFiles\/"
  
  tecSettings.betaTester = false

	if displayToScreen then echo("Client settings set to default.\n") end

end --function tecClientReset()

tecClientReset(false) --Calling the function so these variables get created.</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--Functions that work directly with many variables that have nothing logically in common.
--For example they aren't all variables for display settings, all for font or debuging.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecFileSaveSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--Save client settings to file
function tecFileSaveSettings(displayToScreen)

--Idealy implimenting some kind of error checking would be great.
--Maybe making tecFileLoadSettings into a function that returns a table
--rather than loads the data into a global settings table

  --Save the table to file.
  table.save(tecSettingsFolder.."TECClientData.lua", tecSettings)
	
	--display save to screen
	if displayToScreen then echo("Client settings saved.") end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecFileLoadSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--This perhaps should be in a sysLoadEvent

--This bugs on startup because it is calling debugToDisplay before it is declared.

--Loads variable and theme settings from file.
--Notify is boolean, to let the user know the event occured.
--In this case it is also a to screen notification that it was 
--successfull
function tecFileLoadSettings(displayToScreen)

	--Set the location and name of file.	
	local path = tecSettingsFolder.."TECClientData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		debugToDisplay("tecFileLoadSettings: save file doesn't exist.") --TEC debug screen
		debugc("tecFileLoadSettings: save file doesn't exist.") --mudlets debug screen
		echo("settings did not load from file\n")
	return --kill the function before real errors occur
	else
    table.load(path, tecSettings) --Load the settings in from file
    if displayToScreen then 
    cecho("[  OK  ]  - Parthia settings successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
end --function tecFileLoadSettings

--Call the function so data loads when mudlet starts.
tecFileLoadSettings(true)

--Now change some settings since data has been loaded
setFontSize(tecSettings.tecFontSize) --font size</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientSaveAll(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientSaveAll(displayToScreen)
  --Save client data to file.
  tecFileSaveSettings()
  if displayToScreen then echo("Client data saved to file.\n") end
  
  --saves the gui loadWindowLayout
  GUIframe.saveSettings()
  if displayToScreen then echo("Display settings saved to file.\n") end
end --function tecClientSaveAll</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--used to keep track of characters in current room.
function clearTECRoomObjects()
	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
end --fuctoin clearTecRoomObjects</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Themes</name>
				<packageName></packageName>
				<script>--People expressed interest in having themes.

--Important reference for themes
--https://doc.qt.io/qt-5.12/stylesheet-reference.html
--QT style sheets don't always act they was
--standard css does. Just buggy...

--lua showColors(3) shows a color chooser on screen.
--A good reference of colors, but when we offer color custimization to users, it can give them a 
--list to choose from.

--Upgrade options.
--add these variables to tecSettings so they can be saved and loaded.


function tecConfigThemes() --configure and initalize settings for tabs.
  --Default tab height
  tabsHeight = 30
  
  --QLabels are QTs label system
  --Used here for easy hover affects
  tabsStyle = [[
  	QLabel{
  		background-color: ]]..tecSettings.tabsBackgroundColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: lightgray;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: ]]..tecSettings.tecTabsFontSize..[[px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: ]]..tecSettings.hoverColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: gray;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: ]]..tecSettings.tecTabsFontSize..[[px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]
  
  --This is now tabs text looks
  tabsFontStyle = [[&lt;center&gt;&lt;p style="font-size:]]
    ..tecSettings.tecTabsFontSize..[[px; color:lightgray"&gt;]]

labelsStyle = [[
	QLabel{
		background-color: ]]..tecSettings.labelBackgroundColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: lightgray;
    margin-right: 0px;
    margin-left: 0px;
		font-size: 20px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
	QLabel::hover{
		background-color: ]]..tecSettings.hoverColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: gray;
    margin-right: 0px;
    margin-left: 0px;
		font-size: 20px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
]]
								
buttonsStyle = [[QPushButton{
                		background-color: gray;
                    border-width: 1px;
                    border-style: outset;
                    border-color: lightgray;
                    border-top-left-radius: 15px;
                    border-top-right-radius: 15px;
										border-bottom-left-radius: 15px;
                    border-bottom-right-radius: 15px;
                    margin-right: 1px;
                    margin-left: 1px;
                		font-size: 50px;
                    qproperty-alignment: 'AlignCenter | AlignCenter';}
								 QPushButton::on{}
								 QPushButton::hover{}
]]					

--This is now tabs text looks
buttonsFontStyle = '&lt;center&gt;&lt;p style="font-size:18px; color:white"&gt;'

--Used to shape rooms on map. Intentionally left without a } at the end.
mapRoomStyle = [[
	QLabel{
	border-bottom-right-radius: 3;
	border-bottom-left-radius: 3;
	border-top-right-radius: 3;
	border-top-left-radius: 3;
	margin: 2px;
  qproperty-alignment: 'AlignCenter | AlignCenter';
]]

--Create a red style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleRed = mapRoomStyle..[[
	background-color:  #ff6666;
  }
]]

--Create a Green style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleGreen = mapRoomStyle..[[
	background-color: #77dd77;
  }
]]

--Create a white style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleWhite = mapRoomStyle..[[
	background-color: GhostWhite;
  }
]]

mapStraitOpenExitStyle = [[
	QLabel{
	background-color: GhostWhite;
	}
]]

mapStraitClosedExitStyle = [[
	QLabel{
	background-color: black;
	}
]]

--create table used for exits
tecExit = { "hor", "ver", "ne", "nw" }

--set the horizontal exit table
tecExit["hor"] = {"0", "1", width, height}
tecExit["hor"]["0"] = { tecExitStyleSheet = [[
	QLabel{
	background-color: black;
	}
]]
} --end tecExit["hor"][0] table declaration
tecExit["hor"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
tecExit["hor"].width = 10
tecExit["hor"].height = 3

--now set verticle table
tecExit["ver"] = {"0", "1", width, height}
tecExit["ver"]["0"] = { tecExitStyleSheet = [[
	QLabel{
	background-color: black;
	}
]]
} --end tecExit["ver"][0] table declaration
tecExit["ver"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
tecExit["ver"].width = 3
tecExit["ver"].height = 10

--Use these to adjust nenw icons
local nenwExitIconSize = 10 --square size of icon

--now set ne table
tecExit["ne"] = {"0", "1", width, height}
tecExit["ne"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/ne_closed.png");]]}
tecExit["ne"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/ne_open.png");]]}
tecExit["ne"].width = nenwExitIconSize
tecExit["ne"].height = nenwExitIconSize

--now set nw table
tecExit["nw"] = {"0", "1", width, height}
tecExit["nw"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/nw_closed.png");]]}
tecExit["nw"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/nw_open.png");]]}
tecExit["nw"].width = nenwExitIconSize
tecExit["nw"].height = nenwExitIconSize
end --function tecConfigThemes
tecConfigThemes() --configure tabs now.</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>mudlet Communidy Functions</name>
			<packageName></packageName>
			<script>--[[
Space for mudlet functions the community makes that we need.
]]--</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.text = {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then 
      gapSpaces = 2 
    else 
      gapSpaces = 1 
    end
  end
  options.effWidth = options.width - ((options.capLen * 2) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then 
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else 
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}


function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",

  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  if type(entry) ~= "string" then
    if type(entry) == "function" then
      local entryReturn = entry()
      if type(entryReturn) ~= string and not tostring(entryReturn) then entry = 0 end
    elseif not tostring(entry) then
      entry = 0
    end
  end
  return entry
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

function demonnic.TableMaker:assemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  return sheet
end


function demonnic.TableMaker:new(options)
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>guiFramework</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2

-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.

-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.

-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.

-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.

-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.

-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)

GUIframe.configs = GUIframe.configs or {}

--Default settings for display.
--These will load on a reset, and will be
--what loads when the application is run before
--saving display settings.
GUIframe.defaults = {
    tabHeight = tabsHeight,
    tabStyle = tabsStyle,
    tabEchoStyle = tabsFontStyle,
    leftStartWidth = eighthW,
    leftStartHeight = halfH,
    rightStartWidth = quarterW,
    rightStartHeight = halfH,
    topStartHeight = eighthH,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_30t.png",
    borderOffset = 0,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}

    tabsInfo = {
        topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
            height = configs.tabHeight},
        bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
            width = configs.leftStartWidth, height = configs.tabHeight},
        topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
            width = configs.rightStartWidth, height = configs.tabHeight},
        bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
    }
    containerInfo = {
        topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
            y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth},
        topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth}
    }
    resizeInfo = {
        resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
            y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
            y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
            y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
        resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
            y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
            width = configs.resizeWidth}
    }

    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end

    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    if tecSettings.showScrollBars then --if tecSettings.showScrollBars is false
      setBorderRight(configs.rightStartWidth + configs.borderOffset)
    else
      setBorderRight(-16) --hide the scroll bar off the screen.      
    end --if tecSettings.ShowScrollBars
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
            local name = tab.name:gsub("Tab","")
            local show = GUIframe.windows[name].showText
            if show then
                tab:echo(configs.tabEchoStyle..name)
            end
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container, hideText)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local showText = not hideText
        window.showText = showText
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        if showText then
            lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    local text = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
        text[con] = text[con] or {}
        text[con][k] = v.showText
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, {wname, text[con][wname]})
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(tecSettingsFolder .. "GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = tecSettingsFolder .. "GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
        for _,name in ipairs(wins) do
            if type(name) == "string" then
                GUIframe.addWindow(GUIframe.windows[name], name, con)
            else
                local n, s = name[1], not name[2]
                GUIframe.addWindow(GUIframe.windows[n], n, con, s)
            end
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- can be called to activate a given tab without clicking on it
function GUIframe.activate(name)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local window = GUIframe.windows[name]
	if window then
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    end
end

-- can be called to apply a style to a given tab
function GUIframe.styleTab(name, style)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local tab = GUIframe.tabs[name]
	if tab then
	    tab:setStyleSheet(style)
    end
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
    raiseEvent("GUIframe.buttonClick",name,event)
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""), not window.showText)
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
  if not tecSettings.showScrollBars then --hides scroll bar when right click button is released.
    setBorderRight(-16) --Moves the scroll bar off the screen
    debugToDisplay("GUIframe.buttonRelease: setBorderRight to -16.")
  end --DaveWithTheNiceHat
	raiseEvent("GUIframe.buttonRelease",name,event)
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    lbl = GUIframe[name]
	    if lbl.isClicked then
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
	raiseEvent("GUIframe.buttonMove",name,event)
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

--register the event above
registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>md5</name>
				<packageName></packageName>
				<script>md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n &lt;= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big &lt; #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n &lt; 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n &gt; 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 &gt; 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>fuzzyBoolean(bool)</name>
				<packageName></packageName>
				<script>-- Provided by demonnic
--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TECFunctions</name>
			<packageName></packageName>
			<script>--Functions made by The Eternal Citizens
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>debug</name>
				<packageName></packageName>
				<script>--[[
Debug like functions:


]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setTECDebugMode(tectmpSetDebug)</name>
					<packageName></packageName>
					<script>--opens a debug window.
--triggers system to send debug information to it.

function setTECDebugMode(tectmpSetDebug)
	
	--Set debug mode
	tecSettings.tecDebugMode = tectmpSetDebug or false
	
	if tecSettings.tecDebugMode then --if enabling debug
		openUserWindow("tecDebugWindow")
		--saveWindowLayout() --save floating miniconsole locations
		--loadWindowLayout() --load previously save miniconsole position.
		--tecDebugWindow:addScrollbars(parent, "Vertical")
    if tecSettings.showScrollBars then enableScrollBar("tecDebugWindow") end
		echo("Debug mode enabled.\n")
	else --else disabling debug
		echo("Debug mode disabled.\n")
		setTECDisplayDebugMode(tectmpSetDebug)
		setTECMapDebugMode(tectmpSetDebug)
		setTECTimerDebugMode(tectmpSetDebug)
    closeUserWindow("tecDebugWindow")
	end -- if tectmpSetDebug
	
end --end function setTecDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDebugMode() 
	return tecSettings.tecDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>debugToDisplay()</name>
					<packageName></packageName>
					<script>--this takes a string from function input, and displays it to the debug screen.

--error("") Test this one.
--debugc("") fairly certain this exports to mudlets debug screen.

--Idealy we would want this function to check if a TECClient debug child window 
--Is open, and create one if it is not. Than send debug code to it rather than 
--main, where users can easily see it or mudlets debug, which is meant for true
--blue errors.
function debugToDisplay(textMessage)
	if getTECDebugMode() then --Is debug mode on?
		local redBG, greenBG, blueBG = getBgColor() --keep track of current screen color
		setBgColor( 255,50,50) --change text background to red
		cecho("tecDebugWindow","\n"..textMessage) -- print message to screen
		setBgColor(redBG,greenBG,blueBG) --change text background back to what it was
	end --if debug mode if check
end --end displayToDebug function
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyserDebug()</name>
					<packageName></packageName>
					<script>--poll GUIFrame for 
--Geyser API Reference https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html

function Geyser.Container:getDebug ()
	 
 if getTECDisplayDebugMode() then
	 
  	 local string guiLog = ""
  	 
     guiLog ="Name: "..tostring(self.name)..
		 " | Type: "..tostring(self.type)..
		 " | Parent: "..tostring(self.parent.name)..
		 " | X position: "..tostring(self:get_x())..
		 " | Y Position: "..tostring(self:get_y())..
		 " | Width: "..tostring(self:get_width())..
		 " | Height: "..tostring(self:get_height())..
		 "\n"
  	 
		 --just in case we are going to make a infinite loop killer.
		 guiloop = guiloop + 1
		 if guiloop &lt; 100 then
		 
       --Loop through all children of this container
       for k,v in pairs(self.windowList) do
    	 		
          if k ~= self then
    				guiLog = guiLog..v:getDebug() --Collect debug data to string
    					
          end --end if k not = self check
       end --end for loop pair(self windowlist)
		 end --if guiloop is less than 100
		 
		 --Returns debug data for all of the windows we have looped through
		 return guiLog
		 
	end --if getTECDisplayDebugMode()
end --end Geyser.Container:debugMode


function geyserDebug() --geyserWindow needs to be a string with the name of the window.	

	if getTECDisplayDebugMode() then --Is debug mode on?
		local debugOut = ""
		--Send all of the windows information to the debug display.
		guiloop = 0
		debugToDisplay(GUIframe.topLeftContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomLeftContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomRightContainer:getDebug())
		guiloop = 0
		debugOut =GUIframe.topRightContainer:getDebug()
		debugOut = debugOut:sub(1, -2)
		debugOut = debugOut:sub(2)
		debugToDisplay(debugOut)
		guiloop = 0
		debugOut = GUIframe.topContainer:getDebug()
		debugOut = debugOut:sub(1, -2)
		debugToDisplay(debugOut)
	end --if tecDebugMode is true

end --end geyserDebug() function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecReportIssuesHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>--help user create an issue request
--tecBrief is if screen reporting should be brief
--tecWindow is the string name of the window to send the command help to
function tecReportIssuesHelp(tecBrief, tecWindow) 

	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false

  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug report issue", 
  	[[tecReportIssues()]], 
  	"Report client issues", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, ", Report client issues to developers.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief

end --function tecReportIssues

function tecReportDebugHelp()
	echo("\n---Debug collection helper---\n")
	echo("Please do not follow these steps unless you have opened an issue report and "
		.."were asked to collect debug data from a developer.\n"
		.."The debug modes available are: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on&lt;reset&gt;, ", 
  	[[setTECDebugMode(true)]], 
  	"Enable basic debug", true)
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on&lt;reset&gt;, ", 
  	[[setTECDisplayDebugMode(true)]], 
  	"Enable display debugging", true)
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on&lt;reset&gt;, ", 
  	[[setTECMapDebugMode(true)]], 
  	"Enable map debugging", true)
	echo("and ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timer on&lt;reset&gt;.\n", 
  	[[setTECTimerDebugMode(true)]], 
  	"Enable timer debugging", true)
	echo("After enabling the debug mode or modes requested clear your main window with, ") 
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[tecClearDisplay() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Now cause the issue reported to occur. After you have disable debug mode with ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off.\n", 
  	[[setTECDebugMode(false)]], 
  	"Disable debugging", true)
	echo("Please verify the debug window has text in it than click ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save debug window.\n", 
  	[[tecSaveWindowText("tecDebugWindow")]], 
  	"Save debug window text to file", true)
	echo("Please save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	echo("Open your issue report, at the TEC gitHub ")
	  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	echo("Open the folder that contains the debug window text by clicking ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	cecho("Open main.txt and tecDebugWindow.txt and verify nothing is in it that you would "
		.."not want to be viewed by the public.\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Drag the files tecDebugWindow.txt and main.txt into the comment area of your "
		.."gitHub issues report.&lt;reset&gt;\n"
		.."To update your issue click the green button labeled -Comment-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --function tecReportDebugHelp()

function tecReportStandardIssue()
	echo("\n---Create an issue request helper---\n")
	echo("Go to the client's issue reporting gitHub page: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	echo("Please view our current open issues to see if your issue was already reported.\n"
		.."If you have not you will need to log into gitHub.\n"
		.."To create an issue report click the green -New Issue- button, on the right side of the page.\n"
		.."A new page will load. In the -Title- section please provide a brief description of your issue\(s\).\n"
		.."In the comment section labeled -Leave a comment-. Fully describe your issue\(s\).\n"
		.."It is highly recommendable to clear you main display and recreate your issue "
		.."before continuing forward.\n"
		.."If you would like to, clear your display with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[tecClearDisplay() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	echo("This file is called main.txt and can easily found by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	cecho("Open main.txt and verify nothing is in it that you would not want to be viewed "
		.."by the public!\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Now drag the file main.txt into the comment area of the gitHub issues report.&lt;reset&gt;\n"
		.."At this time, please do not attach any other files to the issue report.\n"
		.."To submit your issue click the green button labeled -Submit new issue-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --end function tecReportMajorIssue

function tecReportIssues()

	cecho("&lt;black:red&gt;\nPlease follow the instructions below.\n")

	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---Start an issue request---\n", 
  	[[tecReportStandardIssue()]], 
  	"Standard issue report tutorial", true)
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---A developer asked you to enable debug---", 
  	[[tecReportDebugHelp()]], 
  	"Debug collection tutorial", true)
		
	echo("\n") --leave this as the last line. cechlink does not autoscroll main display.
	
end --function tecReportIssues</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>function setTECDisplayDebugMode(tmpDebugMode)
	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecDisplayDebugMode = tmpDebugMode or false
	
	if tecSettings.tecDisplayDebugMode then echo("Display debug mode on.\n")
	else echo("Display Debug Off.\n") end
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDisplayDebugMode() 
	return tecSettings.tecDisplayDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecColorTest()</name>
					<packageName></packageName>
					<script>--Just a simple test outputting colors to screen using three main methods.

function tecColorTest()

  echo("\ndefault text\n")
  cecho("\ncecho: &lt;:"..tecSettings.helpHighlightColor.."&gt;blue background, &lt;red:white&gt;Red text white background.\n")
  decho("\ndecho: &lt;:255,0,0&gt;Red background, &lt;0,0,255:0,255,0&gt;Blue text green background.\n")
  hecho("\nhecho: #ff0000Red text, #3c00ffBlue text.\n")

end --end tecColorTest function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECMapDebugMode(boolean)</name>
					<packageName></packageName>
					<script>function setTECMapDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecMapDebugMode = tmpDebugMode or false --enable map debug mode
	
	if tecSettings.tecMapDebugMode then echo("Debug map mode on.\n")
	else echo("Map Debug Off.\n") end
	
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECMapDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECMapDebugMode()
	return tecSettings.tecMapDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECTimerDebugMode(boolean)</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function setTECTimerDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode

	tecSettings.tecTimerDebugMode = tmpDebugMode or false
	if tecSettings.tecTimerDebugMode then echo("Debug timer mode on.\n")
	else echo("Timer Debug Off.\n") end
end --setTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECTimerDebugMode()</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function getTECTimerDebugMode()
	return tecSettings.tecTimerDebugMode
end --getTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI or display</name>
				<packageName></packageName>
				<script>--[[
for funtions that directly affect the clients GUI.

GUI like functions
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setMainWindowAutoWrap()</name>
					<packageName></packageName>
					<script>--set main window word wrap size.
--It is currently in the guiChange event function to be called when gui changes occur
function setMainWindowAutoWrap()

  local wrapAt = 0
    
  if tecSettings.showScrollBars then --if tecSettings.showScrollBars is true

    --get how many characters should appear on a line before word wrapping.
  	wrapAt = getColumnCount()
    
    debugToDisplay("setMainWindowAutoWrap: Wrap at: "..tostring(wrapAt) )

  else --if tecSettings.showScrollBar is false 
  
    --get average pilxelwidth of font used on main console.
    local fontWidth, fontHeight = calcFontSize(getFontSize())
  	--Get size of the entire window.
    local mainWidth, mainHeight = getMainWindowSize()
    
    --Get the width of left and right gui bars.
    local leftSideWidth = GUIframe.topLeftContainer:get_width()
    local rightSideWidth = GUIframe.topRightContainer:get_width()
    
    --Calculate how many characters can fit into main on average taking left and 
    --right GUI objects into consideration. Rounding down with math.floor
    wrapAt = math.floor(((mainWidth - leftSideWidth - rightSideWidth) / fontWidth) - 1)
    
  	--displays actual sizes to screen.
  	--display with setTECDebugMode(true)
  	--or command line debug on
  	debugToDisplay("setMainWindowAutoWrap: Font Width: "..tostring(fontWidth)
      .." Left side width: "..tostring(leftSideWidth).." Right side width: "..tostring(leftSideWidth)
      .." Main screen width: "..tostring(mainWidth)
      .." line wrap: "..tostring(wrapAt)
      .." Mains font sie: "..tostring(getFontSize())..".")
  
  end --if not tecSettings.showScrollBars
  
  --Set updated word wrap for main.
  setWindowWrap("main", tonumber(wrapAt))
  
end --end function setMainWindowAutowrap</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClearDisplay()</name>
					<packageName></packageName>
					<script>--There is either a bug or clear working as intended.
--If we clear main. geyser objects that adopt it's background color via getBgColor
--it will error out.

function tecClearDisplay()

  --backup background color
	local br,bg,bb = getBgColor()
	
  --clear main
  clearWindow()

  --set mains background to eat it was.
	setBgColor(br,bg,bb)
	echo(" \n") --We need a line of text on the screen for getBgColor to copy from.
	
end --end function tecClearDisplay</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplayReset()</name>
					<packageName></packageName>
					<script>function tecClientDisplayReset()

echo("Display settings reset. You MUST restart mudlet.")

  GUIframe.reinitialize()  --reset window positions to default
	tecClientDisplaySave(true) --save default window positions to file
  send("exit") --disconnect
  send("exit")
  disconnect()

end --function tecClientDisplayReset()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplaySave(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientDisplaySave(displayToScreen)
  GUIframe.saveSettings()
  if displayToScreen then echo("\nDisplay settings saved.\n") end
end --function tecClientDisplaySave</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplayLoad(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientDisplayLoad(displayToScreen)

  GUIframe.loadSettings(redraw) --loads display settings from file
  if displayToScreen then 
		echo("\nDisplay settings loaded from last save.\n")
	end --if displayToScreen
	
end --function tecClientDisplayLoad</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setInventoryFormater(setFormater)</name>
					<packageName></packageName>
					<script>function setInventoryFormater(setFormater)
  setFormater = setFormater or false
  tecFormatInventory = setFormater
end --function setInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getInventoryFormater()</name>
					<packageName></packageName>
					<script>function getInventoryFormater()
  return tecFormatInventory
end --function getInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser.Container:objectQuery()</name>
					<packageName></packageName>
					<script>function Geyser.Container:objectQuery(objectTable)
  --We are addding data to this table each loop.
  --We assume first run if a table is not passed. So we created the table.
  objectTable = objectTable or
    {name={}, type={}, parentName={}, xPos={}, yPos={}
    ,width={}, height={}}
  
  --windowList reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  --Loop through all children of this container.
  for k,v in pairs(self.windowList) do
      if k ~= self then --if the key is not this geyser object
    		  objectTable = v:objectQuery(objectTable) --query that object.
      end --end if k not = self check
  end --end for loop pair(self.windowlist)
  
--[[this.object logic can SEEM confusing. It's not.
At this point we have reach the 'bottom' of ourcontainer query.
So the last child with the last alphabetical name.
We insert our object data. Than return it. Meaning this now occurs for the second to
the last geyser object, and so on until we reach the parent that called the query.]]--
  
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#debugc
  --debugc("Geyser.Container:objectQuery: Inserting Object data for: "..self.name)
  
  --Collect this object data.
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  table.insert(objectTable.name, tostring(self.name))
  table.insert(objectTable.type, tostring(self.type))
  table.insert(objectTable.parentName, tostring(self.parent.name))
  table.insert(objectTable.xPos, tostring(self:get_x()))
  table.insert(objectTable.yPos, tostring(self:get_y()))
  table.insert(objectTable.width, tostring(self:get_width()))
  table.insert(objectTable.height, tostring(self:get_height()))

  return objectTable --return the table to the object that called this object
  
end --Geyser.Container:objectQuery(objectTable)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRedrawLabels()</name>
					<packageName></packageName>
					<script>--Tracks down the labels in this project, and reapplies the default stylesheet
function tecRedrawLabels()

  debugToDisplay("Labels redraw started.")

  tecConfigThemes() --redo themes data. something likely changed

  --Create table to store all geyser objects within GUIframe
  ContainerDataTable = { 
    GUIframe.bottomRightContainer:objectQuery(),
    GUIframe.topLeftContainer:objectQuery(),
    GUIframe.bottomLeftContainer:objectQuery(),
    GUIframe.bottomContainer:objectQuery(),
    GUIframe.bottomRightContainer:objectQuery(),
    GUIframe.topRightContainer:objectQuery(),
    GUIframe.topContainer:objectQuery(),
    GUIframe.topLeftTabs:objectQuery(),
    GUIframe.topRightTabs:objectQuery(),
    GUIframe.bottomLeftTabs:objectQuery(),
    GUIframe.bottomRightTabs:objectQuery() }
    
  --Go through all the table we created above
  for key,cdt in pairs(ContainerDataTable) do
    for k,v in pairs(cdt.type) do --Check the types of containers
      if v == "label" then --To see if it is a label
        if "map" == cdt.name[k]:match("map") then --if map label is found, skip
          --debugc("\t"..cdt.name[k].." is a map label no redraw logic in this client release.")
          debugToDisplay("\t"..cdt.name[k].." is a map label no redraw logic in this client release.")
          
        elseif "Compass." == cdt.name[k]:match("Compass.") then
          --debugc("\t"..cdt.name[k].." is a Compass label no redraw logic in this client release.")
          debugToDisplay("\t"..cdt.name[k].." is a Compass label no redraw logic in this client release.")
          if cdt.name[k] == "tecCompass.back" then --if the label is the background of the compass
            setLabelStyleSheet(cdt.name[k], labelsStyle)
            --debugc("\t"..cdt.name[k].." back of Compass applying standard label.")
            debugToDisplay("\t"..cdt.name[k].." back of Compass applying standard label.")
          end --if cdt.name[k] is tecCompass.back
          
        elseif "tab" == cdt.name[k]:match("tab") or "Tab" == cdt.name[k]:match("Tab") then
          setLabelStyleSheet(cdt.name[k],tabsStyle)
          local tmpTabName= cdt.name[k]:gsub("Tab", "") --remove Tab from name
          local tmpTabName= tmpTabName:gsub("tab", "") --remove tab from name
          local tmpTabName= tmpTabName:gsub("tecComWindows.", "") --remove tecComWindows from name
          echo(cdt.name[k], tabsFontStyle..tmpTabName) --echo name onto the tab
          --debugc("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          
        else --Reapply default style sheets to all other labels.
          setLabelStyleSheet(cdt.name[k], labelsStyle)
          --debugc("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          
        end --if check label types.
        --debugc("\tTable type: "..v.." key: "..k)
      end --if cdt.type is label
    end --for cdt
  end --for ContainerDataTable
  
  debugToDisplay("Labels redraw completed.")
  
end --function tecRedrawLabels()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecSetScrollBars(mode)</name>
					<packageName></packageName>
					<script>--Enables or disables scrollbars throughout the project.
--Providing an option to save so scroll bars will not appear automatically
function tecSetScrollBars(mode, displayToScreen)
  mode = fuzzyBoolean(mode) --verifies mode.
  displayToScreen = fuzzyBoolean(displayToScreen)
  mode = mode == nil and true or mode
  displayToScreen = displayToScreen == nil and true or displayToScreen
  tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
  
  debugToDisplay("Setting Scrollbars: ")
  
  if mode then
    --if enabling, com windows only. Settings &amp; Room Character use tecScrollBarCheck
    for index, windowName in ipairs(tecComWindows.tabs) do
      enableScrollBar(windowName)
      debugToDisplay("\tEnabling scroll bar for: "..windowName)
      --debugc("Enabling scroll bar for: "..windowName)
    end --for tecTextWindowNames
    tecSettings.showScrollBars = true --tell further gui changes to show scrollbars
    setBorderRight(GUIframe.topRightContainer:get_width())
    if displayToScreen then
      cecho("Enabled scrollbars. "
        .."Some windows will not show their scrollbars until there is enough text "
        .."to need to scroll the window.\n")
    end --if displayToScreen
  else
      --disable scrollbars for all windows.
      for index, windowName in ipairs(tecTextWindowNames) do
        disableScrollBar(windowName)
        debugToDisplay("\tDisabling scroll bar for: "..windowName)
        --debugc("Disabling scroll bar for: "..windowName)
      end --for tecTextWindowNames
      tecSettings.showScrollBars = false --tell further gui changes to hide scrollbars
      setBorderRight(-16) --hide the scroll bar off the screen
      setMainWindowAutoWrap() --Adjust mains autowrap now that main has changed.
      if displayToScreen then
        cecho("Disabled scrollbars. "
          .."You will need to scroll with your mouse wheel or page up page down keys. "
          .."Main console scrollbar will reappear while moving windows.\n")
      end --if displayToScreen

  end --if mode
  
  debugToDisplay("Completed setting scroll bars.")
  
  if displayToScreen then
    cecho("Don't forget to save your changes with: ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
    [[tecFileSaveSettings(true)]],
    "Save client settings", true)
    cecho("") --cechoLink will not \n on its own.
  end --if displayToScreen
  
end --tecSetScrollBar</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecScrollBarCheck(tecConsoleName)</name>
					<packageName></packageName>
					<script>--automatically enable a console scroll bar if it can not fit the text in it
--This works best if it is in a "sysWindowResizeEvent" function to controll the 
--drawing of a gui object.
function tecScrollBarCheck(tecConsoleName)
  tecConsoleName = tecConsoleName or "main"
  local tecSettingsRowCount = getRowCount(tecConsoleName)
  --if the window can not contain the rows of text.
  if tecSettingsRowCount &lt; getLastLineNumber(tecConsoleName) then
    --if user is allowing scroll bars, enable the scroll bar.
    if tecSettings.showScrollBars then enableScrollBar(tecConsoleName) end
  else --The window can contain the text.
    disableScrollBar(tecConsoleName)
  end --if tecSettingsRowCount less than text rows in that window.
end --function tecScrollBarCheck</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>help</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientFullHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>function tecClientFullHelp(tecBrief, tecWindow)
  
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false
	
	if not tecBrief then --if we do not want to be brief
    echo(tecWindow, "There are a number of commands to adjust the game client. "
  		.."They are:\n")	
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient", 
  [[tecClientHelp()]], 
  "Save or load client settings.", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, " Save or load client settings.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;display", 
  [[tecDisplayHelp()]], 
  "Change display settings.", true)
  if not tecBrief then --if we do not want to be brief
    echo(tecWindow, " Save or load display positions, "
			.."reset display to defaults, "
  		.."and clear text off the display.\n") 
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug", 
  [[tecDebugHelp()]], 
  "Create debug messages", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, " Use to get information to report issues.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  echo(tecWindow, "\n")
end --end function tecClientFullHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDebugHelp()</name>
					<packageName></packageName>
					<script>function tecDebugHelp()
  cecho("\n&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on", 
  [[setTECDebugMode(true)]],
  "Send debug text to debug window", true)
  echo(", Create debug window and send basic info to it.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off", 
  [[setTECDisplayDebugMode(false) setTECMapDebugMode(false) setTECDebugMode(false)]],
  "Stop all debug messages", true)
  echo(", Stops sending all debug messages.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on", 
  [[setTECDisplayDebugMode(true)]],
  "Show display messages to debug window", true)
  echo(", Send display information to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display off", 
  [[setTECDisplayDebugMode(false)]],
  "Stop showing display messages to debug window", true)
  echo(", Disables display debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on", 
  [[setTECMapDebugMode(true)]],
  "Show map messages to debug window", true)
  echo(", Send map debug messages to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map off", 
  [[setTECMapDebugMode(false)]],
  "Stop showing map messages to debug window", true)
  echo(", Disables map debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers on", 
  [[setTECTimerDebugMode(true)]],
  "Start showing timmer messages to debug window", true)
  echo(", Send timer debug messages to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers off", 
  [[setTECTimerDebugMode(false)]],
  "Stop showing timmer messages to debug window", true)
  echo(", Disables timmer debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug test colors", 
  [[tecColorTest()]],
  "Send basic colors to screen", true)
  echo(", Sends colored text to screen.\n")
	
	tecReportIssuesHelp(false, "main")
  
  cecho("&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")

end --end function tecDebugHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecResizeDisplayHelp()</name>
					<packageName></packageName>
					<script>function tecResizeDisplayHelp() --explains how to resize display
	cecho("&lt;black:"..tecSettings.helpHighlightColor.."&gt;\\\/\\\/All windows can be resized! Read Below.\\\/\\\/&lt;reset&gt;\n"
		.."Version one allows this by RIGHT "
		.."clicking one of the four faint blue arrows and dragging it. "
		.."These arrows are on the top, bottom, left and right outer edges "
		.."of the main text window that this text appears in. "
		.."When you move your mouse over the arrows they will "
		.."become bold blue arrows.\n"
    .."After changing don't forget to ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
      [[tecClientSaveAll(true)]],
      "Save all client settings", true)
		cecho("&lt;black:"..tecSettings.helpHighlightColor.."&gt;\/\\\/\\All windows can be resized! Read Above.\/\\\/\\&lt;reset&gt;\n")
end --function tecResizeDisplayHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecMoveTabsHelp()</name>
					<packageName></packageName>
					<script>function tecMoveTabsHelp() --explains how to move tabs on display
	cecho("&lt;black:"..tecSettings.helpHighlightColor
    .."&gt;\\\/\\\/Non communication tabs can be moved! Read Below.\\\/\\\/&lt;reset&gt;\n"
		.."To move a tab you can right click it. Than drag it to the position of a different tab."
    .."It may take a few tries because it requires the position to be nearly exact.\n"
    .."After changing don't forget to ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
      [[tecClientSaveAll(true)]],
      "Save all client settings", true)
		cecho("&lt;black:"..tecSettings.helpHighlightColor
      .."&gt;\/\\\/\\Non communication tabs can be moved! Read Above.\/\\\/\\&lt;reset&gt;\n")
end --function tecResizeDisplayHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDisplayHelp()</name>
					<packageName></packageName>
					<script>function tecDisplayHelp()
  
  echo("\nDisplay commands:\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear", 
  [[tecClearDisplay()]], 
  "Remove text from main screen", true)
	echo(", clear text from main text console.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display enable scrollbars", 
  [[tecSetScrollBars(true)]], 
  "Enable scroll bars", true)
	echo(", enable scrollbars in Parthia.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display disable scrollbars", 
  [[tecSetScrollBars(false)]], 
  "Hide scroll bars", true)
	echo(", hide scrollbars in Parthia.\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
  [[tecClientDisplaySave(true)]], 
  "Save window positions", true)
	echo(", save window positions.\n")
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display load", 
  [[tecClientDisplayLoad(true)]], 
  "Load window positions", true)
	echo(", reset window positions to last save.\n")
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display reset", 
  [[tecClientDisplayReset()]], 
  "Reset window positions", true)
	echo(", reset window positions to default. "
		.."This WILL FORCE you to restart mudlet.\n")
		
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display refresh settings", 
  [[tecClientDisplayReset()]], 
  "Refresh text in settings window", true)
	echo(", clears and reloads text in settings window.\n")
			
	tecResizeDisplayHelp() --explains how to resize display
  
  tecMoveTabsHelp() --Explains how to move tabs
	
end --end tecDisplayHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientHelp()</name>
					<packageName></packageName>
					<script>function tecClientHelp()

  echo("\ntecclient command:\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient font size", 
  [[printCmdLine("tecclient font size ")]],
  "Change client font size", true)
  echo(", Change font size for all consoles.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient change colors", 
  [[tecClientChangeColors()]],
  "Change client colors", true)
  echo(", Change color scheme for client.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save all", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
  echo(", Save client and display settings to file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  echo(", Save basic client settings to file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient load", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from file", true)
  echo(", Loads client settings from file. You need to run -tecclient"
  	.." save- or -tecclient save all- to create a settings file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient reset", 
  [[tecClientReset(true);tecFileSaveSettings(true)]],
  "Reset client to default", true)
  echo(", Reset client to default client settings.\n"
  	.."Use -display reset- or -tecclient reset all- to reset display.\n")
  	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient reset all", 
  [[tecClientResetAll();tecClientSaveAll("true")]],
  "Reset all client settings to default", true)
  echo(", Reset client and display to default settings. "
  	.."Saves default settings to file and disconnects client.\n"
  	.."This command REQUIRES a restart of mudlet!\n")

end --function tecClientHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientChangeColors()</name>
					<packageName></packageName>
					<script>--lists commands that directly change colors
function tecClientChangeColorsList()
cecho("Change background color of windows that do not have text with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient windows background color colorname\n", 
  [[printCmdLine("tecclient windows background color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color nontext windows", true)

  cecho("Change background color of windows that have text in them with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient background colorname ", 
  [[printCmdLine("tecclient background ");
    cecho("You will need to restart for text background to change")]],
  "Change background color of text windows", true)
  cecho("&lt;-Restart required on Windows OS.\n")
  cecho("Command echo background must be changed in Options -&gt; Preferences -&gt; Color View -&gt; Command Background.\n")
  
  cecho("Change background color of the client's tabs with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient tabs background color colorname\n", 
  [[printCmdLine("tecclient tabs background color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color clients tabs", true)
  
  cecho("Change the color of windows and tabs as your mouse hovers over them: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient hover color colorname\n", 
  [[printCmdLine("tecclient hover color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change mouse hover color", true)
  
  cecho("Change the color help commands are highlighted in: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient helphighlight color colorname\n", 
  [[printCmdLine("tecclient helphighlight color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change help command highlight color", true)

  cecho("Change TEC's primary text color: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient text color colorname\n", 
  [[printCmdLine("tecclient text color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  cecho("Change the color of TEC's default green: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient greentext color colorname\n", 
  [[printCmdLine("tecclient greentext color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's green text color", true)
  
  cecho("Change the color of TEC's default blue: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient bluetext color colorname\n", 
  [[printCmdLine("tecclient bluetext color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's blue text color", true)
  
  cecho("Change the color approached characters appear in Room Characters window: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient approached character color colorname\n", 
  [[printCmdLine("tecclient approached character color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color approached characters in Room Character Window", true)
  
  cecho("Change the color not approached characters appear in Room Characters window: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient not approached character color colorname\n", 
  [[printCmdLine("tecclient not approached character color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color not approached characters in Room Character Window", true)
end --function tecClientChnageColorsList

--General help for changing colors.
function tecClientChangeColors()

  cecho("List all commands that change colors with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor
    .."&gt;tecclient change colors commands\n", 
  [[tecClientChangeColorsList()]],
  "Save client settings", true)
   
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  
  cecho("List colornames in main window: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;lua showColors(3)\n", 
  [[showColors(3);
    cecho("Click a color to add it to the end of the command bar")]],
  "List color names", true)
  
  cecho("Open colorname chooser window: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient colors\n", 
  [[tecColorWindow()]],
  "Open color chooser window", true)
  
  cecho("Color names in each command can be a hex color also, IE: #FF0000 is red."
    .." If you would like to use hex colors here is a ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;hex color picker.\n", 
  [[openUrl("https://www.w3schools.com/colors/colors_picker.asp")]],
  "Hex color tool", true)
  
  cecho("")

end --function tecClientChangeColors()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--[[
Due to code order requirements.
Data Functions are in Variables Data themes
]]-- 
</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Map</name>
				<packageName></packageName>
				<script>--Functions used for TEC's map system.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecMapPixelToPercent</name>
					<packageName></packageName>
					<script>--used to convert a number into what percent it would be on TECs Map 
function tecMapPixelToPercent(tecNumToConvert)
	--converts a size in pixels in reference to TECs map to a percent.
	--TECs map is 240 by 240 pixels.
	--Than adjusts with zoom.
	--Intended for calculating dimmensions of object on the map.
	return ((tonumber(tecNumToConvert) / 240) * 100) * mapZoom
end --end function tecMapPixelToPercent</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecMapIconAdjustment</name>
					<packageName></packageName>
					<script>--position a static icon on the map "probably an exit icon".
--tecIconDimmension is the height or width of the icon being positioned.
--tecMapDimmension is the height or width of the background label of the map.
--Both should be either height or width. One being a height and the other a width may result
--in incorrect icon positioning. Later map release will offer user to not have a square map, if wanted.
function tecMapIconAdjustment(tecIconDimmension, tecMapDimmension)	
	--Turn half the icons size into a percent of what it is on a tecMap 240x240
	tecIconDimmension = tecMapPixelToPercent(tecIconDimmension / 2)
	--Device the entire dimmension of the map by tecMaps 240 size.
	--Than device the % of the icon size by that resulting number.
	return tecIconDimmension / (tecMapDimmension / 240)
end --end tecMapIconAdjustment</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Settings Window</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecRefreshSettingsWindow()</name>
					<packageName></packageName>
					<script>function tecRefreshSettingsWindow()

	clearWindow("tecSettingsConsole")

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Load\n", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from last save", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Update\n", 
  [[tecGitUpdate.downloadGitReleaseJSON()]],
  "Check for updates", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Font Size\n", 
  [[printCmdLine("tecclient font size ")]],
  "Change client font size", true)
	
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Resize Windows\n", 
  [[tecResizeDisplayHelp()]],
  "Tutorial on how to resize windows", true)
  
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Move tabs\n", 
  [[tecMoveTabsHelp()]],
  "Tutorial on how to move display tabs", true)

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Change Colors\n", 
  [[tecClientChangeColors()]],
  "Change client colors", true)

  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Report Issues\n", 
  [[tecReportIssues()]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Client Help\n", 
  [[tecClientFullHelp(false, "main")]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "\n&lt;:maroon&gt;Reset\n", 
  [[tecClientResetAll()]],
  "Reset all changes to default", true)

end --function tecRefreshSettingsWindow

tecRefreshSettingsWindow()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Client</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientResetAll()</name>
					<packageName></packageName>
					<script>--Resets all client settings
function tecClientResetAll()

  --reset client settings
  tecClientReset(true)
  tecFileSaveSettings(true)
  
  --reset display settings
  tecClientDisplayReset()
  tecClientDisplaySave(true)

end --function tecClientResetAll()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Font</name>
					<packageName></packageName>
					<script>--[[
Functions that work with the font.
All windows

font like functions
setMainWindowAutoWrap() sets main windows autowrap character count, is in scripts - GUI

]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECFont</name>
						<packageName></packageName>
						<script>--Currently returns the font size.
--later hope to return font type also.
function getTECFont()
	return tecSettings.tecFontSize
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetFontSize(numbertemp)</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetFontSize(numbertemp)--set font settings with this function

	cecho("\nSetting font to: "..numbertemp.."\n")

	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if numbertemp &lt; 8 then
		numbertemp = 8
		echo("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
	
	tecSettings.tecFontSize = numbertemp or tecDefaultFontSize --set it to size passed OR default on fail
  
  --Run change for all text windows.
  for index, windowName in ipairs(tecTextWindowNames) do 
    setFontSize(windowName, tecSettings.tecFontSize)
    debugToDisplay("Font Change: Window: "..windowName.." font is now: "
      ..tecSettings.tecFontSize)
  end --for windowName in table tecTextWindowNames
  
  tecRefreshSettingsWindow() --Redraw text in setttings window.
  tecResetRoomCharacterWindow() --Redraw text in room characters window.
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.

end --end tecClientSetFontSize</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetTabFontSize</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetTabFontSize(tecTmpTabFont)--set font settings with this function
  tecTmpTabFont = tecTmpTabFont or tecSettings.tecTabsFontSize
  
	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if tecTmpTabFont &lt; 8 then
		tecTmpTabFont = 8
		cecho("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
  
  cecho("Setting tab font to: "..tecTmpTabFont.."\n")
	
	tecSettings.tecTabsFontSize = tostring(tecTmpTabFont) or tostring(tecDefaultFontSize) --set it to size passed OR default on fail
  
  --Now that the setting changed, reconfig tab settings
  tecConfigThemes()
  GUIframe.configs.tabEchoStyle = tabsFontStyle
  
  --Redraw all tabs, this includes labels.  
  tecRedrawLabels()
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.

end --end tecClientSetTabFontSize(numbertemp)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSaveWindowText(tecWindow, tecDirectory)</name>
					<packageName></packageName>
					<script>--copy text in a window to clip board
function tecSaveWindowText(tecWindow, tecDirectory)
	
	--if directory not specified default to debug folder.
	tecDirectory = tecDirectory or tecDebugSaveDir
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"

	--get total number of lines in window
	local tecWinLineCount = getLastLineNumber(tecWindow)
	--create a table with windows contents
	local windowDataToCopy = getLines(tecWindow, 1, tecWinLineCount)

	--Create a table to save to file. Has to be a file because a string can not be saved
	--to a file we specify.
	local tecWindowBufferString = "INFO: Text shown from latest line to oldest."
	--Loop through all the lines in the table created from the lines in the window.
	for i = tecWinLineCount, 1, -1 do
		--check if a password or login ID may be in the line
		if string.find(tostring(windowDataToCopy[i]), "LOGIN") 
		or string.find(tostring(windowDataToCopy[i]), "Login")
		or string.find(tostring(windowDataToCopy[i]), "login")
		or string.find(tostring(windowDataToCopy[i]), "PASSWORD")
		or string.find(tostring(windowDataToCopy[i]), "Password")
		or string.find(tostring(windowDataToCopy[i]), "password")
		then --replace them with a notice if they are
			tecWindowBufferString = tecWindowBufferString.."A login event was on this line.\n"
		else
			--Put all the lines into one easy to read string.
			tecWindowBufferString = tecWindowBufferString..tostring(windowDataToCopy[i]).."\n"
		end --if else tecWindowBufferString contains login or password
	end --for tecWinLineCount


	--Checking if folder user requested exists.
	--If it does not, then create the folder.
	--if folder created without error write the buffer string to file.
	--If a folder can not be created, output an error
  local lfs = require( "lfs" ) --load lfs module www.tutorialspoint.com/lua/lua_modules.htm
  --Attempt to change current working directory
  local tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
  if ( tecFolderExists ) then --if folder exists, can be cd into...
  	--Save window contents to file.
    io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
    io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
    io.output():close() --Close the file
		echo("Window saved\n")
  else --if the folder does not exist.
  	lfs.mkdir( tecDirectory ) --make the directory.
		tecFolderExists = nil --clear the folder check
    tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
    if ( tecFolderExists ) then --if folder exists or can be cd into.
    	--Save window to file.
      io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
      io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
      io.output():close() --Close the file
			echo("Window saved\n")
		else --the folder could not be created.
			echo("unable to create folder"..tecDirectory)
			debugToDisplay("unable to create folder"..tecDirectory)
		end --if tecFolderExists
  end --if tecFolderExists else
		
end --function tecSaveWindowText</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecOpenDirectory(tecTMPDir)</name>
					<packageName></packageName>
					<script>--opens a directory in the local browser.
--This will need to have code added to detect linux and mac.

function tecOpenDirectory(tecTMPDir)
	if getOS() == "windows" then
		os.execute("start \"\" \""..tecTMPDir.."\"") --opens explorer to the folder requested
	elseif getOS() == "mac" then
		echo("Sorry mac is currently not supported. Please open finder and go to: "
			..tecTMPDir)
	elseif getOS() == "linux" then
		echo("Sorry linux is currently not supported. Please open a file browser and go to: "
			..tecTMPDir)
	end --if os version
end --tecOpenDirectory</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>techreplace</name>
					<packageName></packageName>
					<script>function techreplace(window, text)
    if not text then text, window = window, nil end
    window = window or "main"
    local str, start, stop = getSelection(window)
    if window ~= "main" then
				selectCurrentLine(window)
				replace(window, "")
				hinsertText(window, text)
				deselect()
    else
				selectCurrentLine()
        replace("")
				hinsertText(text)
				deselect()
    end
end</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Colors</name>
					<packageName></packageName>
					<script>--[[
functions for changing colors on the client.
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>tecLabelBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the background for labels that are not tabs.
function tecLabelBackgroundColor(tecColor)
  tecSettings.labelBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecTabsBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color for tab labels
function tecTabsBackgroundColor(tecColor)
  tecSettings.tabsBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetMouseHoverColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color a label changes to when a mouse hovers over it.
function tecSetMouseHoverColor(tecColor)
  tecSettings.hoverColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetHelpHighlightColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color commands are highlighted in help menus.
function tecSetHelpHighlightColor(tecColor)
  tecSettings.helpHighlightColor = tecColor
  tecRefreshSettingsWindow() --refresh settings window text
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGreenTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetGreenTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GreenTextColor = Geyser.Color.hex(tecColor)
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBlueTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default blue text.
function tecSetBlueTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.BlueTextColor = Geyser.Color.hex(tecColor)
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for main text.
function tecSetTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.tecTextColor = Geyser.Color.hex(tecColor)
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for console background colors.
function tecSetBackgroundColor(tecColor)
  --reference: https://wiki.mudlet.org/w/Manual:Lua_Functions#setBackgroundColor
  --https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#setBgColor
  for index, windowName in ipairs(tecTextWindowNames) do
    local rb, gb, bb = Geyser.Color.parse(tecColor)
    local hexColor = Geyser.Color.hhex(rb, gb, bb)
    hexColor = hexColor:sub(2,7)
    debugToDisplay("Color Change: "..windowName.." background to "
      ..rb..","..gb..","..bb.." hex value: "..hexColor.."\n")
    setBackgroundColor(windowName, rb, gb, bb) --change background color
    setBgColor(windowName, rb, gb, bb) --change background color for cechos
    setHexBgColor(windowName, hexColor)
  end
  
  runTECRoomObjectCheck(false)
  cecho("Text box background color changes are saved by mudlet immediately.\n"
    .."If using windows you will need to restart for text background "
    .."colors to change")
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecNotApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for not approached characters.
function tecSettecNotApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.notApproachedCharacter = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for approached characters.
function tecSettecApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.ApproachedCharacters = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  cecho("Don't forget to save your changes with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  cecho("") --cechoLink does not new line itself.
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecColorWindow()</name>
						<packageName></packageName>
						<script>--Creates a window for users to easily select text.

-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs,rhs)
  local lh,ll,lv = unpack(lhs.sort)
  local rh,rl,rv = unpack(rhs.sort)
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end

-- internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a,b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname &lt; bname
end

-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  
  local d = max - min
  if max == 0 then 
    s = 0 
  else 
    s = d / max 
  end
  
  if max == min then
    h = 0 -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then h = h + 6 end
    elseif max == g then 
      h = (b - r) / d + 2
    elseif max == b then 
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  
  return h, s, v
end

-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r,g,b)
  local lum = math.sqrt( .241 * r + .691 * g + .068 * b )
  local reps = 8
  
  local h, s, v = rgbToHsv(r,g,b)
  
  local h2 = math.floor(h * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then 
    v2 = reps - v2
    lum = reps - lum
  end
  return h2, lum, v2
end

local function calc_luminosity(r,g,b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end


--- Prints out a formatted list of all available named colors (EXCEPT FOR
--- the 256 colors with names of form "ansi_###" where ### is 000 to 255),
--- optional args specifies:
--- * (number) number of columns to print in, defaults to 4;
--- * (string) substring required to match to include in output, defaults to
--- showing all if not supplied;
--- * (boolean) whether to sort the output, defaults to false.
--- @usage Print list in 4 columns by default.
---   &lt;pre&gt;
---   showColors()
---   &lt;/pre&gt;
--- @usage Print list in 2 columns.
---   &lt;pre&gt;
---   showColors(2)
---   &lt;/pre&gt;
---
--- @see color_table

function tecShowColors(...)
  local cols, search, sort = 4, "", false
  for _, val in ipairs(arg) do
    if type(val) == "string" then
      search = val:lower()
    elseif type(val) == "number" then
      cols = val
    elseif type(val) == "boolean" then
      sort = val
    end
  end
  
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if not string.find(k, "ansi_%d%d%d") then
      table.insert(colors,color)
    end
  end
  
  if sort then 
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors,sortColorsByHue) 
  end
  local i = 1
  for _, k in ipairs(colors) do
    if k.name:lower():find(search) then
      local v = k.rgb
      local fgc = "white"
      if calc_luminosity(v[1],v[2],v[3]) &gt; 0.5 then
        fgc = "black"
      end
      cechoLink("Color_Selector", string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ',fgc,k.name,k.name), [[appendCmdLine("]] .. k.name .. [[")]], table.concat(v, ", "), true)
      if i == cols then
        echo("Color_Selector","\n")
        i = 1
      else
        i = i + 1
      end
    end
  end
  if i ~= 1 then echo("\n") end
end

function tecColorWindow()
  openUserWindow("Color_Selector")
  clearUserWindow("Color_Selector")
  enableScrollBar("Color_Selector")
  tecShowColors(4)
  cecho("If the color choice window opened in an odd location "
  .."it can be moved by left clicking its title bar and dragging it.\n"
  .."It does not need to be docked at any location, it can free float anywhere "
  .."in your monitor.\nIt is also fully resizable by clicking and dragging "
  .."its outer edges.\n")
  cecho("Color_Selector",
    "\nClick a color to add it to the end of the command bar.")
end --function tecColorWindow()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecErrorNotification(errorFound)</name>
					<packageName></packageName>
					<script>--fully notifies user when an error is found.
function tecErrorNotification(errorFound)
  debugc("Error: "..errorFound)
  debugToDisplay("&lt;red:&gt;Error: "..errorFound)
  cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
    [[tecReportIssues()]],
    "Report issues or bugs", true)
  cecho("")
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Tec Git AutoUpdates</name>
					<packageName></packageName>
					<script>--Installs updates from github.
--Intended for projects that do not support protocols.
--To allow error checking package file names must end with package type starting with a capitol
--IE: "My Project Name Scripts.xml" or "MyPackageNameTriggers.xml". It must contain characters
--before the package type at the end. "Scripts.xml" Will not be tested.
--"imgs.mpackage" will not be tested.


tecGitUpdate = {} --table to hold project.
--While developing if you save this script, you will need to run the update check again
--because tecGitUpdate = {} will erase the last update check.

--start of section dedicated for functions used by update process.
--To understand the flow of updates you will need to scroll past these.
--There will be a comment stating when update flow starts.

function tecGitUpdateconfig() --Create variables used for updates

  --github latest release URL
  tecGitUpdate.gitReleaseURL = [[https://api.github.com/repos/TheEternalCitizens/mudlet-integration/releases]]
  --tecGitUpdate.gitReleaseURL = [[https://api.github.com/repos/TheEternalCitizens/mudlet-integration/nogoodurlhere]]
  tecGitUpdate.localRespitory = getMudletHomeDir().."/settings/" --local directory for source files
  if not io.exists(tecGitUpdate.localRespitory) then --if folder does not exists
    lfs.mkdir(tecGitUpdate.localRespitory) --create the folder
    debugToDisplay("Update: ERROR localRespitory was not present. Has been created.")
  end --if tecGitUpdate.localRespitory not exist
  tecGitUpdate.gitReleaseURLJSONFile = "ParthiaLatest.json" --local file name REST API latest JSON
  tecGitUpdate.localVersion = "0.1.1" --Parthia version player is currently using
  tecGitUpdate.releaseIndex = 0
  tecGitUpdate.trackedURLs = {} --will be URLs that need to have downloads tracked
  tecGitUpdate.aliasName = "tecclient update" --Name of alias user runs to process update
  trackedDownloads = {} --used to track updates.
  --The full name or a word in the file that this update script is in.
  tecGitUpdate.updateFileNameReference = "Scripts"
  tecGitUpdate.downloadError = false --Sets to true if there is a download error.
  tecGitUpdate.installationError = false --sets to true if there is a package installation error.
  
  trackedDownloads = {} --leave blank, needed for events. Is initialized in function trackDownloads
  trackedDownloads.fileList = "" --leave blank, needed for events. Initialized in function trackDownloads
  trackedDownloads.urlList = ""
  
  debugToDisplay("function tecGitUpdate.config: Initialized update engine.\n\tgitReleaseURL: "..tecGitUpdate.gitReleaseURL
    .."\n\tScriptFileNameReference: "..tecGitUpdate.updateFileNameReference
    .."\n\tlocalRespitory: "..tecGitUpdate.localRespitory
    .."\n\tgitReleaseURLJSONFile: "..tecGitUpdate.gitReleaseURLJSONFile
    .."\n\tLocal Parthia version: "..tecGitUpdate.localVersion)
end --function tecUpdate.config()
tecGitUpdateconfig() --initialize update engine on starup.

--Used to easily change update notification. There are multiple instances where
--Parthia notifies player an update is available.
local function updateAvailable(updateBody)
  enableAlias(tecGitUpdate.aliasName) --enable alias so user can run update with command
  cecho("An update is available. The new features it offers are: \n\t")
  cecho(updateBody)
  cecho("\n&lt;:maroon&gt;To update now, please run: ")
  cechoLink("&lt;:blue&gt;tecclient update", --link text to display
    [[tecGitUpdate.downloadScripts()]], --link command to run
    "Update game client", true) --link tool tip for mouse hover
  echo("\n") --cechoLinks don't cause the window to autoscroll.
end --function updateAvailable

--gather urls from github release that player needs to update to
local function collectURLs()
  if tecGitUpdate.releaseIndex == 0 then --make certain releaseIndex has been initialized
    debugc("function: collectURL, url collection releaseIndex was not initialized.")
    return "function: compareVersions, url collection releaseIndex was not initialized."
  elseif tecGitUpdate.gitJSONTable[tecGitUpdate.releaseIndex].assets.browser_download_url then
    debugc("function: collectURL, url collection JSONTable lacks assets.")
    return "function: compareVersions, url collection JSONTable lacks assets."
  else
    for index, gitAsset in --loop through git release assets.
      ipairs(tecGitUpdate.gitJSONTable[tecGitUpdate.releaseIndex].assets) do
        --save URL needing download to a new table.
        --debugc("function: compareVersions tracking URL: "..gitAsset.browser_download_url)
        tecGitUpdate.trackedURLs[index] = gitAsset.browser_download_url
    end --for tecGitUpdate.gitJSONTable[tecGitUpdate.releaseIndex].assets
    debugToDisplay("function collectURLs(): tecGitUpdate.trackedURLs initialized.") 
  end --if releaseIndex == 0
end --collectURLS

--Search for latest nonbeta release or release that is NOT a prerelease
--function is here to reduce complexity of function that calls it.
local function releaseSearch()
  if tecGitUpdate.gitJSONTable[1].name then --if the table exists
    --debugc("gitUpdate release search, JSON table exists.")
    for index, releaseData in ipairs(tecGitUpdate.gitJSONTable) do --loop through the JSON table
      --debugc("gitUpdate release search, searching index: "..tostring(index))
      debugToDisplay("function releaseSearch, searching index: "..tostring(index))
      --Find the latest release that is NOT a prerelease.
      if not releaseData.prerelease then --if the release is not a prerelease
        --debugc("gitUpdate release search, found latest release at: "..tostring(index))
        debugToDisplay("function releaseSearch, found latest release at: "..tostring(index)
          .."\n\tRelease tab_name: "..releaseData.tag_name
          .." Local release: "..tecGitUpdate.localVersion)
        --If the installed Parthia is different that latest release
        if releaseData.tag_name ~= tecGitUpdate.localVersion then
          tecGitUpdate.releaseIndex = index --collect the release index
          local errorFound collectURLs() --gather URLs into trackedURLs table
          if errorFound then --collectURLs returns a string if error occured.
            return errorFound
          else
            updateAvailable(releaseData.body) --notify player an update is available
            return
          end --if errorFound else
        end --if releaseData.prerelease.tag_name ~= tecGitUpdate.localVersion
      end --if releaseData.prerelease == "false"
    end --for
  else --if the JSON table does NOT exist.
    errorFound = "function releaseSearch, Error, JSON table not found during release search."
    return errorFound--error found stop update.
  end --if tecGitUpdate.gitJSONTable[1].name exists
end --function releaseSearch

--Tracks downloads so updates do not start until all downloads have completed.
--This has been created to allow it to be module.
--downloadURL is a table containing a urls that need to be downloaded.
--!!!trackDownloads(downloadURLs) HAS to be ran BEFORE the downloads are initiated!!!
function trackDownloads(downloadURLs)  
  if downloadURLs[1] then --if downloadURLs is a table
    debugToDisplay("function trackDownloads, table passed.")
    --move the URL containing the script name to the end of the table.
    for index, urlToTrack in ipairs(downloadURLs) do
      if urlToTrack:match(tecGitUpdate.updateFileNameReference) then
        debugToDisplay("function trackDownloads, URL containing update script was found at\n\t"
          ..urlToTrack.." moving it to end of table.")
        table.remove(downloadURLs, index) --remove the URL from the table
        table.insert(downloadURLs, urlToTrack) --insert it on the end of the table
        break --Update script can only be in one file.
      end --urlToTrack:match(tecGitUpdate.updateFileNameReference)
    end --for downloadURLs
    --Make a global table to store URLs that require tracking.
    trackedDownloads = {files = {}, URLs = {}, downloaded = {}, fileList = "", tmpFiles = {}
                        , urlList = ""}
    for index, urlToTrack in ipairs(downloadURLs) do --initialize trackedDownloads table
      --Get the name of the file you need to download.
      local tecPackageFileName = urlToTrack:match(".*%/(.*%..*)")
      --debugc("tecPackageFileName "..tecPackageFileName)
      --Collect package name removing any .s periods that are in it.
      --in git releases spaces in filenames are replaced with .s mudlets install package process
      --is sometimes not compatible with this.
      local tecPackageNameNoExtension = string.gsub(tecPackageFileName:match("(.*)%..*$"), "%.", "") 
      --debugc("tecPackageNameNoExtension: "..tecPackageNameNoExtension)
      local tecPackageNameExtensionOnly = tecPackageFileName:match(".*(%..*)$")
      --debugc("tecPackageNameExtensionOnly: "..tecPackageNameExtensionOnly)
      --Combine the package name with file extension.
      trackedDownloads.files[index] = tecPackageNameNoExtension..tecPackageNameExtensionOnly
      debugToDisplay("function: trackDownloads tracking file: "..trackedDownloads.files[index])
      --Boolean to notify client when download has completed.
      trackedDownloads.downloaded[index] = false
      --Get the name of the file you need to download.
      trackedDownloads.URLs[index] = urlToTrack
      --create a string that contains a list of files needing download.
      --This list will be used during sysDownloadDone event to veirfy the correct download
      trackedDownloads.fileList = trackedDownloads.fileList..trackedDownloads.files[index].." "
      --Used to catch download errors.
      trackedDownloads.urlList = trackedDownloads.urlList..urlToTrack.." "
    end --for downloadURLs

  elseif type(downloadURLs) == "string" then --if the variable passed is a string
    debugToDisplay("function: trackDownloads string passed.")
    debugToDisplay("function trackedDownloads: URL passed: "..downloadURLs)  
    if trackedDownloads.files[1] then --make certain the trackedDownloads table exists
      --Look through trackedDownloads table to see if this is one of the tracked URLs
      for index, trackedDownload in ipairs(trackedDownloads.files) do      
        --if the string passed matches a URL in trackedDownloads
        if trackedDownload == downloadURLs then
          debugToDisplay("function trackedDownload: download completed and recorded for: "
            ..trackedDownload)
          trackedDownloads.downloaded[index] = true --record that this URL downloaded successfully.
            --check if all downloads have completed.
            for index, urlDownloaded in ipairs(trackedDownloads.downloaded) do
              if urlDownloaded then --has the current URL affiliaed with the bool been downloaded.
                --debugc("function trackedDownloads: Verifing download completed for index "..index)
                --If all downloaded booleans in table are true.
                if index == #trackedDownloads.downloaded then
                  debugToDisplay("function trackedDownloads: downloads completed.")
                  return true --tells parthia all downloads are complete.
                end --if index == #trackedDownloads.downloaded
              else --Some file in the set has not been downloaded.
                return false --tells parthia all downloads are not complete
              end --if urlDownloaded
            end --for trackedDownloads.downloaded
          break --break the for loop.
        end --if trackedDownload == downloadURLs
      end --for trackedDownloads
    else
      --display error to debug, and return error message to called function
      errorc("function trackDownloads: was not initialized with a table of URLs.")
      return "function trackDownloads: was not initialized with a table of URLs."
    end --if downloadURLs
  else --argument was not a table or string.
    local errorFound = "function trackDownloads: does not accept "..type(downloadURLs)
      .." as an argument.\n\tOnly supports tables for initilization and strings for tracking."
    errorc(errorFound)
    return errorFound
  end --if downloadURLs type check
end --function trackDownloads

--Here moving forward if you would like to understand the flow of updates
--it starts here.

--downloads the github JSON REST API JSON file
function tecGitUpdate.downloadGitReleaseJSON()
  tecGitUpdateconfig() --initialize update engine.
  debugToDisplay("Update: Downloading "..tecGitUpdate.gitReleaseURL
    .."\n\tTo: "..tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile)
  downloadFile(tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile,
    tecGitUpdate.gitReleaseURL) --download the projects latest release JSON info file.
end --function tecVersionCheck

--after the JSON files is downloaded tecGitUpdate.eventHandler will run compareVersions

--check if version in use is the latest released
--If player is beta test we compare the latest release both prerelease and release 
--If standard player we look for latest release not prerelease
local function compareVersions()
  debugToDisplay("function compareVersions, opening &amp; reading file:\n\t"
    ..tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile)
  --open the local github latest release JSON file in read only mode
  local gitJSONFile, errorFound = 
    io.open(tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile, "r")
  if not gitJSONFile then --file was not created error occured.
    tecErrorNotification("function compareVersions: "..errorFound)
    gitJSONFile:close() --incase of partial failure, close file.
    gitJSONFile = nil
    return  --error found stop update.
  end --if not gitJSONFile
  local gitJSONString = gitJSONFile:read("*a") --read the entire file to a string
  gitJSONFile:close() --close the file
  gitJSONFile = nil
  if not gitJSONString then --the file did not read correctly.
    tecErrorNotification("function compareVersions, file read failure.\n\t"
      ..tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile)
    return --error found stop update.
  end --if not gitJSONString
  --Convert github release JSON into a table
  tecGitUpdate.gitJSONTable = yajl.to_value(gitJSONString)
  if tecGitUpdate.gitJSONTable[1].name then --if the table was made.
    debugToDisplay("function compareVersions, file read successful.")
  else --if the table was not successfully made we can not continue. Notify player.
    errorFound = "Update: Error, JSON to table conversion unsuccessfull.\n\tOpened file: "
      ..tecGitUpdate.localRespitory..tecGitUpdate.gitReleaseURLJSONFile
      .."\n\tIt contained: "..gitJSONString
    tecErrorNotification(errorFound) --Notify player provide method to report error
    return --error found stop update.
  end --tecGitUpdate.gitJSONTable exists
  
  --Look the table for the latest non beta release.
  if tecSettings.betaTester then --if player is a beta tester install latest release   
    --if latest release tag_name does not match local version number.
    debugToDisplay("Update: Release installed: "..tecGitUpdate.localVersion
      .."\n\tLatest release: "..tecGitUpdate.gitJSONTable[1].tag_name)
    if tecGitUpdate.gitJSONTable[1].tag_name ~= tecGitUpdate.localVersion then
      updateAvailable(tecGitUpdate.gitJSONTable[1].body) --notify player update is available
      tecGitUpdate.releaseIndex = 1 --notify update engine which version to use
      local errorFound collectURLs() --gather URLs into trackedURLs table
      if errorFound then
        tecErrorNotification(errorFound)
        return --error found stop update.
      end --if error found
    else
      cecho("Thank you for beta testing!\n\tNo new releases at this time.")
    end --if beta tester is not using latest release
  else --The user is not a beta tester.
    local errorFound = releaseSearch() --search for latest NONbeta release
    if errorFound then
      tecErrorNotification(errorFound)
      return --error found stop update.
    end --if error found
  end --if betaTester

  --We do not know how large the git release JSON is we will trash it just incase
  --doing this after error catch, if error is found this table will still exist
  tecGitUpdate.gitJSONTable = nil
  
end --function compareVersions

--The user has now run the command tecclient update to continue forward.

--Download the scripts in the latest release 
function tecGitUpdate.downloadScripts()
  --turn off the standard update command. So user will not attempt to run it while
  --it is running. Also leave it off so user can not process an update when one 
  --is not required.
  disableAlias(tecGitUpdate.aliasName)
  tecGitUpdate.downloadError = false --in case of previous download error.
  
  --if tecGitUpdate.trackedURLs has been initialized.
  if type(tecGitUpdate.trackedURLs[1]) == "string" then 
    trackDownloads(tecGitUpdate.trackedURLs) --initialize trackDownloads
  else --tecGitUpdate.trackedURLs was not initialized throw error.
    errorFound = "function tecGitUpdate.downloadScripts(), trackedURLs was not initialized."
    tecErrorNotification(errorFound)
    return --stop because we can not proceed.
  end --if tecGitUpdate.trackedURLs is not nil.

  --download the files required.
  for index, trackedDownload in ipairs(tecGitUpdate.trackedURLs) do
    debugToDisplay("function tecGitUpdate.downloadScripts, downloading "
      ..trackedDownload.."\n\tto "
      ..tecGitUpdate.localRespitory..trackedDownloads.files[index])
    --download file
    downloadFile(tecGitUpdate.localRespitory..trackedDownloads.files[index], trackedDownload)
  end --for tecGitUpdate.trackedURLs

--[[
  --this code can be used to test trackedDownloads without using sysDownloadDone function
  for index, trackedDownload in ipairs(tecGitUpdate.trackedURLs) do
    debugToDisplay("function tecGitUpdate.downloadScripts downloading "
      ..trackedDownload.."\n\tto "
      ..tecGitUpdate.localFileStore..trackedDownloads.files[index])
    boolOrErrorMessage = trackDownloads(trackedDownloads.files[index])
    local tmpString = tecGitUpdate.localFileStore..trackedDownloads.files[index]
    cecho("File name: "..tmpString:match(".*%/(.*%..*)$").."\n")
    cecho("fileList is: "..trackedDownloads.fileList.."\n")
    cecho("Found match in fileList for file downloaded: "..
      trackedDownloads.fileList:match(tmpString:match(".*%/(.*%..*)$")).."\n")
    if boolOrErrorMessage then
      debugToDisplay("Downloads completed!!!")
    end
  end --for tecGitUpdate.trackedURLs
]]--

end --function tecGitUpdate.downloadScripts()

--After all files have been downloaded tecGitUpdate.eventHandler will call tecInstallUpdates

local function tecInstallUpdates()
  if tecGitUpdate.downloadError then --if a download error occured.
    cecho("Download error occured. Update can not be processed.\n")
    tecGitUpdate.downloadError = false --Reset now that we have caught the error.
  end --if tecGitUpdate.downloadError
  local tecSourceDirectory = tecGitUpdate.localRespitory --Keep required data outside of tecGitUpdate
  for index, fileName in ipairs(trackedDownloads.files) do --loop through scripts, and install them
    local packageName = fileName:match("(.*)%.") --remove extension from filename
    local packageTypeList = {"alias", "trigger", "timer", "keybind", "script", 
                             "Alias", "Trigger", "Timer", "Keybind", "Script",
                             "KeyBind"}                               
    for index, packageTypeName in ipairs(packageTypeList) do
      packageType = packageName:match(packageTypeName) --find packageType in the package name
      if packageType then --package name contains a package type. Use it to error check.
        debugToDisplay("function tecInstallUpdates: Package type found, "
          ..packageType..". Error checking will be processed for" ..packageName)
        break --packageType found. Contining this would would nil packageType
      end --if packageType
    end --for ipairs(packageTypeList)
    
    --uninstallPackage(packageName) --remove old package
    --comment out uninstallPackage and uncomment raiseEvent to test without uninstalling package
    raiseEvent("sysUninstallPackage", packageName)
    
    if packageType then --package name contains a package type. Use it to error check.
      if 0 ~= exists(packageName, packageType) then --if packagename appears in mudlet
        debugToDisplay("&lt;yellow:&gt;Warning function tecInstallUpdates: appearance of the package "
          ..packageName.." in the "..packageType.." section unexpected.")
      end --if 0 ~= exists(packageName, packageType)
    end --if packageType
    
    --installPackage(tecSourceDirectory..fileName) --install new package
    --comment out installPackage and uncomment raiseEvent to test without installing package
    raiseEvent("sysInstallPackage", packageName, tecSourceDirectory..fileName)
    
    if packageType then --package name contains a package type. Use it to error check.
      if 0 == exists(packageName, packageType) then --if packageName does not exist in mudlet
        local errorFound = "function tecInstallUpdates: "..packageName.." was not found in "
          .." the "..packageType.." section. After package installation."
        tecErrorNotification(errorFound) --display error.
        tecGitUpdate.installationError = true --Notify tecInstallUpdates there is an error
      end --if 0 ~= exists(packageName, packageType)
    end --if packageType

  end --for tecUpdate.scriptNames
  
  if tecGitUpdate.installationError then --there were errors during installation.
    cecho("Errors during installation. Please report issues using the report issues button "
      .."in the settings window.\n")
    return --stop update process
  end --if tecGitUpdate.installationError
  
  debugToDisplay("Updates completed.\n")
  cecho("Updates completed.\n")
end --function tecInstallUpdates

function tecGitUpdate.eventHandler(event, ...)
  if event == "sysDownloadDone" then --if it is a downloadDone event.
    local file = arg[1] -- in this case name of file downloaded
    if string.ends(file,tecGitUpdate.gitReleaseURLJSONFile) then --download is version check file
      debugToDisplay("function tecGitUpdate.eventHandler, Download: "..file
        .."\n\tcompareVersions() called.")
      compareVersions() --Use downloaded JSON file to check if latest version is installed
    --if the name of the file being downloaded is in trackedDownloads.fileList
    elseif trackedDownloads.fileList:match(file:match(".*%/(.*%..*)$")) then
      local boolOrErrorMessage = trackDownloads(file:match(".*%/(.*%..*)$"))
          if boolOrErrorMessage then --if true, all files have downloaded.
            debugToDisplay("function tecGitUpdate.eventHandler, all downloads completed. "
              .."Running function tecInstallUpdates()")
            tecInstallUpdates() --install the downloaded scripts
          elseif type(boolOrErrorMessage) == "string" then --if error found
            tecErrorNotification(boolOrErrorMessage) --notify player of error
          else --all downloads are not completed.
            debugToDisplay(file.." completed downloading. Not all tracked files downloaded yet.")
          end --if boolOrErrorMessage
    else
      debugToDisplay("function tecGitUpdate.eventHandler, Downloaded file: "..file
        .."\n\tWas NOT caught by event handler.")
    end --elseif file downloaded is new script
  elseif event == "sysDownloadError" then --if there is a download error.
    local errorFound = arg[1] --sysDownloadError only argument is error message.
    local erroredURL = arg[1]:match(".*(https:%/%/%S+)") --retreive URL in error message
    --debugc("Errored URL: "..erroredURL)
    --if  then error download's URL matches downloads for this update engine
    if trackedDownloads.urlList:match(erroredURL) or tecGitUpdate.gitReleaseURL == erroredURL then
      tecErrorNotification("fuction tecGitUpdate.downloadErrorEventHandler, "..errorFound)
      tecGitUpdate.downloadError = true --notify tecInstallUpdates not to proceed.
    else --for any other download errors.
      debugToDisplay("fuction tecGitUpdate.downloadErrorEventHandler, "..errorFound)
    end --if trackedDownloads.urlList:match(erroredURL)
  elseif event == "sysInstallPackage" then --after a package has installed.
    local tecInstalledPackageName = arg[1] --notify 
    local tecInstalledPackageFileName = arg[2]
    debugToDisplay("function tecGitUpdate.eventHandler: "..tecInstalledPackageName.." package installed from file: "
      ..tecInstalledPackageFileName)
  elseif event == "sysUninstallPackage" then --after a package has installed.
    local tecUninstalledPackage = arg[1]
    debugToDisplay("function tecGitUpdate.eventHandler: "..tecUninstalledPackage.." package uninstalled.")
  end --if event name
end --function tecUpdate.eventHandler()

--Register event handler for downloads.
registerAnonymousEventHandler("sysDownloadDone", "tecGitUpdate.eventHandler")
registerAnonymousEventHandler("sysDownloadError", "tecGitUpdate.eventHandler")
registerAnonymousEventHandler("sysInstallPackage", "tecGitUpdate.eventHandler")
registerAnonymousEventHandler("sysUninstallPackage", "tecGitUpdate.eventHandler")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecWarningNotification(errorFound)</name>
					<packageName></packageName>
					<script>--fully notifies user when an error is found.
function tecWarningNotification(errorFound)
  debugc("Error: "..errorFound)
  debugToDisplay("&lt;yellow:&gt;Error: "..errorFound)
  cecho("&lt;Yellow:&gt;Warning: "..errorFound
    .."\n\tIf you experence issues contact a developer with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
    [[tecReportIssues()]],
    "Report issues or bugs", true)
  cecho("")
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--[[
Scripts for working with filtering the approach check command 
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>getTECRoomCheckActive()</name>
					<packageName></packageName>
					<script>function getTECRoomCheckActive()
	return tecRoomObjects.checkActive
end --end function getRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)</name>
					<packageName></packageName>
					<script>function setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)
  displayToScreen = displayToScreen or false
	tecRoomObjects.checkActive = tecRoomCheckActive
  tecRoomObjects.displayToScreen = displayToScreen --will ac . display to main
end --end function setRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="no" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--Moved to variables Data Themese - Variables script</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>runTECRoomObjectCheck(displayToScreen)</name>
					<packageName></packageName>
					<script>--used for functions that track objects in the current room.
function runTECRoomObjectCheck(displayToScreen)

  displayToScreen = displayToScreen or false --if not declared default is false

	--clear room data before running check 
	clearTECRoomObjects()

	--clear the character window.
	clearWindow("roomCharacters.console")
	
	--set a room check to true.
	setTECRoomCheckActive(true,displayToScreen)

	--send an ac . command to list characters in the room.
  send("ac .", false)

end --function runRoomCharacterCheck()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearRoomCharacterWindow()</name>
					<packageName></packageName>
					<script>function clearRoomCharacterWindow()
	clearWindow("roomCharacters.console")
  tecRoomObjects.refreshMessageDisplayed =false
end --clearRoomCharacterWindow</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRoomCharRefreshNotification()</name>
					<packageName></packageName>
					<script>local function tecRoomCharRefreshMessage()
  cecho("roomCharacters.console", "Refresh Room Characters by:\n")
  cecho("roomCharacters.console", "Runing command, ")
  cechoLink("roomCharacters.console","&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cecho("roomCharacters.console", ".\n")
  cecho("roomCharacters.console", "Pressing ctrl+R.\n")
  cecho("roomCharacters.console", "Refresh Recommended")
end --function tecRoomCharRefreshMessage()

function tecRoomCharRefreshNotification()

  if not tecRoomObjects.refreshMessageDisplayed then
    tecRoomCharRefreshMessage()
    tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
  end --if tecRefreshNotification is needed
  
end --function recRoomCharRefreshNotification()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecResetRoomCharacterWindow()</name>
					<packageName></packageName>
					<script>function tecResetRoomCharacterWindow()
  clearRoomCharacterWindow() --Room characters window no longer accurate, clear it.
  cecho("roomCharacters.console", "Populate the Room Characters window by:\n")
  cecho("roomCharacters.console", "Runing command, ")
  cechoLink("roomCharacters.console","&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cecho("roomCharacters.console", ".\n")
  cecho("roomCharacters.console", "Pressing ctrl+R.\n")
  cecho("roomCharacters.console", "\nCurrently this is not automated because TEC can only receive "
    .."one command per second.\nWe will be automating this in future releases.\n")
  tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
end --function tecResetRoomCharacterWindow</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>GUI</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>status bar</name>
				<packageName></packageName>
				<script>status_bar = Geyser.Container:new({
  name = "status_bar",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(status_bar,"status_bar","bottom")</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Health Bar</name>
					<packageName></packageName>
					<script>hpbar = Geyser.Gauge:new({
  name="hpbar",
  x=0, y=0,
  width="50%", height="50%",
},status_bar)
hpbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ffdcdc, stop: 0.1 #ff8c8c, stop: 0.49 #ff4c4c, stop: 0.5 #ff4c4c, stop: 1 #ff6666);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]) --                                                                           
hpbar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ff6666, stop: 0.1 #F05050, stop: 0.49 #E03030, stop: 0.5 #E03030, stop: 1 #E03030);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

hpbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Health&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Fatigue Bar</name>
					<packageName></packageName>
					<script>fatiguebar = Geyser.Gauge:new({
  name="fatiguebar",
  x=0, y="50%",
  width="50%", height="50%",
},status_bar)
fatiguebar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0fff0, stop: 0.1 #f0ffca, stop: 0.49 #f0d09a, stop: 0.5 #f0d09a, stop: 1 #f0d09a);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
fatiguebar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0d09a, stop: 0.1 #e0c08a, stop: 0.49 #d0b07a, stop: 0.5 #d0b07a, stop: 1 #d0b07a);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

fatiguebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Fatigue&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Hunger Bar</name>
					<packageName></packageName>
					<script>hungerbar = Geyser.Gauge:new({
  name="hungerbar",
  x="50%", y=0,
  width="50%", height="50%",
},status_bar)
hungerbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FEe0, stop: 0.1 #E6FDe0, stop: 0.49 #A0E070, stop: 0.5 #A0E070, stop: 1 #A0E070);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
hungerbar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #A0E070, stop: 0.1 #99d869, stop: 0.49 #60c830, stop: 0.5 #60c830, stop: 1 #60c830);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

hungerbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Hunger&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Encumbrance Bar</name>
					<packageName></packageName>
					<script>encumbrancebar = Geyser.Gauge:new({
  name="encumbrancebar",
  x="50%", y="50%",
  width="50%", height="50%",
},status_bar)
encumbrancebar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FBFE, stop: 0.1 #E6F8FD, stop: 0.49 #AFDDED, stop: 0.5 #AFDDED, stop: 1 #AFDDED);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
encumbrancebar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #AFDDED, stop: 0.1 #A7D7E9, stop: 0.49 #80AEC7, stop: 0.5 #80AEC7, stop: 1 #80AEC7);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

encumbrancebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Encumbrance&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>compasbar</name>
				<packageName></packageName>
				<script>--Reference https://wiki.mudlet.org/w/Manual:Geyser#Create_a_Clickable_Compass

--create compass object
--dirs directory
tecCompass = tecCompass or {
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"},
} --end tecCompass object declaration

--main container for tecCompass
tecCompass.window = Geyser.Container:new({
  name = "tecCompass",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--back label for tecCompass
tecCompass.back = Geyser.Label:new({
  name = "tecCompass.back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecCompass.window) --The parent of this label. Main is main window.

tecCompass.back:setStyleSheet(labelsStyle)

--Horizontal box
tecCompass.hbox = Geyser.HBox:new({
    name = "tecCompass.box",
    x = 0, --horizonal position in parent
    y = 0, --vertical position in parent
    width = "100%", --How wide box is, % of parent
    height = "100%", --How tall box is, % of parent
  },tecCompass.back) --parent of this Hbox

--create 3 vertical rows
--in parent object compas.box
tecCompass.row1 = Geyser.VBox:new({name = "tecCompass.row1",},tecCompass.hbox)
tecCompass.row2 = Geyser.VBox:new({name = "tecCompass.row2",},tecCompass.hbox)
tecCompass.row3 = Geyser.VBox:new({name = "tecCompass.row3",},tecCompass.hbox)

--create labels to hold compas images
--Each parent is the row that were 
--created with VBox above.
--row1 left row2 center row3 right
tecCompass.nw = Geyser.Label:new({
  name = "tecCompass.nw",
},tecCompass.row1)

tecCompass.w = Geyser.Label:new({
  name = "tecCompass.w",
},tecCompass.row1)

tecCompass.sw = Geyser.Label:new({
  name = "tecCompass.sw",
},tecCompass.row1)

tecCompass.n = Geyser.Label:new({
  name = "tecCompass.n",
},tecCompass.row2)
        
tecCompass.center = Geyser.VBox:new({
  name = "tecCompass.center",
},tecCompass.row2)

tecCompass.up = Geyser.Label:new({
  name = "tecCompass.up",
},tecCompass.center)

tecCompass.down = Geyser.Label:new({
  name = "tecCompass.down",
},tecCompass.center)

tecCompass.s = Geyser.Label:new({
  name = "tecCompass.s",
},tecCompass.row2)

tecCompass.ne = Geyser.Label:new({
  name = "tecCompass.ne",
},tecCompass.row3)
    
tecCompass.e = Geyser.Label:new({
  name = "tecCompass.e",
},tecCompass.row3)
  
tecCompass.se = Geyser.Label:new({
  name = "tecCompass.se",
},tecCompass.row3)
--end of compas labels

--when a label is clicked we want to
--go in that direction
function tecCompass.click(name)
  send(name)
end

--Function that will put images to direction labels. name will be n nw so on in tecCompass under triggers
function tecCompass.lit(name)
  tecCompass[name]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"..[[/]].."compass"..[[/]]..name..[[hover.png");
    margin: 5px;
  ]])
end
--when the space should be unlit change it back to white.
function tecCompass.unlit(name)
  tecCompass[name]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"..[[/]].."compass"..[[/]]..name..[[.png");
    margin: 5px;
  ]])
end

--Each of the 9 labels need an image of an arrow.
--Rather than setting each individually, we'll
--iterate over the tecCompass.dirs table we made 
--awhile back and add the respective image to each.
--The names of images are a reflection of the tecCompass.dirs 
--table. This keeps it consistent and easy to refer to.
--During the iteration, the callback, setLabelOnEnter and
--setLabelOnLeave are also set for each label.

--loop through dirs in table tecCompass
for k,v in pairs(tecCompass.dirs) do
  tecCompass[v]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"
		..[[/]].."compass"..[[/]]..v..[[.png");
    margin: 5px;]]) --apply pictures to directions on compass
  
	--if tecCompass is clicked, go in that direction
	tecCompass[v]:setClickCallback("tecCompass.click",v)  
end --end loop through tecCompass.dirs

--keeps the tecCompass square as the windows are adjusted.
function tecCompass.drawKeepSquare()

  --tecCompass.window:move(0,2) --small black break at top.

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_width() &lt; tecCompass.window:get_height() then
  	tecCompass.back:resize(tecCompass.window:get_width(), tecCompass.window:get_width())
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_height() &lt; tecCompass.window:get_width() then
  	tecCompass.back:resize(tecCompass.window:get_height(), tecCompass.window.height)
	end --end if height is less than width
	
end --end function keep square.

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecCompass.window,"Compass","topleft")

--Now that we created the window. Make certain it is drawn correctly.
tecCompass.drawKeepSquare() --function at the bottom of this script.</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Settings bar</name>
				<packageName></packageName>
				<script>tecSettingsBar = Geyser.Container:new({
  name = "Settings",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--box that will store the miniconsoles
tecSettingsBack = Geyser.Label:new({
  name = "tecSettingsBack",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},tecSettingsBar)

tecSettingsBack:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
tecSettingsConsole = Geyser.MiniConsole:new({
  name = "tecSettingsConsole",
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},tecSettingsBack)
tecSettingsConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
tecSettingsConsole:raise()

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecSettingsBar,"Settings","bottomleft")

function tecSettingsWindowResize()
	
	--Resize the back label by 6. We want a 3px border around the entire window
	tecSettingsBack:resize(tostring(tecSettingsBar:get_width() - 0)
		, tostring(tecSettingsBar:get_height() - 0))
	tecSettingsBack:move (0, 0) --left and top borders
	
	--Resize the room character window by 6. We want a 3px border around the entire window
	tecSettingsConsole:resize(tostring(tecSettingsBack:get_width() - 0)
		, tostring(tecSettingsBack:get_height() - 0))
	tecSettingsConsole:move (0, 0) --left and top borders
  
  tecScrollBarCheck("tecSettingsConsole") --Checks if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." tecSettingsBack width: "..tecSettingsBack:get_width()
			.." tecSettingsBack Height: "..tecSettingsBack:get_height()
			.." tecSettingsConsole Width: "..tecSettingsConsole:get_width()
			.." tecSettingsConsole Height: "..tecSettingsConsole:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecSettingsWindowResize()

tecRefreshSettingsWindow() --Refreshes text in settings window.
tecSettingsWindowResize() --resize the Room Character window now</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tec map</name>
				<packageName></packageName>
				<script>--creates tec's 2d getAllMapUserData
--future ideas. create a zoom scroll with --tecMap_back:addScrollbars(tecMap, "RV")
--will probably need to complete that function for mudlet...

--Don't forget. Creating room and exit labels ahead of time reduces the time it takes to draw
--rooms while the user is playing. Do not create a system where we create labels as they play.

tecMap = Geyser.Container:new({
  name = "TEC Map",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecMap,"TEC Map","bottomright")

--Creating the background for the 2d tec map.
tecMap_back = Geyser.Label:new({
  name = "tecMap_back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecMap) --The parent of this label.

--set the appearance of what is behind the map
tecMap_back:setStyleSheet(labelsStyle)

--rgba(25, 50, 150)

mapRoom = {} --Table to hold labels we will draw the rooms with
mapExit = {} --Table to hold labels we will draw the exits with.
--Creating empty rooms for our map system.
for i = 1, 150 do
	--Create empty room and exit labels. Hide them so no junk is on screen.
  mapRoom[i] = Geyser.Label:new({name = "mapRoom"..tostring(i),},tecMap_back) 
  mapExit[i] = Geyser.Label:new({name = "mapExit"..tostring(i),},tecMap_back) 
  mapRoom[i]:hide() --Hide the tab so they don't layer
	mapExit[i]:hide() --Hide the tab so they don't layer
end --end loop create tabs and consoles

function tecMapdrawKeepSquare()

  tecMap:move(0,0) --move the map down so there is a border on the top.
  --tecMap:resize(tecMap:get_width(), (tecMap:get_height() - 2))

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height the equal.
	if tecMap:get_width() &lt; tecMap:get_height() then
  	tecMap_back:resize(tecMap:get_width(), tecMap:get_width())
    --local centerAdjustment = ((tecMap:get_height() - tecMap_back:get_width()) * .5)
    tecMap_back:move(0,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecMap:get_height() &lt; tecMap:get_width() then
  	tecMap_back:resize(tecMap:get_height(), tecMap:get_height())
    local centerAdjustment = ((tecMap:get_width() - tecMap_back:get_height()) * .5)
    tecMap_back:move(centerAdjustment,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
	echo("tecMap_back","Please walk\nto draw map.")
  tecMap_back:raise()
	
end --end function keep square.

tecMapdrawKeepSquare() --call it to size the map properly</script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>3d map</name>
				<packageName></packageName>
				<script>--[[
threed_map = Geyser.Container:new({
  name = "3d Map",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(threed_map,"3d Map","bottomright")
]]--</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--Creates an interactive list of PC and NPCs in players current room.

roomCharacters = Geyser.Container:new({
  name = "Room Characters",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--box that will store the miniconsoles
roomCharacters.back = Geyser.Label:new({
  name = "roomCharacters.back",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},roomCharacters)

roomCharacters.back:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
roomCharacters.console = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.console", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.console:raise()

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(roomCharacters,"Room Characters","topright")

function tecCRWindowResize()
	
	--Resize the back label by keeping it square.
	roomCharacters.back:resize(tostring(roomCharacters:get_width())
		, tostring(roomCharacters:get_height()))
	roomCharacters.back:move (0, 0) --left and top borders
	
	--Resize the back label by keeping it square.
	roomCharacters.console:resize(tostring(roomCharacters.back:get_width() - 0)
		, tostring(roomCharacters.back:get_height() - 0))
	roomCharacters.console:move (0, 0) --left and top borders
  tecScrollBarCheck("roomCharacters.console") --check if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." roomCharacters.back width: "..roomCharacters.back:get_width()
			.." roomCharacters.back Height: "..roomCharacters.back:get_height()
			.." roomCharacters.console Width: "..roomCharacters.console:get_width()
			.." roomCharacters.console Height: "..roomCharacters.console:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecCRWindowResize()

tecCRWindowResize() --resize the Room Character window now
tecResetRoomCharacterWindow()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Communications Menu</name>
				<packageName></packageName>
				<script>--Communications windows at the top of the screen.

--ideas for future
--When click a tab is stays dark to show that is the active tab.
--fix the minor resizing issue with the back label not having a right margin.
--take tabs out of that damn tecComWindows table
--create the option for a combat bar. Only shows combat text...

--Origional menu from the tabs tutorial.
--Only kept it because using a lone table caused issues.
--Feelfree to take the tabs table out of the menu table.
--For me it is a logic not I just didn't feel like unting.
--menu has to be global.
tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
tecComWindows.current = tecComWindows.current or tecComWindows.tabs[1]

--A container for everything to be in.
--No size or position because that is handled
--In GUIframe
tecComWindows.container = Geyser.Container:new({
  name = "tecComWindows.container",
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecComWindows.container,"tecComWindows.container","top")

--box that will hold the tabs
tecComWindows.header = Geyser.HBox:new({
  name = "tecComWindows.header",
  x = 0, --horizontal
	y = 0, --vertical position 
  width = "100%",
  height = tabsHeight, --for now using % rather than pixel math
},tecComWindows.container)

--box that will store the miniconsoles
tecComWindows.footer = Geyser.Label:new({
  name = "tecComWindows.footer",
  x = 0, --horizontal position
	y = tabsHeight, --adjusted for tabs
  width = "100%",
	height = tecSettings.comTextWindowHeight
},tecComWindows.container)
tecComWindows.footer:setStyleSheet(labelsStyle) --set to default label style

--Create the tabs
for k,v in pairs(tecComWindows.tabs) do
  tecComWindows[v.."tab"] = Geyser.Label:new({
    name = "tecComWindows."..v.."tab",
		x = 0, --horizontal position 
		y = 0, --vertical position
		width = "100%",
		height = tabsHeight,
  },tecComWindows.header)
	
  tecComWindows[v.."tab"]:setStyleSheet(tabsStyle) --set style in themes
	
	tecComWindows[v.."tab"]:echo(tabsFontStyle..v) --lable the tabs, set style in themes

	tecComWindows[v.."tab"]:setClickCallback("tecComWindows.click",v) --for charing tabs

	--These are the miniconsoles that will hold the text
  tecComWindows[v] = Geyser.MiniConsole:new({ --tecComWindows v will be a tab name.
    name = v, --Issues experienced if I attempt to name them v.."Console"
  	x = 0, --%horizontally position in parent
  	y = 0, --%vertical position in parent
  	width = "100%", --% of parent
  	height = tecSettings.comTextWindowHeight - 1, 
		autoWrap = true, --allows text to wrap if too long
		fontSize = getTECFont(), --in variables
		font = getFont(), --get font type from main
  },tecComWindows.footer) --attach to footer show they show below tabs
	tecComWindows[v]:setColor(getBgColor()) --set miniconsoles to main consol BG color 
  tecComWindows[v]:hide() --Hide the tab so they don't layer
  if tecSettings.showScrollBars then tecComWindows[v]:enableScrollBar() end
end --end loop create tabs and consoles

function tecComWindows.click(tab) --Choose what happens when a tab is clicked.
  tecComWindows[tecComWindows.current]:hide() --Hide the current tab
  tecComWindows.current = tab --Make the clicked tab the current one.
  tecComWindows[tecComWindows.current]:show() --Show the current tab.
end --end tecComWindows.click(tab) function

--A tecComWindows has to be selected otherwise on startup it will just show.
--The label behind the tecComWindows, becuase they are hidden directly after creation.
tecComWindows[tecComWindows.current]:show()

function tecComWindowResize()
	
	--subtract GUIframe.defaults.resizeHeight from tecComWindows.footer.height 
	local tecResizedFooterHeight = tecComWindows.container:get_height() - GUIframe.defaults.resizeHeight
	local tecResizedFooterWidth = tecComWindows.container:get_width()
	tecComWindows.footer:resize(tecResizedFooterWidth, tecResizedFooterHeight) --resize the footer
	tecComWindows.footer:move(0,(tabsHeight))
	
	--reflect changes in tecSettings so there is a chance to save the size.
	tecSettings.comTextWindowHeight = tecResizedFooterHeight
	
	--resize all of the miniconsoles
	for k,v in pairs(tecComWindows.tabs) do 
  	tecComWindows[v]:move(0, 0)
  	tecComWindows[v]:resize(tecResizedFooterWidth, tecResizedFooterHeight - 1)
	end --for tecComWindows.tabs
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Communication Window, tecComWindows.footer Height: "..tecComWindows.footer:get_height()
			.." tecComWindows.ctainer Height: "..tecComWindows.container:get_height()
			.." New tecComWindows.footer Height: "..tecResizedFooterHeight
			.." mini consoles width: "..(tecResizedFooterWidth - 0).."%"
			)--end debugToDisplay
	end --end if display debug is enabled.

end --resizeKeepTabsStatis

tecComWindowResize() --resize com window</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Macro Menu</name>
				<packageName></packageName>
				<script>--[[
Tec uses a macro system that players can set within the game.
The command they use is @macro.
To avoid additional time for now we can piggy back of their system.
They support 15 gui buttons that can be macroed in the game.
All we need to do, is when the button is clicked it sends command fe#
so button 1 send("fe1")
After that TECs macro system will take over.
For formating you could set the grid style setup for labels in compasbar
I recommend having this at GUIframe location bottom left.
In 5 rows of 3 columns.
Normally does 5 columns of 3 rows. Tec has a combat rotation that requires three unique moves 
in a row or if you are attacking a person you receive a major debuff.
The 5 is while training. You need to do 5 unique moves to get the most skill points.
I like the 3 columns because it gives us big chunky buttons that will work well with touch
screens.
]]--

--Create a global table or namespace
--Creating a global table will make each of our variables unique. Our namespace will be called
--macroMenu and everything we make from here on out will be stored within the macroMenu table.

macroMenu = macroMenu or {}

--Create the container
--Containers are windows that can contain other windows. Actually, since all other Geyser windows
--subclass container, every window can do that. But containers do not have any visible content by
--themselves. Our tabbed "Macros" window will need a container. This will be the bottom layer.
--Containers are invisible, so no need to set a stylesheet. At the end of the file, we will add this
--container as a "window", which the "GUIframe" library to render for us.
macroMenu.container = Geyser.Container:new({
  name = "macroMenu",
})

--Create the parent label
--The 'parent label' refers to the label on the bottom layer. The entire macro menu will be created 
--within this label.
macroMenu.back = Geyser.Label:new({
  name = "macroMenu.back",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.container)

--Create a 3x5 grid
--The macro menu is split into 15 sections, one for each macro. This 3x5 grid is created by 5 HBoxes
--that sit within a single VBox (or vice versa, it doesn't matter). So first off, we create the VBox.
--It will be the same size as its parent, macroMenu.back.

macroMenu.box = Geyser.VBox:new({
  name = "macroMenu.box",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.back)

--Next, we create our 5 HBoxes. We don't need to specify position or size because these are placed
--within macroMenu.box, a VBox.
macroMenu.row1 = Geyser.HBox:new({
  name = "macroMenu.row1",
}, macroMenu.box)
macroMenu.row2 = Geyser.HBox:new({
  name = "macroMenu.row2",
},macroMenu.box)
macroMenu.row3 = Geyser.HBox:new({
  name = "macroMenu.row3",
}, macroMenu.box)
macroMenu.row4 = Geyser.HBox:new({
  name = "macroMenu.row4",
}, macroMenu.box)
macroMenu.row5 = Geyser.HBox:new({
  name = "macroMenu.row5",
}, macroMenu.box)

--Finally, we add our 15 labels. Take note that they are split up into five groups of three. Each group
--is placed into a different "macroMenu.row" number.
local mappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = macroMenu.row1, --the geyser box we want this label to go in
  },
  {
    name = "fe2",
    label = "II",
    row = macroMenu.row1,
  },
  {
    name = "fe3",
    label = "III",
    row = macroMenu.row1,
  },
  {
    name = "fe4",
    label = "IV",
    row = macroMenu.row2,
  },
  {
    name = "fe5",
    label = "V",
    row = macroMenu.row2,
  },
  {
    name = "fe6",
    label = "VI",
    row = macroMenu.row2,
  },
  {
    name = "fe7",
    label = "VII",
    row = macroMenu.row3,
  },
  {
    name = "fe8",
    label = "VIII",
    row = macroMenu.row3,
  },
  {
    name = "fe9",
    label = "IX",
    row = macroMenu.row3,
  },
  {
    name = "fe10",
    label = "X",
    row = macroMenu.row4,
  },
  {
    name = "fe11",
    label = "XI",
    row = macroMenu.row4,
  },
  {
    name = "fe12",
    label = "XII",
    row = macroMenu.row4,
  },
  {
    name = "fe13",
    label = "XIII",
    row = macroMenu.row5,
  },
  {
    name = "fe14",
    label = "XIV",
    row = macroMenu.row5,
  },
  {
    name = "fe15",
    label = "XV",
    row = macroMenu.row5,
  },
}

--add onto standard label. We want a small margin for this label.								
--macroLabelStyle = labelsStyle.."margin: 1px\n";
macroLabelStyle = labelsStyle

for _, mapping in pairs(mappings) do --loop trough mappings table using data within
  macroMenu[mapping.name] = Geyser.Label:new({
    name = "macroMenu." .. mapping.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. mapping.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, mapping.row) --parent is gettings passed via mapping table row reference
  macroMenu[mapping.name]:setClickCallback("onMacroClick", mapping.name)
  macroMenu[mapping.name]:setStyleSheet(macroLabelStyle) --create window layout
end

--Create a callback function
--When the user clicks a macro button, this function will send the button name to the server. For
--example, when the user clicks the first button, we will send "fe1" to the server.
function onMacroClick(name)
  send(name, false)
end

--Add the macro menu to the top left of the screen
GUIframe.addWindow(macroMenu.container, "Macros", "bottomleft")

function tecMacroMenuResize()
  --macroMenu.back:move(0,0)
end --function tecMacroMenuResize
tecMacroMenuResize()

GUIframe.activate("Macros") --Make the macros bar the active bar on bottom left.</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Events</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>guiChange()</name>
				<packageName></packageName>
				<script>--calls events that are needed when a window change occurs.
--Do NOT put any function that changes the GUI here!!!

--I am suspicious that calling multiple functions in one event is a no no
--I did this though because creating multiple AnonymousEvents caused issues.
--If I Recall the last event would not occur.

function guiChange()
	setMainWindowAutoWrap() --adjusts word wrap for user.
	if getTECDisplayDebugMode() then geyserDebug() end --if displaydebug is on
	tecCompass.drawKeepSquare()
	tecMapdrawKeepSquare()
	tecComWindowResize() --resize commmunications window
	tecCRWindowResize() --resize the Room Character window now
	tecSettingsWindowResize() --resize the Room Character window now
end --end function guiChange

--whenever event sysWindowReizeEvent occurs run setMainWindowAutowrap.
--In otherwords when any window geyser or main is CHANGED, run setMainWindowAutoWrap.
--That is NOT just resizing.
registerAnonymousEventHandler("sysWindowResizeEvent", "guiChange")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>controlInput(_, command)</name>
				<packageName></packageName>
				<script>--use bool checks to control user input.
--Use this when you do not know what will be entered but DO know a trigger that will
--occur before the command that will be sent.
function controlInput(_, tecPassword) 
  if tecPasswordEntry then --if password entry is set, we expect a password.
  	tecPasswordEntry = false --set this if check to false to it doesn't occur every input.
    --Log into the game. md5.sumhexa converts user ID and password to md5 hash.
    sendAll("USER " .. tecUsername .. "\n", "SECRET NONE", "HASH "
  	 .. md5.sumhexa(tecUsername .. tecPassword .. "NONE") .. "\n", false)
    tecUsername = nil --Clear out the username.
    clearCmdLine() --clear password from command input bar.
    denyCurrentSend() --Deny the origional command, in this case the password.
    
    --clear the password off the screen.
    local tecMainLastLine = (getLastLineNumber("main") - 1)
    moveCursor(1,tecMainLastLine) --Move cursor to second from the newest line in main console
    selectString(tecPassword,1) --Select the password in main.
    replace("Password Entered\n") --Replaced the selected password with.
    deselect() --Don't forget your deselects!
    
    tecPassword = nil --Just in case, lets make certain the password is cleared out.
    command = nil --
	end --tecPasswordEntry
end --function tecPasswordPrompt

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysDataSendRequest
registerAnonymousEventHandler("sysDataSendRequest", "controlInput")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tecExitHandler()</name>
				<packageName></packageName>
				<script>--runs when mudlet profile closes.
function tecExitHandler()
  send("logout") --Forces a complete logout of TEC
end --function tecExitHandler

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysExitEvent
registerAnonymousEventHandler("sysExitEvent", "tecExitHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Post Initilization</name>
				<packageName></packageName>
				<script>--For changing default settings that would be time consuming to change during 

--Enable or disable scroll bars. Dependant on user preference.
tecSetScrollBars(tecSettings.showScrollBars, false)

--redraw windows 
guiChange()</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
