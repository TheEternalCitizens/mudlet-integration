<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>fuzzyBoolean(bool)</name>
			<packageName></packageName>
			<script>-- Provided by demonnic
--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TextToSpeech</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>setParthiaTalk(mode)</name>
				<packageName></packageName>
				<script>function setParthiaTalk(mode)
  tecSettings.parthiaTalkEnabled = fuzzyBoolean(mode)
end --function setParthiaTalk(mode)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>getParthiaTalk()</name>
				<packageName></packageName>
				<script>function getParthiaTalk()
  return tecSettings.parthiaTalkEnabled
end --function setParthiaTalk(mode)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>parthiaTalkFilter(message)</name>
				<packageName></packageName>
				<script>function parthiaTalkFilter(message)
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "parthiaTalkFilter, was sent a non string variable. Type sent was "..tostring(type(message))
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    if getParthiaTalk() then --if parthia talk is enabled
      ttsQueue(error..errorFound) --send error to tts queue
    end --if getParthiaTalk() then
  else --message is a string, filter it
    message = string.gsub(message, '&lt;font color="#%x+"&gt;', '')
    message = string.gsub(message, [[&lt;/font&gt;]], '')
    message = string.gsub(message, "#%x+", "")
	  message = string.gsub(message, "&lt;center&gt;", "")
	  message = string.gsub(message, "&lt;/center&gt;", "")
    if message:match("think") then --if there is a thought remove &lt;&gt;
      message = string.gsub(message, [[&lt;]], '') --remove or thoughts will not read
      message = string.gsub(message, [[&gt;]], '') --remove or thoughts will not read
    end --if message:match("think")
    if not message:match("%S") then message = "" end
    --remove all multiple spaces from the talk like.
    while message:match("  ") do --loop through the line 
      message = message:gsub( "  ", " ") --remove all double spaces
    end --while parthiaTalkLine:match("  ") do
    return message --send the filtered message back
  end --if not type(message) == "string"
end --function parthiaTalkFilter(message)</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>pecho(message, talkOnly, forceSpeech)</name>
			<packageName></packageName>
			<script>function parthiaEcho(message, talkOnly, forceSpeech)
  talkOnly = fuzzyBoolean(talkOnly) --only speak do not show to screen
  forceSpeech = fuzzyBoolean(forceSpeech) --Speak even if parthia talk is disabled, for parthia talk thoughts and parthia talk speech
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "function parthiaEcho, was sent a non string variable. Type sent was "..tostring(type(message))
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    message = "Error function parthiaEcho, was sent a non string variable. Type sent was "..tostring(type(message))
  else --message is a string, display it
    if not talkOnly then cecho(message) end
    if getParthiaTalk() or forceSpeech then --if parthia talk is enabled, or forceSpeech is set
      ttsSpeak(" ") --sometimes the queue stops, this prevents that.
      message = parthiaTalkFilter(message) --filter message for tts
      if message ~= "" then ttsQueue(message) end --If there is a message send it to the tts queue
    end --if Parthia talk is enabled que the message
  end --if not type(message) == "string" then

end --function parthiaEcho(message)

pecho = parthiaEcho --make pecho a reference of parthiaEcho so it can be used as shorter reference.</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pechoLink(linkTable)</name>
			<packageName></packageName>
			<script>function pechoLink(message, command, hint, bool)

  local errorFound = false --used to detect errors

  --make certain arguments are good
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "function parthiaEcho, arg[1] message is a non string variable. Type sent was "..tostring(type(message))
  end --if not type(message) == "string"
  if not type(command) == "string" then --if the command variable is not a string
    local errorFound = "function parthiaEcho, arg[2] command is a non string variable. Type sent was "..tostring(type(command))
  end --if not type(command) == "string"
  if not type(hint) == "string" then --if the hint variable is not a string
    local errorFound = "function parthiaEcho, arg[3] hint is a non string variable. Type sent was "..tostring(type(command))
  end --if not type(hint) == "string"
  bool = true --bools in echoLinks are always true
  
  if errorFound then 
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    message = "&lt;red:&gt;Error: "..errorFound
  end --if errorFound

  cechoLink(message, command, hint, bool) --show echo to screen
  if getParthiaTalk() then --if parthia talk is enabled
    ttsSpeak(" ") --the queue stops somewhat frequently ttsSpeak starts it again
    message = parthiaTalkFilter(message) --filter message for tts
    if message ~= "" then ttsQueue(message) end --If there is a message send it to the tts queue
  end --if Parthia talk is enabled que the message
end --function pechoLink(linkTable)</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Variables Data Themese</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--[[
Used for creating variables that should be global.
Anything in the tecSettings table WILL be saved from file.
Meaning it WILL be loaded from file on a load.
]]--

function tecClientReset(displayToScreen) --reset all client settings to defaults
  if displayToScreen then echo("Please wait defaulting Parthia settings.\n") end

  --Creating a table that will be used to easily save these
  --Variables to file. So NOT putting tec.Settings. before
  --a variable will mean that it does not get saved to file.
  tecSettings = {}
  
  --folder where settings are kept. 
  --tecUpdate.versionsRespitory is in tec Auto Updates script
  tecSettingsFolder = getMudletHomeDir().."/settings/"
  
  --set primary text color in game
  --needs to be a hex number WITH # before it.
  --If the back ground is dark this will AUTOMATICALLY be changed
  --in the text filter trigger.
  tecSettings.tecTextColor = "#c0c0c0"
  
  --Changes colors because defaults have too much contrast.
  tecSettings.GreenTextColor = "#77dd77"
  tecSettings.BlueTextColor = "#8888ff"
  tecSettings.PurpleTextColor = "#cca9dd"
  tecSettings.GrayTextColor = "#646464"
  tecSettings.notApproachedCharacterColor = "#77dd77"
  tecSettings.ApproachedCharactersColor = "#ff6666"
  
  --background color for labels.
  tecSettings.labelBackgroundColor = "#537dC0"
  
  --background color for tabs.
  tecSettings.tabsBackgroundColor = "#436db0"
  
  --Color of label backgrounds and tabs as mouse hovers over them.
  tecSettings.hoverColor = "#5e8eff"
  
  --color that help text is highlighted in
  tecSettings.helpHighlightColor = "SteelBlue"
  
  --default font size. Do not save it to file.
  tecDefaultFontSize = 14
  
  --adjustable font size
  tecSettings.tecFontSize = 14
  
  --Text size applied to tabs.
  tecSettings.tecTabsFontSize = 18
  
  --enable or disable debug mode.
  --Currently display red background main line to screen.
  --The code for this is at the bottom of
  --tec client triggers - text filters - text filters
  tecSettings.tecDebugMode = false
  
  --For gui messages debug, having all this put to screen when not needed muxs things up.
  tecSettings.tecDisplayDebugMode = false
  
  --for map debug messages.
  tecSettings.tecMapDebugMode = false
  
  --Height of the communications window text area.
  tecSettings.comTextWindowHeight = 100
  
  --This line is used to buffer the main line.
  --Than we filter this line in triggers - filter text 
  --It is important that this variable be global.
  --DO NOT SAVE THIS TO FILE
  filteredLine = "Reset filteredLine."
  
  --Zoom level of the map. 
  mapZoom = 1
  
  --used to keep track of characters in current room.
  	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
  
  --stores a command list for the room character window
  --Done this way so it can be customized. 
  tecSettings.commandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.commandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  tecSettings.approachedCommandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.approachedCommandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  	
  --Used to check if a room Character check is needed.
  doRoomCharacterCheck = false

  --used for if timer debug is or is not wanted.
  tecSettings.tecTimerDebugMode = false
  
  --controls if scroll bars are of are now viewd.
  tecSettings.showScrollBars = true
  
  --Spaces inventory list 
  tecInventorySpacer = ""
  
  --use for functions that need to loop through all text windows 
  tecTextWindowNames = {"main", "tecSettingsConsole"
    ,"roomCharacters.console" , "Communication"
    ,"Thoughts", "Speech"}
    
  --Holds list of labels that use default lable stylesheet 
  tecWindowLabels = {} --normally configured with tecGetWindowLabelList
    
  tecTabNames = {} --contains names of tabs

	tecDebugSaveDir = getMudletHomeDir().."\/DebugingFiles\/"
  
  --is the player a beta tester
  tecSettings.betaTester = false
  
  --Is the player using GUIframe UI manager
  tecSettings.useGUIframe = true
  
  --Does the player want to have the player development folders managed
  tecSettings.PlayerDevelopmentSpaceEnabled = false
  
  --should keybindings to navigate with the numpad be enabled
  tecSettings.numpadNavigationEnabled = true
  
  --keep track of UI manager names. Not case sensative.
  UIManagers = { "GUIframe" , "none"}
  
  --holds geyser windows for UI manager
  tecGeyserWindows = tecGeyserWindows or {}
  
  --Used to save settings for GUI objects.
  UIManagerSettings = UIManagerSettings or {}
  
  tecSettings.parthiaTalkEnabled = false --is parthia talk enabled
  tecSettings.parthiaTalkThoughts = false --is parthia talk thoughts enabled
  tecSettings.parthiaTalkSpeech = false --is parthia talk speech enabled
  tecSettings.parthiaTalkSpeed = 6 --speed parthia talk speaks at
  tecSettings.parthiaTalkPitch = 6 --pitch parthia talk speaks in
  tecSettings.parthiaTalkVoice = "" --default voice parthia talk speaks in. No way to know what voices are supported

	if displayToScreen then pecho("Parthia settings set to default.\n") end

end --function tecClientReset()
</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--Functions that work directly with many variables that have nothing logically in common.
--For example they aren't all variables for display settings, all for font or debuging.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecFileSaveSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--Save client settings to file
function tecFileSaveSettings(displayToScreen)

--Idealy implimenting some kind of error checking would be great.
--Maybe making tecFileLoadSettings into a function that returns a table
--rather than loads the data into a global settings table

  --Save the table to file.
  table.save(tecSettingsFolder.."TECClientData.lua", tecSettings)
	
	--display save to screen
	if displayToScreen then pecho("Client settings saved.\n") end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecFileLoadSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--This perhaps should be in a sysLoadEvent

--This bugs on startup because it is calling debugToDisplay before it is declared.

--Loads variable and theme settings from file.
--Notify is boolean, to let the user know the event occured.
--In this case it is also a to screen notification that it was 
--successfull
function tecFileLoadSettings(displayToScreen)
  local tecTmpSettingsTable = {}
	--Set the location and name of file.	
	local path = tecSettingsFolder.."TECClientData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		cecho("tecDebugWindow","tecFileLoadSettings: "..path.." file doesn't exist.") --TEC debug screen
		--debugc("tecFileLoadSettings: "..path.." file doesn't exist.") --mudlets debug screen
		if displayToScreen then
      cecho("[ Info ]  - No settings file. Parthia using default settings.\n")
    end
	return --kill the function before real errors occur
	else
    table.load(path, tecTmpSettingsTable) --Load the settings in from file
    --Load settings from file updating default settings where different.
    tecSettings = table.update(tecSettings, tecTmpSettingsTable)
    if displayToScreen then 
      pecho("[  OK  ]  - Parthia settings successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
  
end --function tecFileLoadSettings

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientSaveAll(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientSaveAll(displayToScreen)
  --Save client data to file.
  tecFileSaveSettings(displayToScreen)
  --Save display data to file. 
  UIManagerFileSave(displayToScreen)
end --function tecClientSaveAll</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--used to keep track of characters in current room.
function clearTECRoomObjects()
	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
end --fuctoin clearTecRoomObjects</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Themes</name>
				<packageName></packageName>
				<script>--People expressed interest in having themes.

--Important reference for themes
--https://doc.qt.io/qt-5.12/stylesheet-reference.html
--QT style sheets don't always act they was
--standard css does. Just buggy...

--lua showColors(3) shows a color chooser on screen.
--A good reference of colors, but when we offer color custimization to users, it can give them a 
--list to choose from.

--Upgrade options.
--add these variables to tecSettings so they can be saved and loaded.


function tecConfigThemes() --configure and initalize settings for tabs.
  --Default tab height
  tabsHeight = 30
  
  --QLabels are QTs label system
  --Used here for easy hover affects
  tabsStyle = [[
  	QLabel{
  		background-color: ]]..tecSettings.tabsBackgroundColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: lightgray;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: ]]..tecSettings.tecTabsFontSize..[[px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: ]]..tecSettings.hoverColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: gray;
      border-top-left-radius: 15px;
      border-top-right-radius: 15px;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: ]]..tecSettings.tecTabsFontSize..[[px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]
  
  --This is now tabs text looks
  tabsFontStyle = [[&lt;center&gt;&lt;p style="font-size:]]
    ..tecSettings.tecTabsFontSize..[[px; color:lightgray"&gt;]]

  labelsStyle = [[
  	QLabel{
  		background-color: ]]..tecSettings.labelBackgroundColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: lightgray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: ]]..tecSettings.hoverColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: gray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]
  								
  buttonsStyle = [[QPushButton{
                  		background-color: gray;
                      border-width: 1px;
                      border-style: outset;
                      border-color: lightgray;
                      border-top-left-radius: 15px;
                      border-top-right-radius: 15px;
  										border-bottom-left-radius: 15px;
                      border-bottom-right-radius: 15px;
                      margin-right: 1px;
                      margin-left: 1px;
                  		font-size: 50px;
                      qproperty-alignment: 'AlignCenter | AlignCenter';}
  								 QPushButton::on{}
  								 QPushButton::hover{}
  ]]					
  
  --This is now tabs text looks
  buttonsFontStyle = '&lt;center&gt;&lt;p style="font-size:18px; color:white"&gt;'
  
  --Used to shape rooms on map. Intentionally left without a } at the end.
  mapRoomStyle = [[
  	QLabel{
  	border-bottom-right-radius: 3;
  	border-bottom-left-radius: 3;
  	border-top-right-radius: 3;
  	border-top-left-radius: 3;
  	margin: 2px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  ]]
  
  --Create a red style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleRed = mapRoomStyle..[[
  	background-color:  #ff6666;
    }
  ]]
  
  --Create a Green style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleGreen = mapRoomStyle..[[
  	background-color: #77dd77;
    }
  ]]
  
  --Create a white style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleWhite = mapRoomStyle..[[
  	background-color: GhostWhite;
    }
  ]]
  
  mapStraitOpenExitStyle = [[
  	QLabel{
  	background-color: GhostWhite;
  	}
  ]]
  
  mapStraitClosedExitStyle = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  
  --create table used for exits
  tecExit = { "hor", "ver", "ne", "nw" }
  
  --set the horizontal exit table
  tecExit["hor"] = {"0", "1", width, height}
  tecExit["hor"]["0"] = { tecExitStyleSheet = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  } --end tecExit["hor"][0] table declaration
  tecExit["hor"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
  tecExit["hor"].width = 10
  tecExit["hor"].height = 3
  
  --now set verticle table
  tecExit["ver"] = {"0", "1", width, height}
  tecExit["ver"]["0"] = { tecExitStyleSheet = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  } --end tecExit["ver"][0] table declaration
  tecExit["ver"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
  tecExit["ver"].width = 3
  tecExit["ver"].height = 10
  
  --Use these to adjust nenw icons
  local nenwExitIconSize = 10 --square size of icon
  
  --now set ne table
  tecExit["ne"] = {"0", "1", width, height}
  tecExit["ne"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/ne_closed.png");]]}
  tecExit["ne"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/ne_open.png");]]}
  tecExit["ne"].width = nenwExitIconSize
  tecExit["ne"].height = nenwExitIconSize
  
  --now set nw table
  tecExit["nw"] = {"0", "1", width, height}
  tecExit["nw"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/nw_closed.png");]]}
  tecExit["nw"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/nw_open.png");]]}
  tecExit["nw"].width = nenwExitIconSize
  tecExit["nw"].height = nenwExitIconSize
end --function tecConfigThemes</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Pre initialization</name>
			<packageName></packageName>
			<script>--[[
Place functions here that need to run before function and window creations.
Runs after variable creations.
Intended for setting default settings for variables and loading settings from file.
]]--

tecClientReset(false) --create default settings.

--remove all messages from tts queue
if getParthiaTalk() then ttsClearQueue() end

--Call the function so data loads when mudlet starts.
tecFileLoadSettings(true)

--Now change some settings since data has been loaded
setFontSize(tecSettings.tecFontSize) --font size

tecConfigThemes() --configure display themes</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>mudlet Communidy Functions</name>
			<packageName></packageName>
			<script>--[[
Space for mudlet functions the community makes that we need.
]]--</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.text = {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then 
      gapSpaces = 2 
    else 
      gapSpaces = 1 
    end
  end
  options.effWidth = options.width - ((options.capLen * 2) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then 
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else 
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}


function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",

  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  if type(entry) ~= "string" then
    if type(entry) == "function" then
      local entryReturn = entry()
      if type(entryReturn) ~= string and not tostring(entryReturn) then entry = 0 end
    elseif not tostring(entry) then
      entry = 0
    end
  end
  return entry
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

function demonnic.TableMaker:assemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  return sheet
end


function demonnic.TableMaker:new(options)
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>guiFramework</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2

-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.

-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.

-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.

-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.

-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.

-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.

--Do not load GUIframe script if other UI manager is in use.
if tecSettings.useGUIframe then --if using GUIframe manager

--stylesheet that is applied to resizeLabels
tecResizeLabelStyleSheet = [[
QLabel{
	border-image: url("]]..getMudletHomeDir()..[[/imgs/resize/blue_arrows_10t.png")
}
QLabel::hover{ 
	border-image: url("]]..getMudletHomeDir()..[[/imgs/resize/blue_arrows.png");
}
]]

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)

GUIframe.configs = GUIframe.configs or {}

--Default settings for display.
--These will load on a reset, and will be
--what loads when the application is run before
--saving display settings.
GUIframe.defaults = {
    tabHeight = tabsHeight,
    tabStyle = tabsStyle,
    tabEchoStyle = tabsFontStyle,
    leftStartWidth = eighthW,
    leftStartHeight = halfH,
    rightStartWidth = quarterW,
    rightStartHeight = halfH,
    topStartHeight = eighthH,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/resize/blue_arrows.png",
    resizeRestImage = "/imgs/resize/blue_arrows_20t.png",
    borderOffset = 0,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}

    tabsInfo = {
        topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
            height = configs.tabHeight},
        bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
            width = configs.leftStartWidth, height = configs.tabHeight},
        topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
            width = configs.rightStartWidth, height = configs.tabHeight},
        bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
    }
    containerInfo = {
        topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
            y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth},
        topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth}
    }
    resizeInfo = {
        resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
            y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
            y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
            y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
        resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
            y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
            width = configs.resizeWidth}
    }

    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end

    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(tecResizeLabelStyleSheet) --DaveWithTheNiceHat
        --Dave commented this out. Favoring qts hover setting over mudlets event engine.
        --done while making tooltip functions. Below code was not working with tooltip system.
        --later found the source, but left this uncommented.
        --GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        --GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
        --    string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        --GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
        --    string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    if tecSettings.showScrollBars then --if tecSettings.showScrollBars is false
      setBorderRight(configs.rightStartWidth + configs.borderOffset)
    else
      setBorderRight(-16) --hide the scroll bar off the screen.      
    end --if tecSettings.ShowScrollBars
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
            local name = tab.name:gsub("Tab","")
            local show = GUIframe.windows[name].showText
            if show then
                tab:echo(configs.tabEchoStyle..name)
            end
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container, hideText)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local showText = not hideText
        window.showText = showText
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        if showText then
            lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    local text = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
        text[con] = text[con] or {}
        text[con][k] = v.showText
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, {wname, text[con][wname]})
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(tecSettingsFolder .. "GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = tecSettingsFolder .. "GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
      debugToDisplay("function GUIframe.loadSettings, wins: "..tostring(wins)) --DaveWithTheNiceHat
        for _,name in ipairs(wins) do
            debugToDisplay("function GUIframe.loadSettings, adding window: "..tostring(name)) --DaveWithTheNiceHat
            if type(name) == "string" then
                GUIframe.addWindow(GUIframe.windows[name], name, con)
            else
                local n, s = name[1], not name[2]
                GUIframe.addWindow(GUIframe.windows[n], n, con, s)
            end
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- can be called to activate a given tab without clicking on it
function GUIframe.activate(name)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local window = GUIframe.windows[name]
	if window then
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    end
end

-- can be called to apply a style to a given tab
function GUIframe.styleTab(name, style)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local tab = GUIframe.tabs[name]
	if tab then
	    tab:setStyleSheet(style)
    end
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
    raiseEvent("GUIframe.buttonClick",name,event)
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""), not window.showText)
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
  if not tecSettings.showScrollBars then --hides scroll bar when right click button is released.
    setBorderRight(-16) --Moves the scroll bar off the screen
    debugToDisplay("GUIframe.buttonRelease: setBorderRight to -16.")
  end --DaveWithTheNiceHat
	raiseEvent("GUIframe.buttonRelease",name,event)
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
    trackTooltip("Right-click &amp; drag to resize") --DaveWithTheNiceHat
	    lbl = GUIframe[name]
	    if lbl.isClicked then
        hideWindow(tooltips.name) --avoid tooltip being chopped DaveWithTheNiceHat
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab then trackTooltip("Right-Click &amp; drag to move tab") end --DaveWithTheNiceHat
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
	raiseEvent("GUIframe.buttonMove",name,event)
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

--register the event above
registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")

end --if tecSettings.useGUIframe</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>md5</name>
				<packageName></packageName>
				<script>md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n &lt;= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big &lt; #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n &lt; 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n &gt; 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 &gt; 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TECFunctions</name>
			<packageName></packageName>
			<script>--Functions made by The Eternal Citizens
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>debug</name>
				<packageName></packageName>
				<script>--[[
Debug like functions:


]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setTECDebugMode(tectmpSetDebug)</name>
					<packageName></packageName>
					<script>--opens a debug window.
--triggers system to send debug information to it.

function setTECDebugMode(tectmpSetDebug)
	
	--Set debug mode
	tecSettings.tecDebugMode = tectmpSetDebug or false
	
	if tecSettings.tecDebugMode then --if enabling debug
		openUserWindow("tecDebugWindow")
		--saveWindowLayout() --save floating miniconsole locations
		--loadWindowLayout() --load previously save miniconsole position.
		--tecDebugWindow:addScrollbars(parent, "Vertical")
    if tecSettings.showScrollBars then enableScrollBar("tecDebugWindow") end
		pecho("Debug mode enabled.\n")
	else --else disabling debug
		pecho("Debug mode disabled.\n")
		setTECDisplayDebugMode(tectmpSetDebug)
		setTECMapDebugMode(tectmpSetDebug)
		setTECTimerDebugMode(tectmpSetDebug)
    closeUserWindow("tecDebugWindow")
	end -- if tectmpSetDebug
	
end --end function setTecDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDebugMode() 
	return tecSettings.tecDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>debugToDisplay()</name>
					<packageName></packageName>
					<script>--this takes a string from function input, and displays it to the debug screen.

--error("") Test this one.
--debugc("") fairly certain this exports to mudlets debug screen.

--Idealy we would want this function to check if a TECClient debug child window 
--Is open, and create one if it is not. Than send debug code to it rather than 
--main, where users can easily see it or mudlets debug, which is meant for true
--blue errors.
function debugToDisplay(textMessage)
	if getTECDebugMode() then --Is debug mode on?
		cecho("tecDebugWindow","\n"..textMessage) -- print message to screen
	end --if debug mode if check
end --end displayToDebug function
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyserDebug()</name>
					<packageName></packageName>
					<script>--poll GUIFrame for 
--Geyser API Reference https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html

function Geyser.Container:getDebug ()
	 
 if getTECDisplayDebugMode() then
	 
  	 local string guiLog = ""
  	 
     guiLog ="Name: "..tostring(self.name)..
		 " | Type: "..tostring(self.type)..
		 " | Parent: "..tostring(self.parent.name)..
		 " | X position: "..tostring(self:get_x())..
		 " | Y Position: "..tostring(self:get_y())..
		 " | Width: "..tostring(self:get_width())..
		 " | Height: "..tostring(self:get_height())..
		 "\n"
  	 
		 --just in case we are going to make a infinite loop killer.
		 guiloop = guiloop + 1
		 if guiloop &lt; 100 then
		 
       --Loop through all children of this container
       for k,v in pairs(self.windowList) do
    	 		
          if k ~= self then
    				guiLog = guiLog..v:getDebug() --Collect debug data to string
    					
          end --end if k not = self check
       end --end for loop pair(self windowlist)
		 end --if guiloop is less than 100
		 
		 --Returns debug data for all of the windows we have looped through
		 return guiLog
		 
	end --if getTECDisplayDebugMode()
end --end Geyser.Container:debugMode


function geyserDebug() --geyserWindow needs to be a string with the name of the window.	

	if getTECDisplayDebugMode() then --Is debug mode on?
		local debugOut = ""
    
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
  		--Send all of the windows information to the debug display.
  		guiloop = 0
  		debugToDisplay(GUIframe.topLeftContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomLeftContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomRightContainer:getDebug())
  		guiloop = 0
  		debugOut =GUIframe.topRightContainer:getDebug()
  		debugOut = debugOut:sub(1, -2)
  		debugOut = debugOut:sub(2)
  		debugToDisplay(debugOut)
  		guiloop = 0
  		debugOut = GUIframe.topContainer:getDebug()
  		debugOut = debugOut:sub(1, -2)
  		debugToDisplay(debugOut)
    end --if if GetUIManager() == "GUIframe" and GUIframe.initialized
    else --if unknown
    tecWarningNotification("function getTECDisplayDebugMode, no UI manager specified.")
	end --if tecDebugMode is true

end --end geyserDebug() function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecReportIssuesHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>--help user create an issue request
--tecBrief is if screen reporting should be brief
--tecWindow is the string name of the window to send the command help to
function tecReportIssuesHelp(tecBrief) 

	--if a window was forgotten default to main
	--tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug report issue", 
  	[[tecReportIssues()]], 
  	"Report client issues", true)
  if not tecBrief then --if we do not want to be brief
  	pecho(", Report client issues to developers.\n")
	else echo("\n")
  end --end if not tecBrief

end --function tecReportIssues

function tecReportDebugHelp()
	pecho("\n---Debug collection helper---\n")
	pecho("Please do not follow these steps unless you have opened an issue report and "
		.."were asked to collect debug data from a developer.\n"
		.."The debug modes available are: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on&lt;reset&gt;, ", 
  	[[setTECDebugMode(true)]], 
  	"Enable basic debug", true)
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on&lt;reset&gt;, ", 
  	[[setTECDisplayDebugMode(true)]], 
  	"Enable display debugging", true)
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on&lt;reset&gt;, ", 
  	[[setTECMapDebugMode(true)]], 
  	"Enable map debugging", true)
	pecho("and ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timer on&lt;reset&gt;.\n", 
  	[[setTECTimerDebugMode(true)]], 
  	"Enable timer debugging", true)
	pecho("After enabling the debug mode or modes requested clear your main window with, ") 
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[UIManagerClearMainWindow() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	pecho("Now cause the issue reported to occur. After you have disable debug mode with ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off.\n", 
  	[[setTECDebugMode(false)]], 
  	"Disable debugging", true)
	pecho("Please verify the debug window has text in it than click ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save debug window.\n", 
  	[[tecSaveWindowText("tecDebugWindow")]], 
  	"Save debug window text to file", true)
	pecho("Please save the text in the main window to file by clicking: ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	pecho("Open your issue report, at the TEC gitHub ")
	  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	pecho("Open the folder that contains the debug window text by clicking ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	pecho("Open main.txt and tecDebugWindow.txt and verify nothing is in it that you would "
		.."not want to be viewed by the public.\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Drag the files tecDebugWindow.txt and main.txt into the comment area of your "
		.."gitHub issues report.&lt;reset&gt;\n"
		.."To update your issue click the green button labeled -Comment-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --function tecReportDebugHelp()

function tecReportStandardIssue()
	pecho("\n---Create an issue request helper---\n")
	pecho("Go to the client's issue reporting gitHub page: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	pecho("Please view our current open issues to see if your issue was already reported.\n"
		.."If you have not you will need to log into gitHub.\n"
		.."To create an issue report click the green -New Issue- button, on the right side of the page.\n"
		.."A new page will load. In the -Title- section please provide a brief description of your issue\(s\).\n"
		.."In the comment section labeled -Leave a comment-. Fully describe your issue\(s\).\n"
		.."It is highly recommendable to clear you main display and recreate your issue "
		.."before continuing forward.\n"
		.."If you would like to, clear your display with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[UIManagerClearMainWindow() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	pecho("This file is called main.txt and can easily found by clicking: ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	pecho("Open main.txt and verify nothing is in it that you would not want to be viewed "
		.."by the public!\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Now drag the file main.txt into the comment area of the gitHub issues report.&lt;reset&gt;\n"
		.."At this time, please do not attach any other files to the issue report.\n"
		.."To submit your issue click the green button labeled -Submit new issue-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --end function tecReportMajorIssue

function tecReportIssues()

	pecho("&lt;black:red&gt;\nPlease follow the instructions below.\n")

	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---Start an issue request---\n", 
  	[[tecReportStandardIssue()]], 
  	"Standard issue report tutorial", true)
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---A developer asked you to enable debug---", 
  	[[tecReportDebugHelp()]], 
  	"Debug collection tutorial", true)
		
	echo("\n") --leave this as the last line. cechlink does not autoscroll main display.
	
end --function tecReportIssues</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>function setTECDisplayDebugMode(tmpDebugMode)
	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecDisplayDebugMode = tmpDebugMode or false
	
	if tecSettings.tecDisplayDebugMode then pecho("Display debug mode on.\n")
	else pecho("Display Debug Off.\n") end
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDisplayDebugMode() 
	return tecSettings.tecDisplayDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>displayDebug(textMessage)</name>
					<packageName></packageName>
					<script>--intended for sending debug messages to debug window IF display mode is enabled.
function displayDebug(textMessage)
  if getTECDisplayDebugMode() then
    debugToDisplay(textMessage)
  end -- if getTECDisplayDebugMode()
end --function displayDebug
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecColorTest()</name>
					<packageName></packageName>
					<script>--Just a simple test outputting colors to screen using three main methods.

function tecColorTest()

  echo("\ndefault text\n")
  cecho("\ncecho: &lt;:"..tecSettings.helpHighlightColor.."&gt;blue background, &lt;red:white&gt;Red text white background.\n")
  decho("\ndecho: &lt;:255,0,0&gt;Red background, &lt;0,0,255:0,255,0&gt;Blue text green background.\n")
  hecho("\nhecho: #ff0000Red text, #3c00ffBlue text.\n")

end --end tecColorTest function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECMapDebugMode(boolean)</name>
					<packageName></packageName>
					<script>function setTECMapDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecMapDebugMode = tmpDebugMode or false --enable map debug mode
	
	if tecSettings.tecMapDebugMode then pecho("Debug map mode on.\n")
	else pecho("Map Debug Off.\n") end
	
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECMapDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECMapDebugMode()
	return tecSettings.tecMapDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECTimerDebugMode(boolean)</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function setTECTimerDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode

	tecSettings.tecTimerDebugMode = tmpDebugMode or false
	if tecSettings.tecTimerDebugMode then pecho("Debug timer mode on.\n")
	else pecho("Timer Debug Off.\n") end
end --setTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECTimerDebugMode()</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function getTECTimerDebugMode()
	return tecSettings.tecTimerDebugMode
end --getTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecErrorNotification(errorFound)</name>
					<packageName></packageName>
					<script>--fully notifies user when an error is found.
function tecErrorNotification(errorFound)
  debugc("Error: "..errorFound)
  debugToDisplay("&lt;red:&gt;Error: "..errorFound)
  pecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
    [[tecReportIssues()]],
    "Report issues or bugs", true)
  cecho("")
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecWarningNotification(errorFound)</name>
					<packageName></packageName>
					<script>--fully notifies user when an error is found.
function tecWarningNotification(errorFound)
  debugc("Warning: "..errorFound)
  debugToDisplay("&lt;yellow:&gt;Warning: "..errorFound)
--  cecho("&lt;yellow:&gt;Warning: "..errorFound
--    .."\n\tIf you experence issues contact a developer with: ")
--  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
--    [[tecReportIssues()]],
--    "Report issues or bugs", true)
--  cecho("")
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Misc</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>dontForgetToSave()</name>
					<packageName></packageName>
					<script>function dontForgetToSave()
  pecho("Don't forget to save your changes:\n")
  pecho("Save all settings with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save all\n", 
  [[tecClientSaveAll(true)]],
  "Save all settings", true)
  cecho("") --cechoLink will not \n on its own.
end --function dontForgetToSave</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ReplaceStringMagicChar(tmpString)</name>
					<packageName></packageName>
					<script>--used to replace magic characters in a string with the proper escape character 
--sequence. Useful for replacing file names on sysDownload events.
function ReplaceStringMagicChar(tmpString)
  tmpString = tmpString:gsub("%%", "%%%")
  tmpString = tmpString:gsub("%(", "%%(")
  tmpString = tmpString:gsub("%)", "%%)")
  tmpString = tmpString:gsub("%.", "%%.")
  tmpString = tmpString:gsub("%+", "%%+")
  tmpString = tmpString:gsub("%[", "%%[")
  tmpString = tmpString:gsub("%^", "%%^")
  tmpString = tmpString:gsub("%$", "%%$")
  tmpString = tmpString:gsub("%-", "%%-")
  tmpString = tmpString:gsub("%*", "%%*")
  tmpString = tmpString:gsub("%?", "%%?")
return tmpString
end --function ReplaceStringMagicChar(tmpString)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>hex2rgb(hex)</name>
					<packageName></packageName>
					<script>--convert hex to RGB
function hex2rgb(hex)
    hex = hex:gsub("#","")
    return tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6))
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GetConsoleColumnCount(localConsole)</name>
					<packageName></packageName>
					<script>function GetConsoleColumnCount(localConsole)

  --get average pilxelwidth of font
  local fontWidth, _ = calcFontSize(getFontSize())
  --Get size of the entire window.
  local localConsoleWidth = localConsole:get_width()
  
  --Calculate how many characters can fit into consoles
  localConsoleColumnCount = math.floor((localConsoleWidth / fontWidth) - 1)
  
  displayDebug("function parthiaRoomCharactersWrap, Font Width: "..tostring(fontWidth)
    .." localConsoleWidth: "..tostring(localConsoleWidth)
    .." localConsoleColumnCount: "..tostring(localConsoleColumnCount))
  
  return localConsoleColumnCount
end --function parthiaRoomCharactersWrap()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI</name>
				<packageName></packageName>
				<script>--[[
for funtions that directly affect the clients GUI.

GUI

each window is added to tecGeyserWindows table via tecUIManagerRegisterWindow at startup.
Than in script "post initilization" they are loaded with UIManagerShowWindow("all", true)
to the UI manager being used.
Need to be able to not send UI manager windows that the user has removed.
Make table saveUIManagerSettings
saveUIManagerSettings[windowName].enabled saves if the window should be added to the UI manager is use.
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setMainWindowAutoWrap()</name>
					<packageName></packageName>
					<script>--set main window word wrap size.
--It is currently in the guiChange event function to be called when gui changes occur
function setMainWindowAutoWrap()

  local wrapAt = 0
  local leftSideWidth = 0
  local rightSideWidth = 0
    
  if tecSettings.showScrollBars then --if tecSettings.showScrollBars is true

    --get how many characters should appear on a line before word wrapping.
  	wrapAt = getColumnCount()
    
    displayDebug("setMainWindowAutoWrap: Wrap at: "..tostring(wrapAt) )

  else --if tecSettings.showScrollBar is false 
  
    --get average pilxelwidth of font used on main console.
    local fontWidth, fontHeight = calcFontSize(getFontSize())
  	--Get size of the entire window.
    local mainWidth, mainHeight = getMainWindowSize()
    
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
      --Get the width of left and right gui bars.
      leftSideWidth = GUIframe.topLeftContainer:get_width()
      rightSideWidth = GUIframe.topRightContainer:get_width()
    else
      tecWarningNotification("function, setMainWindowAutoWrap, leftSideWidth and "
        .."rightSideWidth are not properly initialized. UI Manager unknown.")
    end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    
    --Calculate how many characters can fit into main on average taking left and 
    --right GUI objects into consideration. Rounding down with math.floor
    wrapAt = math.floor(((mainWidth - leftSideWidth - rightSideWidth) / fontWidth) - 1)
    
  	--displays actual sizes to screen.
  	--display with setTECDebugMode(true)
  	--or command line debug on
  	displayDebug("setMainWindowAutoWrap: Font Width: "..tostring(fontWidth)
      .." Left side width: "..tostring(leftSideWidth).." Right side width: "..tostring(leftSideWidth)
      .." Main screen width: "..tostring(mainWidth)
      .." line wrap: "..tostring(wrapAt)
      .." Mains font sie: "..tostring(getFontSize())..".")
  
  end --if not tecSettings.showScrollBars
  
  --Set updated word wrap for main.
  setWindowWrap("main", tonumber(wrapAt))
  
end --end function setMainWindowAutowrap</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setInventoryFormater(setFormater)</name>
					<packageName></packageName>
					<script>function setInventoryFormater(setFormater)
  setFormater = setFormater or false
  tecFormatInventory = setFormater
end --function setInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getInventoryFormater()</name>
					<packageName></packageName>
					<script>function getInventoryFormater()
  return tecFormatInventory
end --function getInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser.Container:objectQuery()</name>
					<packageName></packageName>
					<script>function Geyser.Container:objectQuery(objectTable)
  --We are addding data to this table each loop.
  --We assume first run if a table is not passed. So we created the table.
  objectTable = objectTable or
    {name={}, type={}, parentName={}, xPos={}, yPos={}
    ,width={}, height={}}
  
  --windowList reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  --Loop through all children of this container.
  for k,v in pairs(self.windowList) do
      if k ~= self then --if the key is not this geyser object
    		  objectTable = v:objectQuery(objectTable) --query that object.
      end --end if k not = self check
  end --end for loop pair(self.windowlist)
  
--[[this.object logic can SEEM confusing. It's not.
At this point we have reach the 'bottom' of ourcontainer query.
So the last child with the last alphabetical name.
We insert our object data. Than return it. Meaning this now occurs for the second to
the last geyser object, and so on until we reach the parent that called the query.]]--
  
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#debugc
  --debugc("Geyser.Container:objectQuery: Inserting Object data for: "..self.name)
  
  --Collect this object data.
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  table.insert(objectTable.name, tostring(self.name))
  table.insert(objectTable.type, tostring(self.type))
  table.insert(objectTable.parentName, tostring(self.parent))
  table.insert(objectTable.xPos, tostring(self:get_x()))
  table.insert(objectTable.yPos, tostring(self:get_y()))
  table.insert(objectTable.width, tostring(self:get_width()))
  table.insert(objectTable.height, tostring(self:get_height()))

  return objectTable --return the table to the object that called this object
  
end --Geyser.Container:objectQuery(objectTable)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRedrawLabels()</name>
					<packageName></packageName>
					<script>--Tracks down the labels in this project, and reapplies the default stylesheet
function tecRedrawLabels()

  debugToDisplay("Labels redraw started.")

  tecConfigThemes() --redo themes data. something likely changed

  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
    --Create table to store all geyser objects within GUIframe
    ContainerDataTable = { 
      GUIframe.bottomRightContainer:objectQuery(),
      GUIframe.topLeftContainer:objectQuery(),
      GUIframe.bottomLeftContainer:objectQuery(),
      GUIframe.bottomContainer:objectQuery(),
      GUIframe.topRightContainer:objectQuery(),
      GUIframe.topContainer:objectQuery(),
      GUIframe.topLeftTabs:objectQuery(),
      GUIframe.topRightTabs:objectQuery(),
      GUIframe.bottomLeftTabs:objectQuery(),
      GUIframe.bottomRightTabs:objectQuery() }
  else --no UI manager specified.
    tecWarningNotification("function tecRedrawLabels, UI manager not specified. "
      .."Making containerDataTable a blank table.")
    ContainerDataTable = {}
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    
  --Go through all the table we created above
  for key,cdt in pairs(ContainerDataTable) do
    for k,v in pairs(cdt.type) do --Check the types of containers
      if v == "label" then --To see if it is a label
        if "map" == cdt.name[k]:match("map") then --if map label is found, skip
          --debugc("\t"..cdt.name[k].." is a map label no redraw logic in this client release.")
          debugToDisplay("\t"..cdt.name[k].." is a map label no redraw logic in this client release.")
          
        elseif "Compass." == cdt.name[k]:match("Compass.") then
          --debugc("\t"..cdt.name[k].." is a Compass label no redraw logic in this client release.")
          debugToDisplay("\t"..cdt.name[k].." is a Compass label no redraw logic in this client release.")
          if cdt.name[k] == "tecCompass.back" then --if the label is the background of the compass
            setLabelStyleSheet(cdt.name[k], labelsStyle)
            --debugc("\t"..cdt.name[k].." back of Compass applying standard label.")
            debugToDisplay("\t"..cdt.name[k].." back of Compass applying standard label.")
          end --if cdt.name[k] is tecCompass.back
        --if label has the word tab in it, we treat it as a tab  
        elseif "tab" == cdt.name[k]:match("tab") or "Tab" == cdt.name[k]:match("Tab") then
          local tabNameFound = false
          --loop though table containing tab names
          for iterator, tabName in ipairs(tecTabNames) do
            --if the tab name was found record that it was
            if tabName == cdt.name[k] then tabNameFound = true end 
          end --for ipairs(tecTabNames)
          --if the tab name was not found inthe tabname table, insert it.
          if not tabNameFound then table.insert(tecTabNames, cdt.name[k]) end
          setLabelStyleSheet(cdt.name[k],tabsStyle)
          local tmpTabName= cdt.name[k]:gsub("Tab", "") --remove Tab from name
          local tmpTabName= tmpTabName:gsub("tab", "") --remove tab from name
          local tmpTabName= tmpTabName:gsub("tecComWindows.", "") --remove tecComWindows from name
          echo(cdt.name[k], tabsFontStyle..tmpTabName) --echo name onto the tab
          --debugc("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          
        else --Reapply default style sheets to all other labels.
          setLabelStyleSheet(cdt.name[k], labelsStyle)
          --debugc("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          
        end --if check label types.
        --debugc("\tTable type: "..v.." key: "..k)
      end --if cdt.type is label
    end --for cdt
  end --for ContainerDataTable
  
  debugToDisplay("Labels redraw completed.")
  
end --function tecRedrawLabels()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecSetScrollBars(mode)</name>
					<packageName></packageName>
					<script>--Enables or disables scrollbars throughout the project.
--Providing an option to save so scroll bars will not appear automatically
function tecSetScrollBars(mode, displayToScreen)
  mode = fuzzyBoolean(mode) --verifies mode.
  displayToScreen = fuzzyBoolean(displayToScreen)
  mode = mode == nil and true or mode
  displayToScreen = displayToScreen == nil and true or displayToScreen
  tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
  
  debugToDisplay("Setting Scrollbars: ")
  
  if mode then
    --if enabling, com windows only. Settings &amp; Room Character use tecScrollBarCheck
    for index, windowName in ipairs(tecComWindows.tabs) do
      enableScrollBar(windowName)
      debugToDisplay("\tEnabling scroll bar for: "..windowName)
      --debugc("Enabling scroll bar for: "..windowName)
    end --for tecTextWindowNames
    tecSettings.showScrollBars = true --tell further gui changes to show scrollbars
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
      setBorderRight(GUIframe.topRightContainer:get_width())
    else --no UI manager specified.
      tecWarningNotification("function tecSetScrollBars, UI manager no specified. "
        .."Right border set set.")
    end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    if displayToScreen then
      pecho("Enabled scrollbars. "
        .."Some windows will not show their scrollbars until there is enough text "
        .."to need to scroll the window.\n")
    end --if displayToScreen
  else
      --disable scrollbars for all windows.
      for index, windowName in ipairs(tecTextWindowNames) do
        disableScrollBar(windowName)
        debugToDisplay("\tDisabling scroll bar for: "..windowName)
        --debugc("Disabling scroll bar for: "..windowName)
      end --for tecTextWindowNames
      tecSettings.showScrollBars = false --tell further gui changes to hide scrollbars
      setBorderRight(-16) --hide the scroll bar off the screen
      setMainWindowAutoWrap() --Adjust mains autowrap now that main has changed.
      if displayToScreen then
        pecho("Disabled scrollbars. "
          .."You will need to scroll with your mouse wheel or page up page down keys. "
          .."Main console scrollbar will reappear while moving windows.\n")
      end --if displayToScreen

  end --if mode
  
  debugToDisplay("Completed setting scroll bars.")
  
  if displayToScrenn then dontForgetToSave() end --If player ran command remind them to save.
  
end --tecSetScrollBar</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecScrollBarCheck(tecConsoleName)</name>
					<packageName></packageName>
					<script>--automatically enable a console scroll bar if it can not fit the text in it
--This works best if it is in a "sysWindowResizeEvent" function to controll the 
--drawing of a gui object.
function tecScrollBarCheck(tecConsoleName)
  tecConsoleName = tecConsoleName or "main"
  local tecSettingsRowCount = getRowCount(tecConsoleName)
  --if the window can not contain the rows of text.
  if tecSettingsRowCount &lt; getLastLineNumber(tecConsoleName) then
    --if user is allowing scroll bars, enable the scroll bar.
    if tecSettings.showScrollBars then enableScrollBar(tecConsoleName) end
  else --The window can contain the text.
    disableScrollBar(tecConsoleName)
  end --if tecSettingsRowCount less than text rows in that window.
end --function tecScrollBarCheck</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser Tooltip</name>
					<packageName></packageName>
					<script>--References for this script
--label echo| https://www.mudlet.org/geyser/files/geyser/GeyserLabel.html
--calculate window width| https://wiki.mudlet.org/w/Manual:Lua_Functions#string.len.2C_utf8.len
--Timers https://wiki.mudlet.org/w/Manual:Timer_Engine

function configTooltips()
  if not tooltips then --if tooltips table has not been created
    tooltips = {}
    tooltips.fontSize = 10 --size of the font that will appear in the Tooltip
    tooltips.timeout = 2 --how long tip stays active after mouse leaves label
    tooltips.name = "Tooltip" --name of the label
    tooltips.fontfamily = "Arial"
    tooltips.styleSheet = [[
     background-color: "#aadddd99";
     border: 2px solid #555533;
     font-family: ]]..tooltips.fontfamily..[[;
     ]]
    local _, ttTextHeight = calcFontSize(tooltips.fontSize, tooltips.fontfamily) --get width of a single font character
    tooltips.height = ttTextHeight + 8 --Height of the tool tip.
  end --if not tooltips
end --function configTooltips()
if tooltips then
  tooltips[tooltips.name] = nil
  tooltips = nil
end --Reset project data on save, so changes above are reflected after saving.

--Apply message and resize label
local function resizeToolTiplabel(TooltipText)
  --Write message on tooltip label
  tooltips[tooltips.name]:echo(TooltipText,"black","c"..tostring(tooltips.fontSize))
  local ttTextWidth, ttTextHeight = calcFontSize(tooltips.fontSize, tooltips.fontfamily) --get width of a single font character
  local toolTextLabelWidth = ttTextWidth * (utf8.len(TooltipText) + 2) --calc width of the Tooltip label
  tooltips[tooltips.name]:resize(toolTextLabelWidth, tooltips.height) --Resize tool tip to fit TooltipText
  
  if getTECDisplayDebugMode then --if display debug is enabled.
    local Pos_X, Pos_Y = getMousePosition()
    local tmpMainWidth, tmpMainHeight = getMainWindowSize()
    displayDebug("function moveTooltip, Right side of tool tip label: "
      ..(Pos_X + tooltips[tooltips.name]:get_width())
      .." main window width: "..tmpMainWidth
      .." Pos_X: "..Pos_X.." tooltip label width: "..tooltips[tooltips.name]:get_width()
      .." Width the tooltip label should be: "..toolTextLabelWidth
      .."\n\tHeight of the tooltip should be: "..tooltips.height.." Height of the tooltip is: "..tooltips[tooltips.name]:get_height())
  end --if getTECDisplayDebugMode
end --function resizeToolTipLabel

local function moveTooltip(Pos_X, Pos_Y, TooltipText)
  if not Pos_X or not Pos_Y or not TooltipText then --if data collection error occured
    debugc("function, moveTooltip: data collection error.")
    return --end call function will have unwanted outcome.
  end --if not Pos_X or not Pos_Y or not TooltipText
  local tmpMainWidth, tmpMainHeight = getMainWindowSize()
  
  resizeToolTiplabel(TooltipText) --Apply message and resize label
 
  --move tooltip label. Preventing it from scrolling out of the mudlet window where it can not be drawn
  if Pos_Y &gt; tooltips.height then --If the mouse is NOT at the top of the window
    --if the tooltip would go off the screen
    if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth then
      --if the tooltip would go off the right side of the screen
      Pos_X = Pos_X - tooltips[tooltips.name]:get_width()
    end --if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth
    tooltips[tooltips.name]:move(Pos_X+5, (Pos_Y-tooltips.height-5)) --position tooltip just above mouse
  else --if the mouse is at the top of the screen
    --if the tooltip would go off the right side of the screen
    if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth then
      --Draw tooltip label to the left of the cursor
      Pos_X = Pos_X - tooltips[tooltips.name]:get_width()
    end --if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth
    tooltips[tooltips.name]:move(Pos_X+5, (Pos_Y+tooltips.height+5)) --position tooltip just below the mouse
  end --if Pos_Y &gt; tooltips.height else

  raiseWindow(tooltips.name) -- make certain Tooltip stays on top of other labels.
  showWindow(tooltips.name) --show tool tip
end --function moveTooltip

function trackTooltip(TooltipText)
  configTooltips() --configures tooltip table if it is not already
  local Pos_X, Pos_Y = getMousePosition()
  if tooltips.timer then --if the timer exists.
    killTimer(tooltips.timer) --delete the timer to reset it at end of this function
    tooltips.timer = nil
  end--if tooltips.timer
  
  if tooltips[tooltips.name] then --if the tool tip has previously been created
    moveTooltip(Pos_X, Pos_Y, TooltipText)
  else --if the tool window has not been created.
    --create tooltip label, we will reuse this same label by moving it and hiding it.
    tooltips[tooltips.name] = Geyser.Label:new({
      name = tooltips.name,
      x = Pos_X + 5,
      y = Pos_Y - tooltips.height,
      height = tooltips.height,
      fgColor = "#000000",
      })
    resizeToolTiplabel(TooltipText) --Apply message and resize label
    setLabelStyleSheet(tooltips.name, tooltips.styleSheet)
    enableClickthrough(tooltips.name) --Do not allow label to be clicked.
    raiseWindow(tooltips.name) -- make certain Tooltip stays on top of other labels.
  end --if Tooltip
tooltips.timer = tempTimer(tooltips.timeout, [[deleteTooltip()]]) --delete tip after x+1 seconds.
end --function createTooltip(TooltipText)

function deleteTooltip()
  hideWindow(tooltips.name) --hide the tooltip label.
  killTimer(tooltips.timer) --delete the completed timer.
  tooltips.timer = nil --remove the timer ID
end

--easy method to create tool tip timer.
function SetTooltip(labelNeedingToolTip, TooltipText)
  --labelNeedingToolTip is the name of the geyser label that needs a tooltip
  --TooltipText is text to put on the tooltip label

  --occurs when mouse hovers over geyser object that needs a tool tip.
  setLabelOnEnter(labelNeedingToolTip, "trackTooltip", TooltipText)
  --hide tooltip immediately after the mouse leaves label the tool tip is for.
  --setLabelOnLeave(geyserObjectNeedingToolTip, "DeleteTooltip")
  --track mouse movement when cursor is over label.
  setLabelMoveCallback(labelNeedingToolTip, "trackTooltip", TooltipText)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getPercentOfMainWindow(percent)</name>
					<packageName></packageName>
					<script>--Returns the percent of width and height of the main window
local function getPercentOfMainWindow(percent)
	local mainWidth,mainHeight = getMainWindowSize()
	--turn number into a percent
	percent = tonumber(percent) * .01
	--return window size in %
	return (mainWidth * percent), (mainHeight * percent)
end --function getPercentOfMainWindow</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>UIManager</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>SetUIManager(UIManagerName, displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
Set UI manager mode.
Usage:
SetUIManager(UIManagerName, displayToScreen)
UIManagerName a string, the name of the UI manager you would like to set. IE: "GUIframe". Not case sensetive.
displayToScreen, true displays progress to screen, false does not.
]]--
function SetUIManager(UIManagerName, displayToScreen)
  --add UI managers in UIManagers table in the variables script.
  
  --Varify arguments are good.
  mode = fuzzyBoolean(mode) --true enables GUIFrame usage false disables it
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  local UIManagerNameCorrect = false --used later to verify correct argument sent.
  local UIManagerNameList = "" --used later to list good names in event of an error.
  if type(UIManagerName) ~= "string" then --if objectName is not a string
    tecErrorNotification("function SetUIManager, first argument is a: "
    ..type(UIManagerName).." string was expected. Use UI manager name IE: GUIframe") 
  end --if type(objectName) ~= "string"
  
  --verify correct UI manager name sent.
  for iterator, UIManager in ipairs(UIManagers) do
    if UIManager:lower() == UIManagerName:lower() then --if names match
      debugToDisplay("\tFound objectName match "..UIManagerName:lower())
      UIManagerNameCorrect = true --notify error catch, correct name sent
      UIManagerName = UIManager --Correct case sensitivity.
    end --if UIManager:lower() == UIManagerName:lower()
    UIManagerNameList = UIManager..", " --collect list of UI managers to display on error.
  end --for pairs(UIManagers)
  
  --manager name is incorrect send supported commands to player
  if not UIManagerNameCorrect then --if the wrong name was sent.
    if displayToScreen then
      pecho("User Interface managers or display manager commands are: ")
      for iterator, UIManager in ipairs(UIManagers) do --get UI manager names to click.
        local cmdToSend = [[SetUIManager( "]]..UIManager..[[",true)]] --make commandfor cechoLink
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display manager "..UIManager, 
          cmdToSend, --runs on click.
          "Set UI manager.", true)
        --add proper punctuation.
        if iterator &lt; (#UIManagers - 1) then cecho(", ") elseif iterator == (#UIManagers - 1) then pecho(" and ") end
      end --for ipairs(UIManagers)
      cecho(".\n")
      return --stop process error found
    else --if this is not being displayed to screen
      tecErrorNotification("function SetUIManager, incorrect name sent. Please use "
        .."supported names: "..UIManagerNameList)
      return --stop process error found
    end --if displayToScreen
  end --if not UIManagerNameCorrect
  
  debugToDisplay("function SetUIManager, started. UIManagerName is: "..UIManagerName
    .." displayToScreen is: "..tostring(displayToScreen))

  if UIManagerName == "GUIframe" then --if true is sent enable GUIframe
    tecSettings.useGUIframe = true
    pecho("UI manager set to GUIframe. Please restart.\n")
    tecFileSaveSettings(displayToScreen) --force a save
  elseif UIManagerName == "none" then
    tecSettings.useGUIframe = false
    setBorderSizes(0,0,0,0)
    pecho("disabled all UI managers. Please restart.\n")
    tecFileSaveSettings(displayToScreen) --force a save.
  else --if it was false disable GUIframe
    tecErrorNotification("function SetUIManager, incorrect UI Manager name after "
      .."error checking.")
    return --stop process error found
  end -- UIManagerName == series.
end --function tecSetGUIFrameMode(mode)
--SetUIManager("farts", true)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>GetUIManager()</name>
						<packageName></packageName>
						<script>--[[
Returns string name of UI manager in use or "none" if no UI manager is being used.
]]--
function GetUIManager()
  if tecSettings.useGUIframe then --using GUIframe UI manager
      return "GUIframe" --using GUIframe manager
  else 
    return "none"
  end --no UI manager found.
end --function GetUIManager
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerClearMainWindow()</name>
						<packageName></packageName>
						<script>--There is either a bug or clear working as intended.
--If we clear main. geyser objects that adopt it's background color via getBgColor
--it will error out.

function UIManagerClearMainWindow()

  --backup background color
	local br,bg,bb = getBgColor()
	
  --clear main
  clearWindow()

  --set mains background to eat it was.
	setBgColor(br,bg,bb)
	echo(" \n") --We need a line of text on the screen for getBgColor to copy from.
	
end --end function UIManagerClearMainWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerTestWindow(objectName, displayToScreen)</name>
						<packageName></packageName>
						<script>--tests if objectName is correct. If it is it returns a correctly
--capitalized objectName. If it is bad, it returns false.
function UIManagerTestWindow(objectName, displayToScreen)

  local tecWindowExists = false --used to see if objectName matches a window name.

  --Varify arguments are good.
  if type(objectName) ~= "string" then --if objectName is not a string
    tecErrorNotification("\tfunction UIManagerTestWindow, first argument is a : "
    ..type(objectName).." string was expected. Use object name IE \"Compass\"") 
    return false --end process it can not continue.
  end --if type(objectName) ~= "string"
  
  --if there are no geyser containers in tecGeyserWindows table.
  if next(tecGeyserWindows) == nil then
    tecWarningNotification("\tfunction UIManagerTestWindow, no geyser "
      .."containers in the tecGeyserWindows table. No geyser containers managed "
      .." by UI manager.")
    return false --stop to function there are no geyser containers to add to UI manager
  end --if #tecGeyserWindows == 0
  
  local tecWindowNameList = "" --will be used to list window names
  for windowName, window in pairs(tecGeyserWindows) do--loop through containers
    --if name was not specified, use the windowName in its place.
    if not window.name then 
      tecWarningNotification("function UIManagerTestWindow, name was not "
        .."specified for "..windowName.." using it's window name instead.")
      tecGeyserWindows[windowName].name = windowName 
    end --if not window.name
    if objectName:lower() == window.name:lower() then --if names match
      debugToDisplay("\tfunction tecTestUIManager, Found objectName match "..window.name:lower())
      tecWindowExists = true --notify error catch, correct name sent
      objectName = window.name --Correct case sensitivity.
    end --if objectName:lower() == window.name:lower()
    tecWindowNameList = tecWindowNameList..window.name..", " --List windows in 1 string
  end --while ipairs(tecWindowNames)tecWindowNames
  
  --check if argument passed is "all" for all windows.
  if objectName:lower() == "all" then
    debugToDisplay("\tfunction UIManagerTestWindow, Found objectName match \"all\"")
    tecWindowExists = true --notify error catch, correct name sent
    objectName = "all" --Correct case sensitivity.
  end --if objectName:lower() == "all"
  
  if not tecWindowExists then --window name does not exist.
    if displayToScreen then
    else
      tecErrorNotification("\tfunction UIManagerTestWindow, "
        .."window name: "..objectName.." not found in tecWindowNames table. "
        .."Please send a supported name. Supported names are: "..tecWindowNameList
        .."and all.")
    end --if displayToScreen
    debugToDisplay("\tfunction UIManagerTestWindow, failed to find GUIframe name matching: "..objectName)
    return  false
  end --if not tecWindowExists

  return objectName --no errors found
end --function UIManagerTestWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerShowWindow(objectName, mode, displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
control what geyesr objects show in the current UI manager.
You must first add a geyser object to tecGeyserWindows table 
To add a geyser object to the tecGeyserWindows table refer to: tecConfigGeyserWindows(clear)
objectName is the name of the geyser object.
Mode is true if you would like to add the geyser object the current UI manager
mode is false if you would like to remove the geyser object from the current UT manager
displayToScreen is true if you would like the player to see these additions or removals
]]--
function UIManagerShowWindow(objectName, mode, displayToScreen)
  
  mode = fuzzyBoolean(mode) --true enables name specified, false disables it
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  
  debugToDisplay("function UIManagerShowWindow, started. ObjectName is: "..tostring(objectName)
    .." mode is: "..tostring(mode).." displayToScreen is: "..tostring(displayToScreen))
  
  --Returns correctly capitolized window name on success or false on input failure.
  objectName = UIManagerTestWindow(objectName, displayToScreen)
  if not objectName then --objectName passed was incorrect
    if displayToScreen then
      pecho("Incorrect window name sent. Supported commands are:\n")
      for windowName, window in pairs(tecGeyserWindows) do--loop through containers
        if mode then 
          --make commandfor cechoLink
          local cmdToSend = [[UIManagerShowWindow("]]..windowName..[[",true,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display add "..windowName, 
            cmdToSend, --runs on click.
            "Add window to display", true)
          pecho(", ")
        else
          local cmdToSend = [[UIManagerShowWindow("]]..windowName..[[",false,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display remove "..windowName, 
            cmdToSend, --runs on click.
            "Remove window from display", true)
          pecho(", ")
        end --if mode
      end --for pairs(tecGeyserWindows)
      pecho("and ")
      if mode then
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display add all",
            [[UIManagerShowWindow("all",true,true)]], --runs on click.
            "Add all windows from display", true)
      else --if mode
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display remove all",
            [[UIManagerShowWindow("all",false,true)]], --runs on click.
            "remove all windows from display", true)
      end --if mode
    end --if displayToScreen
    return --error found
   end --if error found with UIManagerTestWindow
  
  if mode then --enable GUIframe object
    for windowName, window in pairs(tecGeyserWindows) do--loop through containers
        --check if objectName matches window name in loop
        --objectName == "all"| run on all windowNames
        --window.name == objectName| remove specific window sent as objectName argument
        if objectName == "all" or window.name == objectName then
          --Check if window is disabled.
          if UIManagerSettings[window.name] then 
            if UIManagerSettings[window.name].disabled then --if the window is disabled.
              if displayToScreen then
                --display a clickable command to screen
                pecho("Window "..window.name.." is currently disabled. Enable window with: ")
                local cmdToSend = [[tecEnableUIManagerWindow("]]..window.name..[[",true)]]
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display enable "..window.name, 
                  cmdToSend, --runs on click.
                  "Enable window in UI Manager", true)
              end --displayToScreen
              debugToDisplay("function UIManagerShowWindow, window: "..window.name.." is currently disable."
                ..[[enable with tecEnableUIManagerWindow("windowname",displayToScreen) or "display enable windowname"]])
              return -- do not continue window is disabled.
            end --if UIManagerSettings[window.name].disabled
          end --if UIManagerSettings[window.name]
          
          --if the UI manager is GUIframe
          if GetUIManager() == "GUIframe" then --if using GUIframe manager
            debugToDisplay("Adding "..window.name.." to "..window.GUIframeLocation..".\n")
            if displayToScreen then
              pecho("Adding "..window.name.." to "..window.GUIframeLocation..".\n")
            end --if displayToScreen
            --Add the window to GUIframe manager
            GUIframe.addWindow(tecGeyserWindows[windowName], window.name, window.GUIframeLocation)
            GUIframe.activate(windowName) --Activating the window will hide windows behind it.
          end --if GetUIManager() == "GUIframe"
          
        end --if objectName == "all" or window.name == objectName 
    end --for pairs(tecGeyserWindows)
  else --disable GUIframe object
    --loop though windows being managed.
    for windowName, window in pairs(tecGeyserWindows) do
        --objectName == "all"| run on all windowNames
        --window.name == objectName| remove specific window sent as objectName argument
        if objectName == "all" or window.name == objectName then
          if displayToScreen then echo("Removing "..objectName..".\n") end
          --if using GUIframe manager and it is initialized
          if GetUIManager() == "GUIframe" and GUIframe.initialized then 
            debugToDisplay("function UIManagerShowWindow, Removing window: "..window.name.." from GUIframe.")
            GUIframe.removeWindow(window.name) --stop displaying window in GUIframe
          end --if GetUIManager() == "GUIframe" and GUIframe.initialized
        end --if windowName == "all" or windowName == objectName
    end --for ipairs(tecWindowNames)
  end --if mode
  if guiChange then --if the guiChange function has been created
    if displayToScreen then --displayToScreen is only true when ShowWindow is run by alias, if it is false it is run by SetTheme().
      guiChange() --resize windows.
    end --if displayToScreen
  end--end if guiChange
end --function setGUIframeObject</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerRegisterWindow(geyserContainer, displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerRegisterWindow(geyserContainer, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  if not tecGeyserWindows then tecGeyserWindows = {} end --if windows table is not configured.
  local windowIsAlreadyTracked = false
  local guiFrameWindowLocations = "top topleft topright bottom bottomleft bottomright"

  if type(geyserContainer) ~= "table" then
    local errorFound = "function UIManagerRegisterWindow, was not passed a geyser container. "
      .."Stopping function, UIManagerRegisterWindow only supports geyser containers."
    tecErrorNotification(errorFound)
    error(errorFound)
  end --type(geyserContainer) ~= "table"

  if not geyserContainer.name then --if there is no name for the container.
    local errorFound = "function UIManagerRegisterWindow, geyser container passed does not have a name. "
      .." Name is required. To give it a name.\n"
      ..[[At container creation with: yourContainer = Geyser.Container:new({ name = "Name You Want"})]]
      .."\n"..[[Post creation with: yourContainer.name = "Name You Want"]]
    tecErrorNotification(errorFound)
    error(errorFound)
    return --stop function
  end -- if not geyserContainer.name
  
  --make certain GUIframeLocation is present if the framework is in use.
  if tecSettings.useGUIframe then --if using GUIframe.
    if not geyserContainer.GUIframeLocation then --if location for container in GUIframe not declared.
      local errorFound = "function UIManagerRegisterWindow, geyser container passed does not have a GUIframe location. "
        .." Not required chooses where windows starts in GUIframe layout.\n"
        ..[[After creating your geyser container add a .GUIframeLocation to the container table. ]]
        ..[[with: yourContainer.GUIframeLocation = "location"\n Supported locations are: ]]
        ..guiFrameWindowLocations
        .."\nUsing default location topleft"
      tecWarningNotification(errorFound)
      geyserContainer.GUIframeLocation ="topleft"
    end --if not geyserContainer.GUIframeLocation
    --make it lower case so we can easily check it
    geyserContainer.GUIframeLocation = geyserContainer.GUIframeLocation:lower()
    --if wrong GUIframe window location sent.
    if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation) then
      local errorFound = "function UIManagerRegisterWindow, geyser contains a bad GUIframeLocation. "
        .."Supported locations are: "..guiFrameWindowLocations
        ..". Using default location topleft."
        tecErrorNotification(errorFound)
        geyserContainer.GUIframeLocation = "topleft"
    end --if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation)
  end --if tecSettings.useGUIframe
  
  debugToDisplay("function UIManagerRegisterWindow, tecGeyserWindows table contains: ")
  --loop throgh geyser table
  for key, window in pairs(tecGeyserWindows) do
    debugToDisplay("\tWindow name: "..window.name)
    --if window passed already in table
    if window.name:lower() == geyserContainer.name:lower() then
      debugToDisplay("\tFound "..geyserContainer.name:lower()
        .." in tecGeyserWindows table. It is already being manged by UI manager.")
--      windowIsAlreadyTracked = true --notify function container already in table.
    end --if window.name:lower() == geyserContainer:lower()
  end --for pairs(tecGeyserWindows)
  
  if windowIsAlreadyTracked then --container already exists in table.
    if displayToScreen then --Display to player.
      echo(geyserContainer.name.." is already being managed by UI manager.\n")
    else --if we do not show user.
      tecWarningNotification("function UIManagerRegisterWindow, container "..geyserContainer.name
        .." already in tecGeyserWindows table. Already tracked by UI Manager.")
    end --if displayToScreen
  else --container not already in tecGeyserWindows table.

    debugToDisplay("function UIManagerRegisterWindow, adding "..geyserContainer.name.." to tecGeyserWindows table.")
--    if tecGeyserWindows[geyserContainer.name] then --container name is already in table.
--      tecErrorNotification("function UIManagerRegisterWindow, tecGeyserWindows has a table named "
--        ..geyserContainer.name)
--      return --end function
--    else -- tecGeyserWindows[geyserContainer.name] does not exist
      tecGeyserWindows[geyserContainer.name] = geyserContainer
      if not tecGeyserWindows[geyserContainer.name].name then --container did not add
        local errorFound = "function UIManagerRegisterWindow, "..geyserContainer.name
          .." was not correctly added to tecGeyserWindows table. It is not being managed "
          .." by UI manager."
        tecErrorNotification(errorFound)
        error(errorFound)
      end 
--    end --if tecGeyserWindows[geyserContainer.name]
    if displayToScreen then --Display to player.
      pecho("Adding "..geyserContainer.name.." to interface manager "..GetUIManager()..".\n")
    end --if displayToSreen
    tecGeyserWindows[geyserContainer.name]:hide() --hide the window it is not in a UI yet
    --UIManagerShowWindow(geyserContainer.name, true, displayToScreen)
  end --if windowIsAlreadyTracked
end --function UIManagerRegisterWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerEnableWindow(objectName, mode, displayToScreen)</name>
						<packageName></packageName>
						<script>--enables a window after it has been disabled.
function UIManagerEnableWindow(objectName, mode, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  local unchangedObjectName = objectName

  debugToDisplay("function UIManagerEnableWindow, started. ObjectName is: "..tostring(objectName)
    .." mode is "..tostring(mode).." displayToScreen is: "..tostring(displayToScreen))

  --Returns correctly capitolized window name on success or false on input failure.
  objectName = UIManagerTestWindow(objectName, displayToScreen)
  if not objectName then --objectName passed was incorrect
    if (unchangedObjectName:lower()):match("list") then --if the we receive a list request
      pecho("Supported ")
      if mode then pecho("enable ") 
      else pecho("disable ") end
      pecho("commands are: ")
    else 
      pecho(unchangedObjectName.." is not a managed window. Supported commands are: ")
    end
    if mode then--if enable was wanted
      if displayToScreen then
        for windowName, window in pairs(tecGeyserWindows) do--loop through containers
            --make commandfor cechoLink
            local cmdToSend = [[UIManagerEnableWindow("]]..windowName..[[",true,true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window enable "..windowName, 
              cmdToSend, --runs on click.
              "Enable "..windowName.." window", true)
            pecho(", ")
        end --for pairs(tecGeyserWindows)
        pecho("and ")
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window enable all",
              [[UIManagerEnableWindow("all",true,true)]], --runs on click.
              "Enable all windows", true)
      end --if displayToScreen
    else --disable windows sent
      if displayToScreen then
        for windowName, window in pairs(tecGeyserWindows) do--loop through containers
            --make commandfor cechoLink
            local cmdToSend = [[UIManagerEnableWindow("]]..windowName..[[",false,true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window disable "..windowName, 
              cmdToSend, --runs on click.
              "Disable "..windowName.." window", true)
            pecho(", ")
        end --for pairs(tecGeyserWindows)
        pecho("and ")
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window disable all",
              [[UIManagerEnableWindow("all",false,true)]], --runs on click.
              "Disable all windows", true)
      end --if displayToScreen
    end --if mode
    pecho("\n")
    return --error found
   end --if error found with UIManagerTestWindow

  --make certain the window is going to an enabled side.
  --if it is not, send it to a good side.
  --If neither left or right side is enabled show a message.
  for windowName, window in pairs(tecGeyserWindows) do --loop through managed containers
    if objectName == "all" or window.name == objectName then --if matches the argument passed
      if mode then --if request is to enable.
        local windowLocationGood = true --tell function if the GUIFrameLocation is good
        if GetUIManager() == "GUIframe" then --if using GUIframe
          local tmpSidesTable = {"left", "right", "top", "bottom"} --used to test sides
          local tmpWindowLocation = window.GUIframeLocation:lower() --
          local tmpEnabledSideFound = false --used to tell function that an enabled side was found
          --if this window is about to  go to a side that is disabled, change the side.
          for _, tmpSide in ipairs(tmpSidesTable) do --loop through sides
            if not UIManagerSettings.PlayersTheme.borders[tmpSide] then --if the side is disabled
              local localGUIframeLocatioDisabled = false
              --check if the side the window is going to is disabled
              if table.contains({"top","bottom"}, tmpSide) then --if the disabled side is the top or bottom
                if tmpWindowLocation == tmpSide then --if the window is going to a disabled side
                  localGUIframeLocatioDisabled = true
                end --if tmpWindowLocation == tmpSide
              end --if table.contains({"top","bottom"}, tmpSide)
              if table.contains({"right","left"}, tmpSide) then--if the disabled side is the left or right
                if tmpWindowLocation:match(tmpSide) then --if the window is going to a disabled side
                  localGUIframeLocatioDisabled = true
                end --if tmpWindowLocation:match("left") or tmpWindowLocation:match("right")
              end --table.contains({"right","left"}, tmpSide)
              
              if localGUIframeLocatioDisabled then --if the side the window is going to is disabled
                for _, tmpSideModeCheck in ipairs({"left", "right"}) do --loop through sides
                  --check the left and right sides, windows added to those can be moved.
                  --Because of lack of layering support we do not want to place a window 
                  --on the top or bottom. Because it will cover windows already there.
                  if UIManagerSettings.PlayersTheme.borders[tmpSideModeCheck] then --if side is enabled
                    local errorFound = "Window "..window.name.. " is set to go to the "
                      ..window.GUIframeLocation.." of the screen. The "..tmpSide
                      .." side of the screen is disabled. Sending the window to the "
                      .."top"..tmpSideModeCheck.." of the screen."
                    window.GUIframeLocation = "top"..tmpSideModeCheck
                    tmpEnabledSideFound = true --tell function an enabled side was found
                    debugToDisplay("function UIManagerEnableWindow, "..errorFound)
                    if displayToScreen then cecho(errorFound.."\n") end
                  end --if UIManagerSettings.PlayersTheme.borders[tmpSide]
                end --for _, tmpSideModeCheck in ipairs(tmpSidesTable)
                if not tmpEnabledSideFound then --if both left and right sides are disabled.
                  local errorFound = "Both left and right sides of display are disabled. "
                    .."window "..window.name.." is set to go to the "..window.GUIframeLocation
                    .." of the screen. Left or right side of the screen must be enabled for this "
                    .."window to be added to display."
                  tecWarningNotification("function UIManagerEnableWindow, "..errorFound)
                  if displayToScreen then pecho(errorFound.."\n") end
                  windowLocationGood = false --stop this window from being enabled.
                  --tell the UI manager not to load window
                  UIManagerSettings[window.name].disabled = true 
                end --if not tmpEnabledSideFound
              end --if window.GUIframelocation:match(tmpSide)
            end --if not UIManagerSettings.PlayersTheme.borders[tmpSide]
          end --ipairs(tmpSidesTable)
        end --if GetUIManager() == "GUIframe"
      
        if windowLocationGood then --the GUIframeLocation checked good above.
          debugToDisplay("function UIManagerEnableWindow, Enabling window: "..window.name)
          if displayToScreen then pecho("Enabling window: "..window.name..".\n") end --if displayToScreen
          if not UIManagerSettings[window.name] then UIManagerSettings[window.name] = {} end --if the table does not exist, create it.
          UIManagerSettings[window.name].disabled = false --enable the window.
          UIManagerShowWindow(window.name,mode,displayToScreen) --display the window again.
        end --if windowLocationGood
      else --mode is false, we are disabling the window.
        --if window name is not in UIManagerSettings table, create a table for the window.
        if not UIManagerSettings[window.name] then UIManagerSettings[window.name] = {} end 
        UIManagerSettings[window.name].disabled = true --tell the UI manager not to load window

        --if using GUIframe
        if GetUIManager() == "GUIframe" and GUIframe.initialized then --if using GUIframe
          if GUIframe.windows[window.name] then --if the window exists.
            debugToDisplay("function UIManagerEnableWindow, removing: "..window.name
              .." from GUIframe.windows table.")
            UIManagerShowWindow(window.name,mode,displayToScreen) --hide the window
            GUIframe.windows[window.name] = nil --remove window from GUIframe so it does not get saved
          else --if the window does not exist in GUIframe already.
            debugToDisplay("function UIManagerEnableWindow, window "..window.name
              .." does not exist in GUIframe.windows table, nothing to remove.")
          end --if GUIframe.windows[window.name]
          if getTECDisplayDebugMode then --if display debug is enabled.
            displayDebug("function UIManagerEnableWindow, GUIframe.windows now looks like: ")
            for tmpWindowName, tmpWindow in pairs(GUIframe.windows) do
              displayDebug("\tWindow name: "..tmpWindowName)
            end --for pairs(GUIframe.windows)
          end --if getTECDisplayDebugMode
        end --if GetUIManager() == "GUIframe" and GUIframe.initialized
        --display message to player. Window disabled.
        if displayToScreen then pecho(window.name.." disabled.\n") end --if displayToScreen
      end --if mode
    end --if objectName == "all" or window.name == objectName
  end --for pairs(tecGeyserWindows)
  
  --if guiChange then guiChange() end--redraw windows since the display has changed
end --function tecUIManagerEnableWindow(objectName, displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerGUIframeThemes(displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
To create a UI Layout theme copy the text in the area labeled COPY BELOW
There will be another line labeled COPY ABOVE stop there.
In the function there is an area labeled PASTE ABOVE and PASTE BELOW
This will create a table within the UIThemes table.
That table will be used to place windows where you would like them.
Once completed if you run the `display layout name` command 
it will load the layout or list supported layouts.

COPY BELOW
  --Start theme namehere----------------------------------------
  uiThemes.namehere = {} --create theme table
  
  uiThemes.namehere.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }

  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `tecclient add list`
  uiThemes.namehere.windows = { }

  uiThemes.namehere.windows["TEC Map"] = "bottomright"
  uiThemes.namehere.windows["Settings"] = "bottomleft"
  uiThemes.namehere.windows["Macros"] = "bottomleft"
  uiThemes.namehere.windows["Status"] = "bottom"
  uiThemes.namehere.windows["Compass"] = "topleft"
  uiThemes.namehere.windows["Communications"] = "top"
  uiThemes.namehere.windows["Room Characters"] = "topright"
  
  --add windowsnames to table clickWindows and they will be clicked after layout has completed
  uiThemes.orchil.clickWindows = {}
  uiThemes.orchil.clickWindows["TEC Map"] = true
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.namehere.borders = {
    left = true,
    right = true,
    top = true,
    bottom = true,
  }
  --End theme namehere----------------------------------------
COPY ABOVE
]]--

--configure layout themes
function UIManagerGUIframeThemes(displayToScreen)

  --use these for sizing
  local mainW, mainH = getMainWindowSize()
  --half the width and height of main window.
  local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
  --a quarter of the window of main window.
  local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
  --an eighth the width and hieght of main window.
  local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)
  --one third of main window
  local thirdW, thirdH = math.floor(mainW * .33), math.floor(mainH * .33)
  
  uiThemes = {} --create table to hold themes
  
  --Start theme NiceHat----------------------------------------
  uiThemes.NiceHat = {} --create theme table
  
  uiThemes.NiceHat.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }

  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `display add list`
  uiThemes.NiceHat.windows = { }

  uiThemes.NiceHat.windows["TEC Map"] = "bottomright"
  uiThemes.NiceHat.windows["Settings"] = "bottomleft"
  uiThemes.NiceHat.windows["Macros"] = "bottomleft"
  uiThemes.NiceHat.windows["Status"] = "bottom"
  uiThemes.NiceHat.windows["Compass"] = "topleft"
  uiThemes.NiceHat.windows["Communications"] = "top"
  uiThemes.NiceHat.windows["Room Characters"] = "topright"
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.NiceHat.borders = {
    left = true,
    right = true,
    top = true,
    bottom = true,
  }
  --End theme NiceHat----------------------------------------
  
  --Start theme orchil----------------------------------------
  uiThemes.orchil = {} --create theme table
  
  uiThemes.orchil.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }
  
  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `display add list`
  uiThemes.orchil.windows = { }
  uiThemes.orchil.windows["Settings"] = "bottomright"
  uiThemes.orchil.windows["Communications"] = "top"
  uiThemes.orchil.windows["Multi Window"] = "topright"
  uiThemes.orchil.windows["TEC Map"] = "bottomright"
  
  --add windowsnames to table clickWindows and they will be clicked after layout has completed
  uiThemes.orchil.clickWindows = {}
  uiThemes.orchil.clickWindows["TEC Map"] = true
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.orchil.borders = {
    left = false,
    right = true,
    top = true,
    bottom = false,
  }
  --End theme orchil----------------------------------------
  
--PASTE BELOW----------------------------------------

--PASTE ABOVE----------------------------------------

  --Set the default theme here
  uiThemesDefaultLayout = uiThemes.orchil --set default theme here

  --Load theme from save, or load a default theme if ther was no saved theme
  if UIManagerSettings.PlayersTheme then --if there is a PlayerTheme loaded from file.
    uiThemes.PlayersTheme = UIManagerSettings.PlayersTheme --load the saved theme into the themes table
  else --if there is no PlayersTheme loaded from file.
    --set the PlayersTheme to the an existing theme.
    uiThemes.PlayersTheme = uiThemesDefaultLayout
  end --if UIManagerSettings.PlayersTheme

end --function tecUILayoutManagerConfig</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerSetTheme(themeName, displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerSetTheme(themeName, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  UIManagerGUIframeThemes(displayToScreen) --configure GUIframe layout themes
  --list of acceptable GUIframe window locations
  local guiFrameWindowLocations = [["top" "topleft" "topright" "bottom" "bottomleft" "bottomright"]]

  local tecThemeExists = false --used to see if objectName matches a window name.
  local tecThemeNameList = "" --will be used to list window names

  debugToDisplay("function UIManagerSetTheme, themeName sent is "..tostring(themeName)
    .." displayToScreen is: "..tostring(displayToScreen))

  --Varify arguments are good.
  if type(themeName) ~= "string" then --if objectName is not a string
    tecErrorNotification("function UIManagerSetTheme, first argument is a : "
    ..type(themeName).." string was expected. Use object name IE \"niceHat\"") 
    return --end process it can not continue.
  end --if type(themeName) ~= "string"
  
  --if there are no geyser containers in tecGeyserWindows table.
  if next(uiThemes) == nil then
    tecWarningNotification("function UIManagerSetTheme, no themes in the uiLayoutThemes table.")
    return --stop to function there are no geyser containers to add to UI manager
  end --if #tecGeyserWindows == 0
  
  --Verify themeName is a correct name. Make certain themes have good data.
  for uiThemeName, uiTheme in pairs(uiThemes) do--loop through themes
    --if name was not specified, use the windowName in its place.
    if not uiThemeName then 
      tecWarningNotification("function UIManagerSetTheme, theme does not have a name.")
    end --if not uiThemeName
    --make certain UIManagerSetTheme was sent a correct name.
    if themeName:lower() == uiThemeName:lower() then --if names match
      tecThemeExists = true --notify error catch, correct name sent
      themeName = uiThemeName --Correct case sensitivity.
      debugToDisplay("function tecTestUIManager, Found objectName match "..themeName)
    end --if themeName:lower() == uiThemeName:lower()
    tecThemeNameList = tecThemeNameList..uiThemeName..", " --List windows in 1 string
  end --while pairs(uiThemes)
  
  --incorrect themeName sent. Show player correct themes.
  if not tecThemeExists then --Theme sent to function did not match any saved themes
    if displayToScreen then --display message to screen.
        if (themeName:lower()):match("list") then --if the we receive a list request
          pecho("Supported window layout themes are: ")
        else --if themeName is not "list"
          pecho(themeName.." is not a layout theme. Supported window layout themes are: ")
        end
        for uiThemeName, uiTheme in pairs(uiThemes) do--loop through containers
            --make command for cechoLink
            local cmdToSend = [[UIManagerSetTheme("]]..uiThemeName..[[",true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display layout "..uiThemeName, 
              cmdToSend, --runs on click.
              "Change display layout.", true)
            if (uiThemeName:lower()):match("playerstheme") then --if it is the playertheme
              pecho("-your saved theme-") --notify the player.
            end --if (uiThemeName:lower()):match("playerstheme")
            pecho(" ")
        end --for pairs(tecGeyserWindows)
    else
      tecErrorNotification("function UIManagerSetTheme, Incorrect theme name. Supported themes are "
        ..tecWindowNameList)
    end --if displayToScreen
    debugToDisplay("function UIManagerSetTheme, failed to find theme name matching: "..themeName)
    echo("\n")
    return
  end --if not tecWindowExists
  
  --load desired windows back into UI
  if GetUIManager() == "GUIframe" then --is GUIframe being used
    debugToDisplay("\tUIManagerSetTheme, starting GUIframe config")
    
    if displayToScreen then pecho("Removing windows, please wait.\n") end
    
    if GUIframe.initialized then 
      --remove all windows from UI manager and display.
      UIManagerEnableWindow("all", false, false)
    end
    --load settings from desired theme to GUIframe.
    GUIframe.configs = table.update(GUIframe.defaults, uiThemes[themeName].GUIframe)

    --Reset GUI frame
    GUIframe.reinitialize()
    
    --disable all sides
    GUIframe.disable("top", true)
    GUIframe.disable("bottom", true)
    GUIframe.disable("left", true)
    GUIframe.disable("right", true)

    if displayToScreen then pecho("Adding windows, please wait.\n") end

    --enable or disable sides.
    for tmpWinowSide,_ in pairs(uiThemes[themeName].borders) do
      --make certain the theme has a good border setting. Should be true or false, but lets be sure.
      uiThemes[themeName].borders[tmpWinowSide] = fuzzyBoolean(uiThemes[themeName].borders[tmpWinowSide])
      debugToDisplay("function UIManagerSetTheme, border "..tmpWinowSide
        .." set to "..tostring(uiThemes[themeName].borders[tmpWinowSide]))
      --enable window if theme calls for it
      if uiThemes[themeName].borders[tmpWinowSide] then GUIframe.enable(tmpWinowSide) end 
    end --for tmpWinowSide,_ in pairs(uiThemes[themeName].borders)
    
    --loop through theme windows to be added for theme make certain they are correct.
    --if they are send them to the UI manager.
    for tmpWindowName, tmpWindowGUIframeLocation in pairs(uiThemes[themeName].windows) do
      debugToDisplay("function UIManagerSetTheme, testing window name: "..tmpWindowName
        .." going to GUIframe location "..tmpWindowGUIframeLocation)
        
      --Window name error checking.
      local incorrectWindowName = tmpWindowName --used later if themeName sent is correct
      --verify the window name exists.
      tmpWindowName = UIManagerTestWindow(tmpWindowName, displayToScreen)
      if not tmpWindowName then --if the window name was bad.
        --create a smart error message
        local errorFound = incorrectWindowName.." is not a window name. Supported names are: "
        for fullListWindowName, tmpWindowTable in pairs(tecGeyserWindows) do
            errorFound = errorFound.."\""..fullListWindowName.."\" "
        end --for fullListWindowName,_ in pairs(tecGeyserWindows) do
        errorFound = errorFound.."\nTheme config code needing correction looks like: "
          ..[[uiThemes.]]..themeName..[[.windows["]]..incorrectWindowName..[["] = "]]..tmpWindowGUIframeLocation..[["]]
          .."\n\""..incorrectWindowName.."\" needs to be replaced with a supported window name, listed above.\n"
          .."Please correct and attempt again.\n"
        if displayToScreen then --if we want to display to player screen
          pecho(errorFound) --display error direct to player
        end --if displayToScreen
        debugToDisplay("function UIManagerSetTheme, "..errorFound) --display error to debug
        return --stop function bad window name sent.
      end --if not tmpWindowName
      
      --error check GUIframeLocation    
      if not guiFrameWindowLocations:match(tmpWindowGUIframeLocation) then
        --find an enabled border and set the location to that border.
        if uiThemes[themeName].borders["right"] then --if right side is enabled.
          tmpWindowGUIframeLocation = "topright" --put the window at the top right.
        elseif uiThemes[themeName].borders["left"] then --if left side is enabled.
          tmpWindowGUIframeLocation = "topleft" --put the window at the top left.
        end --if uiThemes[themeName].borders[tmpWinowSide]
        errorFound = "GUIframe location for window: "..incorrectWindowName.." incorrect.\n"
          .."A default location of "..tmpWindowGUIframeLocation.." has been chosen for window "..incorrectWindowName
          .."\nTo correct this, theme config code needing correction looks like: "
          ..[[uiThemes.]]..themeName..[[.windows["]]..incorrectWindowName..[["] = "]]..tmpWindowGUIframeLocation..[["]]
          .."\n\""..tmpWindowGUIframeLocation.."\" needs to be a supported GUIframe location, "
          ..guiFrameWindowLocations
        --display to player if displayToScreen is true.
        if displayToScreen then echo(errorFound) end --Show message to player
        tecWarningNotification(errorFound) --display to debug system.
      end --if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation)

      --Window name and location tested good, we will add it to the display.
      --if the window exists in the tecGeyserWindows table, set its GUIframeLocation
      if tecGeyserWindows[tmpWindowName] then 
        debugToDisplay("function UIManagerSetTheme, enabeling window "..tmpWindowName
          .." to GUIframe location "..tmpWindowGUIframeLocation)
        tecGeyserWindows[tmpWindowName].GUIframeLocation = tmpWindowGUIframeLocation
      else --the window name does not exist. and error occured.
        errorFound = "function UIManagerSetTheme, "..tmpWindowName
          .." does not exist in tecGeyserWindows table after UIManagerSetTheme error "
          .."checking. Please contact a developer and supply your UILayout config."
        tecErrorNotification(errorFound)
        return
      end --if tecGeyserWindows[tmpWindowName]
      debugToDisplay("\tUIManagerSetTheme, error checking passed for window "
        ..tmpWindowName.."enabeling it and adding it to display")
      --make the players theme a duplicate of the desired theme
      UIManagerSettings.PlayersTheme = table.deepcopy(uiThemes[themeName])
      --enable and display the window.
      --Do not display to screen as it will run dontforgettosave() for each window.
      UIManagerEnableWindow(tmpWindowName, true)
    end --for tmpWinowSide, tmpEnableSide in pairs(uiThemes[themeName].windows)

    --Loop through windows to click after enabeling windows, check if the names are good
    --if they are send them to the UI manager.
    if uiThemes[themeName].clickWindows then -- If there is a window to click
      for tmpWindowName, clickWindow in pairs(uiThemes[themeName].clickWindows) do
        debugToDisplay("function UIManagerSetTheme, testing clickWindows name: "..tmpWindowName
          ..", clickWindow is "..tostring(clickWindow))
        --Window name error checking.
        local incorrectWindowName = tmpWindowName --used later if themeName sent is correct
        --verify the window name exists.
        tmpWindowName = UIManagerTestWindow(tmpWindowName, displayToScreen)
        if not tmpWindowName then --if the window name was bad.
          --create a smart error message
          local errorFound = "clickWindows test of window "..incorrectWindowName.." is not a window name. Supported names are: "
          for tmpThemeWindowNames, _ in pairs(uiThemes[themeName].windows) do
              errorFound = errorFound.."\""..tmpThemeWindowNames.."\" "
          end --for fullListWindowName,_ in pairs(tecGeyserWindows) do
          errorFound = errorFound.."\nTheme config code needing correction looks like: "
            ..[[uiThemes.]]..themeName..[[.clickWindows["]]..incorrectWindowName..[["] = ]]..tostring(clickWindow)
            .."\n\""..incorrectWindowName.."\" needs to be replaced with a supported window name, listed above.\n"
            .."Please correct and attempt again.\n"
          if displayToScreen then --if we want to display to player screen
            pecho(errorFound) --display error direct to player
          end --if displayToScreen
          debugToDisplay("function UIManagerSetTheme, "..errorFound) --display error to debug
          return --stop function bad window name sent.
        else --the window name was good. click it.
          debugToDisplay("function UIManagerSetTheme, clicking window "..tmpWindowName)
          GUIframe.activate(tmpWindowName) --click the window. Hiding other windows in that space.
        end --if not tmpWindowName
      end --for pairs(uiThemes[themeName].clickWindows)
    end --if uiThemes[themeName].clickWindows
    
    --redraw GUIframe with new layout.
    --GUIframe.eventHandler("sysWindowResizeEvent")
    if guiChange then guiChange() end --Size windows to theme setting.
    
    if displayToScreen then
      pecho("Layout changed to theme, "..themeName.."\n")
      dontForgetToSave() --remind player to save changes
    end --if displayToScreeen
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized

end --function UIManagerSetTheme(themeName, displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerEnableSide(sideName,mode,displayToScreen)</name>
						<packageName></packageName>
						<script>--Enable or disable sides in UI managers
function UIManagerEnableSide(sideName,mode,displayToScreen)
  mode = fuzzyBoolean(mode) --Verify good boolean sent
  displayToScreen = fuzzyBoolean(displayToScreen) --Verify good boolean sent
  local tmpSidesTable = {"left", "right", "top", "bottom"} --used to test input
  
  if not type(sideName) == "string" then --make certain first argument is a string
    local errorFound = "first argument needs to be a string."
    tecErrorNotification("function UIManagerEnableSide, "..errorFound)
    if displayToScreen then cecho("UIManagerEnableSide "..errorFound) end
    return --stop function error found
  end
  --Make certain argument passed is a correct side name
  if not table.contains (tmpSidesTable, sideName:lower()) then
    --if displayToScreen is true, show a list of acceptable commands
    if displayToScreen then 
      if (sideName:lower()):match("list") then --if the we receive a list request
        pecho("Supported side ")
        if mode then pecho("enable ") 
        else pecho("disable ") end
        pecho("commands are: ")
      else 
        pecho(sideName.." is not side. Supported commands are: ")
      end
      if mode then --show a list of enable commands if mode is true
        --loop through side names inserting them into command examples
        for iterator, tmpSideName in ipairs(tmpSidesTable) do
          --loading a command into a variable to put into a cecholink
          local cmdToSend = [[UIManagerEnableSide("]]..tmpSideName..[[",true,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor
            .."&gt;display side enable "..tmpSideName, 
            cmdToSend, --runs cmdToSend string on click.
            "Enable side "..tmpSideName, true)
          cecho(" ")
        end --for pairs("left", "right", "top", "bottom")
      else --mode false so send disable examples.
        --loop through side names inserting them into command examples
        for iterator, tmpSideName in ipairs(tmpSidesTable) do
          --loading a command into a variable to put into a cecholink
          local cmdToSend = [[UIManagerEnableSide("]]..tmpSideName..[[",false,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor
            .."&gt;display side disable "..tmpSideName, 
            cmdToSend, --runs cmdToSend string on click.
            "Disable side "..tmpSideName, true)
          cecho(" ")
        end --for pairs(tmpSidesTable)                                                                            
      end --if mode
      cecho("\n") --put a new line at the end of the command examples
    end --if displayToScreen
    debugToDisplay("function UIManagerEnableSide, incorrect side name sent")
    return --stop function error found
  end --if tmpCorrectSides:match(sideName:lower())
  
  --Use GetUIManager create an ifelse for each UI manager that supports sides
  --is GUIframe being used
  if GetUIManager() == "GUIframe" and GUIframe.initialized then 
    sideName = sideName:lower() --now that we know it is a string, make it lower case
    debugToDisplay("function UIManagerEnableSide, setting border "
      ..sideName.." to "..tostring(mode))
    --Change settings in playerstheme table.
    --Now if they save display settings these changes will load on startup.
    UIManagerSettings.PlayersTheme.borders[sideName] = mode
    if mode then --if mode is true, enable side.
      GUIframe.enable(sideName)
    else --mode is false disable side
      GUIframe.disable(sideName, true)
    end --if mode
  else --UI manager does not support sides
    local errorFound = "The User Interface manager "
      .."in use does not support sides."
    if displayToScreen then cecho(errorFound.."\n") end
    tecWarningNotification("function UIManagerEnableSide, "..errorFound)
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized

  if guiChange then --if the guiChange function has been created
    if displayToScreen then --displayToScreen is only true when ShowWindow is run by alias, if it is false it is run by SetTheme().
      guiChange() --resize windows.
    end --if displayToScreen
  end--end if guiChange

  if displayToScreen then dontForgetToSave() end
end --function UIManagerEnableSide</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerFileSave(displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerFileSave(displayToScreen)
  if tecSettings.useGUIframe then --if using GUIframe manager
    GUIframe.saveSettings() --While we do not use it presently still save GUIframe settings
    --if UIManagerSettings table does not exist make it.
    if not UIManagerSettings then 
      UIManagerSettings = {}
      UIManagerSettings.PlayersTheme = uiThemes.PlayersTheme
    end --if not UIManagerSettings
    
    --save GUIframe sizes to UIManagerSettings table, so they will load on startup
    UIManagerSettings.PlayersTheme.GUIframe.leftStartWidth = getBorderLeft() --left border width
    UIManagerSettings.PlayersTheme.GUIframe.leftStartHeight = GUIframe.topLeftContainer:get_height() --Where top and bottom windows meet
    UIManagerSettings.PlayersTheme.GUIframe.rightStartWidth = getBorderRight() --Right border window
    UIManagerSettings.PlayersTheme.GUIframe.rightStartHeight = GUIframe.topRightContainer:get_height() --Where top and bottom windows meet
    UIManagerSettings.PlayersTheme.GUIframe.topStartHeight = getBorderTop() --width of top
    UIManagerSettings.PlayersTheme.GUIframe.bottomStartHeight = getBorderBottom() --width of bottom
    
    --save enabled windows locations
    for windowName, window in pairs(tecGeyserWindows) do --loop through manged windows
      if UIManagerSettings[window.name] then --if the window exists in the settings area
        if UIManagerSettings[window.name].disabled then --check if the window is disabled
          if UIManagerSettings.PlayersTheme.windows[window.name] --if the window exists in the saved playerstheme
            --erase the settings for the window. If we do not the window will load on startup and when display layout is run.
            then UIManagerSettings.PlayersTheme.windows[window.name] = nil
          end --if UIManagerSettings[window.name].disabled
        else --if the window is enabled
          --get the location of the window from the name of its container
          local tmpGUIframeLocation = (window.container.name:gsub("Container","")):lower()
          debugToDisplay("function UIManagerFileSave, Window "..window.name
            .." saving to GUIframe location "..tmpGUIframeLocation.."\n")
          UIManagerSettings.PlayersTheme.windows[window.name] = tmpGUIframeLocation --save the windows location
        end --if UIManagerSettings[window.name].disabled
      end --if UIManagerSettings[window.name]
    end --for pairs(tecGeyserWindows)
    
  else --UI manager not in use.
    tecWarningNotification("function UIManagerFileSave, UI manager not specified.")
    if displayToScreen then echo("No User Iterface manager present.") end
  end --if tecSettings.useGUIframe then --if using GUIframe manager
  
  --Save UI Manager settings if any are present.
  if UIManagerSettings then
    --save UI Manager settings
    table.save(tecSettingsFolder.."TECUIManagerData.lua", UIManagerSettings)
  else --UIManagerSettings does not exist for some reason.
    tecErrorNotification("function UIManagerFileSave, UIManagerSettings table not present.")
  end --if UIManagerSettings
  
  if displayToScreen then pecho("\nDisplay settings saved.\n") end
end --function UIManagerFileSave</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerFileLoad(displayToScreen)</name>
						<packageName></packageName>
						<script>--load display settings.
function UIManagerFileLoad(displayToScreen)
  local tecTMPDisplayTable = {}
  
  local path = tecSettingsFolder.."TECUIManagerData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		debugToDisplay("tecFileLoadSettings: "..path.." file doesn't exist.") --TEC debug screen
    pecho("[ Info ]  - No display settings file. Parthia using default settings.\n")
		--debugc("tecFileLoadSettings: "..path.." file doesn't exist.") --mudlets debug screen
	return --kill the function before real errors occur
	else
    table.load(path, tecTMPDisplayTable) --Load the settings in from file
    --if UIManagerSettings table does not exist make it.
    if not UIManagerSettings then UIManagerSettings = {} end
    --load settings into UIManagerSettings table.
    UIManagerSettings = table.update(UIManagerSettings, tecTMPDisplayTable)
    if displayToScreen then 
      cecho("[  OK  ]  - Parthia UI Manager settings successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
	
end --function UIManagerFileLoad</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerReset(displayToScreen)</name>
						<packageName></packageName>
						<script>--reset window layout to default theme
function UIManagerReset(displayToScreen)

  --make certain display to screen is good
  displayToScreen = fuzzyBoolean(displayToScreen)

  if GetUIManager() == "GUIframe" then --if using GUIframe manager
    UIManagerGUIframeThemes(displayToScreen) --create default UI layout
    if uiThemesDefaultLayout then --if uiThemesDefaultLayout exists
      if uiThemes then --if the uiThemes table exists
        debugToDisplay("function UIManagerReset, setting PlayersTheme table to defaultUILayout table.")
        UIManagerSettings = {}
        UIManagerSettings.PlayersTheme = uiThemesDefaultLayout --replace players UI layout with default
      else --the uiThemes table somehow does not exist.
        tecErrorNotification("function UIManagerReset, uiThemes table missing.")
      end --if uiThemes
      if displayToScreen then echo("Please wait while windows reload.\n") end
      UIManagerSetTheme("PlayersTheme", false) --load windows into display
      if displayToScreen then echo("Display settings set to default.\n") end --if displayToScreen
    else --the uiThemesDefaultLayout table does not exist.
      tecErrorNotification("function UIManagerReset, uiThemesDefaultLayout table missing.")
    end --if uiThemesDefaultLayout
  else --No UI manager found
    tecWarningNotification("function UIManagerReset, no UI Mananger specified.")
    if displayToScreen then echo("No UI Manager specified.\n") end
  end --if tecSettings.useGUIframe

  if displayToScreen then dontForgetToSave() end --remind player to save.

end --function UIManagerReset</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerHelp()</name>
						<packageName></packageName>
						<script>--Returns list of commands UI Manager is capable of
--Intended to be used within a help system you make.
function UIManagerHelp()

  pecho("Developer display commands:\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display add window name", 
    [[printCmdLine("display add ");
    pecho("Now enter a window name, all to add all windows or list to list supported window names.")]], 
    "Add graphical object", true)
	pecho(", show a registered window.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display remove window name", 
  [[printCmdLine("display remove ");
    pecho("Now enter a window name, all to remove all windows or list to list supported window names.")]], 
  "Remove graphical object", true)
	pecho(", hide a registered window.\n")
  
  pecho("\nPlayer display commands:\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear", 
  [[UIManagerClearMainWindow()]], 
  "Remove text from main screen", true)
	pecho(", clear text from main text console.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display scrollbars enable", 
  [[tecSetScrollBars(true)]], 
  "Enable scroll bars", true)
	pecho(", enable scrollbars in Parthia.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display scrollbars disable", 
  [[tecSetScrollBars(false)]], 
  "Hide scroll bars", true)
	echo(", hide scrollbars in Parthia.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display side list", 
  [[UIManagerEnableSide("list",true,true);
    UIManagerEnableSide("list",false,true);
    pecho("Click a command above to enable or disable a side of the screen.\n")]], 
  "Control what sides are displayed", true)
	pecho(", enable or disable sides of the screen that hold windows.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window list", 
  [[UIManagerEnableWindow("list",true,true);
    UIManagerEnableWindow("list",false,true);
    pecho("Click a command above to enable or disable a window.\n")]], 
  "List all window commands", true)
	pecho(", show all windows that can be enabled or disabled.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display layout list", 
  [[UIManagerSetTheme("list",true);
    pecho("Click a command above to switch to a different layout theme.\n")]], 
  "Change windows layout", true)
	pecho(", change window's layout to a preset theme.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display manager name", 
  [[SetUIManager("list", true)]], 
  "Change display manager", true)
	pecho(", change display manager.\n")
	
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
  [[UIManagerFileSave(true)]], 
  "Save window positions", true)
	pecho(", save window positions.\n")
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display load", 
  [[UIManagerFileLoad(true)]], 
  "Load window positions", true)
	pecho(", reset window positions to last save.\n")
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display reset", 
  [[UIManagerReset()]], 
  "Reset window positions", true)
	pecho(", reset window positions to default.\n")
			
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Resize Windows tutorial", 
  [[UIManagerResizeHelp()]], 
  "Resize windows tutorial", true)
	pecho(", expand or shrink windows.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Move Windows tutorial", 
  [[UIManagerMoveWindowHelp()]], 
  "Move windows tutorial", true)
	pecho(", move windows in display.\n")
  
  pecho("Click a command above or type it into the command line.\n")
  
   --Explains how to move tabs

end --function UIManagerHelp</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerResizeHelp()</name>
						<packageName></packageName>
						<script>function UIManagerResizeHelp() --explains how to resize display
	if GetUIManager() == "GUIframe" and GUIframe.initialized then
    pecho("You are currently using the GUIframe display manager. "
    .."To reize windows right "
		.."click one of the four very faint blue arrows and drag it. "
		.."These arrows are on the top, bottom, left and right outer edges "
		.."of the main text window that this text appears in. "
		.."When you move your mouse over the arrows they will "
		.."become bold blue arrows and show a resize tip in a small gray box.\n"
    .."Don't forget to save changes with ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
      [[UIManagerFileSave(true)]],
      "Save display settings", true)
    pecho("\n")
  else
    tecErrorNotification("You are not using a display manager. "
      .."No windows should show on screen to resize.")
  end --if GetUIManager == "GUIframe" and GUIframe.initialized
end --function UIManagerResizeHelp</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerMoveWindowHelp()</name>
						<packageName></packageName>
						<script>function UIManagerMoveWindowHelp() --explains how to move tabs on display
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
	 pecho("You are currently using the GUIframe display manager.\n"
		.."To move a window you can right click its name tab at the top of the window. "
    .."Than drag it to the tab of another window. "
    .."When it is ready to be release a black space will open in the tabs bar to fit the name tab of the window being moved.\n"
    .."It may take a few tries because it requires the tip of the mouse's cursor to be directly over another tab. "
    .."After releasing the mouse the window and its name tab will stay where you moved it.\n"
    .."Don't forget to save changes with ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
      [[UIManagerFileSave(true)]],
      "Save display settings", true)
    cecho("\n")
  else
    tecErrorNotification("You are not using a display manager. "
      .."No windows should show on screen to move.")
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
end --function tecResizeDisplayHelp</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>help</name>
				<packageName></packageName>
				<script>--[[
functions to display help messages to screen
like the parthia command or parthia talk command
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientFullHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>function tecClientFullHelp(tecBrief, tecWindow)
  
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false
  local parthiaCmdHelp = " change many client settings."
  local displayCmdHelp = " Save or load window positions, "
		.."reset display to defaults, "
  	.."and clear text off the display."
  local debugCmdHelp = " Use to get information to report issues."
  
  if not tecBrief then --if we do not want to be brief
    pecho("There are a number of commands to adjust the game client. "
  		.."They are:\n")	
  end --end if not tecBrief
  
  if getParthiaTalk() then --if parthia talk is enabled
    pecho("parthia."..parthiaCmdHelp.." display."..displayCmdHelp
      .." debug."..debugCmdHelp, true) --send to pecho talkOnly true
  end --if getParthiaTalk()
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia", 
  [[tecClientHelp()]], 
  "Save or load client settings.", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, parthiaCmdHelp.."\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;display", 
  [[UIManagerHelp()]], 
  "Change display settings.", true)
  if not tecBrief then --if we do not want to be brief
    echo(tecWindow, displayCmdHelp.."\n") 
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug", 
  [[tecDebugHelp()]], 
  "Create debug messages", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, debugCmdHelp.."\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  echo(tecWindow, "\n")
end --end function tecClientFullHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDebugHelp()</name>
					<packageName></packageName>
					<script>function tecDebugHelp()
  pecho("\n&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on", 
  [[setTECDebugMode(true)]],
  "Send debug text to debug window", true)
  pecho(", Create debug window and send basic info to it.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off", 
  [[setTECDisplayDebugMode(false) setTECMapDebugMode(false) setTECDebugMode(false)]],
  "Stop all debug messages", true)
  pecho(", Stops sending all debug messages.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on", 
  [[setTECDisplayDebugMode(true)]],
  "Show display messages to debug window", true)
  pecho(", Send display information to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display off", 
  [[setTECDisplayDebugMode(false)]],
  "Stop showing display messages to debug window", true)
  pecho(", Disables display debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on", 
  [[setTECMapDebugMode(true)]],
  "Show map messages to debug window", true)
  pecho(", Send map debug messages to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map off", 
  [[setTECMapDebugMode(false)]],
  "Stop showing map messages to debug window", true)
  pecho(", Disables map debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers on", 
  [[setTECTimerDebugMode(true)]],
  "Start showing timmer messages to debug window", true)
  pecho(", Send timer debug messages to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers off", 
  [[setTECTimerDebugMode(false)]],
  "Stop showing timmer messages to debug window", true)
  pecho(", Disables timmer debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug test colors", 
  [[tecColorTest()]],
  "Send basic colors to screen", true)
  pecho(", Sends colored text to screen.\n")
	
	tecReportIssuesHelp(false)
  
  pecho("&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
    
  pecho("Click a command above or type it into the command line.\n")

end --end function tecDebugHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientHelp()</name>
					<packageName></packageName>
					<script>function tecClientHelp()

  echo("\nparthia developer commands:\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia prepare release", 
  [[expandAlias("parthia prepare release")]],
  "Prepare code for release", true)
  echo(", set mudlet objects to default enable or disabled state.\n")
  
  echo("\nparthia player commands:\n")
  pecho("\nparthia command:\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk", 
  [[parthiaTalkHelp()]],
  "parthia talk help", true)
  pecho(", list parthia's text to speech commands.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia update check", 
  [[DownloadGitReleaseJSON()]],
  "Check for updates", true)
  pecho(", check if Parthia updates are available.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia version", 
  [[expandAlias("parthia version")]],
  "Display version of Parthia", true)
  pecho(", check installed Parthia version.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia beta test yes", 
  [[tecSetBetaTester(true)]],
  "Receive beta updates", true)
  pecho(", Receive beta updates and help us make a reliable client.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia beta test no", 
  [[tecSetBetaTester(false)]],
  "Stop receiving beta updates", true)
  pecho(", No longer receive beta updates.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save all", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
  pecho(", Save client and display settings to file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  pecho(", Save basic client settings to file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia load", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from file", true)
  pecho(", Loads client settings from file. Run -parthia"
  	.." save- to create a settings file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia reset", 
  [[tecClientReset(true);dontForgetToSave(true)]],
  "Reset client to default", true)
  pecho(", Reset client to default client settings. "
  	.."Run -display reset- to reset display.\n")
  	
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia reset all", 
  [[tecClientResetAll()]],
  "Reset all client settings to default", true)
  pecho(", Reset client and display to default settings.\n")
    
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia repair", 
  [[expandAlias("parthia repair")]],
  "Repair Parthia", true)
  pecho(", repairs Parthia. By replacing all developer created code.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia report", 
  [[tecReportIssues()]],
  "Report Parthia issues", true)
  pecho(", receive instruction on reporting issues.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment Install", 
  [[PlayerDev.SetEnabled(true)]],
  "Install player development folders", true)
  pecho(", install player development folders.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment uninstall", 
  [[PlayerDev.SetPackages(false)]],
  "Uninstall player development folders", true)
  pecho(", Uninstall player development folders.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment disable", 
  [[PlayerDev.SetEnabled(false)]],
  "Disable player development updates", true)
  pecho(", stop receiving player development code updates.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment update", 
  [[PlayerDev.Update(true)]],
  "Check for player development updates", true)
  pecho(", check for updates to player development folders. Occurs automatically with client updates.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia numpad navigation", 
  [[expandAlias("parthia numpad navigation")]],
  "Toggle numpad navigation", true)
  echo(", turn navigation using the numberpad on or off.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia tab font size", 
  [[printCmdLine("parthia tab font size ")]],

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia tab font size fontsize", 
  [[printCmdLine("parthia tab font size ");
    pecho("Now enter the font size at the end of the command and press enter.\n")]],
  "Change font size of tabs", true)
  pecho(", Change font size for window tabs.\n") 
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia change colors", 
  [[tecClientChangeColors()]],
  "Change client colors", true)
  pecho(", Change color scheme for client.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia font size fontsize", 
  [[printCmdLine("parthia font size ");
    pecho("Now enter the font size at the end of the command and press enter.\n")]],
  "Change client font size", true)
  pecho(", Change font size for all consoles.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia commands", 
  [[parthiaCommandsHelp()]],
  "List custom parthia commands", true)
  pecho(", game commands that exist in parthia only.\n")
  
  pecho("Click a command above or type it into the command line.\n")

end --function tecClientHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientChangeColors()</name>
					<packageName></packageName>
					<script>--lists commands that directly change colors
function tecClientChangeColorsList()
  pecho("Change background color of windows that do not have text with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia windows background color colorname\n", 
  [[printCmdLine("parthia windows background color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color nontext windows", true)

  pecho("Change background color of windows that have text in them with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia background colorname ", 
  [[printCmdLine("parthia background ");
    pecho("You will need to restart mudlet for text background to change")]],
  "Change background color of text windows", true)
  pecho("-Mudlet restart required on Windows OS.\n\tText background color saved in mudlet not Parthia.\n")
  pecho("Command echo background must be changed in Options -&gt; Preferences -&gt; Color View -&gt; Command Background.\n")
  
  pecho("Change background color of the client's tabs with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia tabs background color colorname\n", 
  [[printCmdLine("parthia tabs background color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color clients tabs", true)
  
  pecho("Change the color of windows and tabs as your mouse hovers over them: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia hover color colorname\n", 
  [[printCmdLine("parthia hover color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change mouse hover color", true)
  
  pecho("Change the color approached characters appear in Room Characters window: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia approached character color colorname\n", 
  [[printCmdLine("parthia approached character color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color approached characters in Room Character Window", true)
  
  pecho("Change the color not approached characters appear in Room Characters window: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia not approached character color colorname\n", 
  [[printCmdLine("parthia not approached character color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color not approached characters in Room Character Window", true)
  
  pecho("Change the color help commands are highlighted in: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia helphighlight color colorname\n", 
  [[printCmdLine("parthia helphighlight color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change help command highlight color", true)

  pecho("Change TEC's gray text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia gray color colorname\n", 
  [[printCmdLine("parthia gray color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  pecho("Change TEC's purple text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia purple color colorname\n", 
  [[printCmdLine("parthia purple color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  pecho("Change the color of TEC's default green: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia greentext color colorname\n", 
  [[printCmdLine("parthia greentext color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's green text color", true)
  
  pecho("Change the color of TEC's default blue: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia bluetext color colorname\n", 
  [[printCmdLine("parthia bluetext color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's blue text color", true)
  
  pecho("Change TEC's primary text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia text color colorname\n", 
  [[printCmdLine("parthia text color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)

  pecho("Click a command above or type it into the command line.\n")  

end --function tecClientChnageColorsList

--General help for changing colors.
function tecClientChangeColors()

  pecho("List all commands that change colors with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor
    .."&gt;parthia change colors commands\n", 
  [[tecClientChangeColorsList()]],
  "Save client settings", true)
   
  pecho("Don't forget to save your changes with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  
  pecho("List colornames in main window: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;lua showColors(3)\n", 
  [[showColors(3);
    cecho("Click a color to add it to the end of the command bar")]],
  "List color names", true)
  
  pecho("Open colorname chooser window: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia colors\n", 
  [[tecColorWindow()]],
  "Open color chooser window", true)
  
  pecho("Color names in each command can be a hex color also, IE: #FF0000 is red."
    .." If you would like to use hex colors here is a ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;hex color picker.\n", 
  [[openUrl("https://www.w3schools.com/colors/colors_picker.asp")]],
  "Hex color tool", true)
  
  pecho("Click a command above or type it into the command line.\n")

end --function tecClientChangeColors()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaCommandsHelp()</name>
					<packageName></packageName>
					<script>function parthiaCommandsHelp()
  pecho("\nCustom Parthia commands:\n")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;wait for drover", 
  [[expandAlias("wait for drover")]],
  "Wait for a drover", true)
  pecho(", wait for a wagon drover.\n")
  
  pecho("Click a command above or type it into the command line.\n")
end --function parthiaCommandsHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaTalkHelp()</name>
					<packageName></packageName>
					<script>--help message that appears when `parthia talk` command is run
function parthiaTalkHelp()
  pecho("Parthia talk commands are\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk enable", 
    [[expandAlias("parthia talk enable")]],
    "Enable parthia talk", true)
  pecho(", enable parthia's text to speech system.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk disable", 
    [[expandAlias("parthia talk disable")]],
    "Disable parthia talk", true)
  pecho(", disable parthia's text to speech system.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pause", 
    [[expandAlias("parthia talk pause")]],
    "Pause parthia talk", true)
  pecho(", pause parthia talk, keep message queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk resume", 
    [[expandAlias("parthia talk resume")]],
    "Resume parthia talk", true)
  pecho(", resume talk after pausing.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk skip", 
    [[expandAlias("parthia talk skip")]],
    "Skip current message", true)
  pecho(", skip the current message in the talk queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk sk", 
    [[expandAlias("parthia talk sk")]],
    "Skip current message", true)
  pecho(", skip the current message in the talk queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk stop", 
    [[expandAlias("parthia talk stop")]],
    "Stop current messages", true)
  pecho(", stop current message and clear speech queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk st", 
    [[expandAlias("parthia talk st")]],
    "Stop current messages", true)
  pecho(", stop current message and clear speech queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice list", 
    [[expandAlias("parthia talk voice list")]],
    "Choose talk voice", true)
  pecho(", change voice parthia talk speaks in.\n")
  
--  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk clear", 
--    [[expandAlias("parthia talk clear")]],
--    "Clear talk queue", true)
--  pecho(", clear parthia talk's message queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speed list", 
    [[expandAlias("parthia talk speed list")]],
    "List talk speed list", true)
  pecho(", list speeds parthia talk speaks in.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pitch list", 
    [[expandAlias("parthia talk pitch list")]],
    "List talk pitch commands", true)
  pecho(", speak game speech even if parthia talk is disabled.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk thoughts", 
    [[expandAlias("parthia talk thoughts")]],
    "Speak thoughts always", true)
  pecho(", speak thoughts even if parthia talk is disabled.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speech", 
    [[expandAlias("parthia talk speech")]],
    "Speak speech always", true)
  pecho(", speak game speech even if parthia talk is disabled.\n")
  
  pecho("\nparthia talk has a short hand version of pt. For example ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;pt enable", 
    [[expandAlias("pt enable")]],
    "Enable parthia talk", true)
  cecho("\n")
  
  pecho("Click a command above or type it into the command line.\n")
end --function parthiaTalkHelp()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Map</name>
				<packageName></packageName>
				<script>--Functions used for TEC's map system.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecMapPixelToPercent</name>
					<packageName></packageName>
					<script>--used to convert a number into what percent it would be on TECs Map 
function tecMapPixelToPercent(tecNumToConvert)
	--converts a size in pixels in reference to TECs map to a percent.
	--TECs map is 240 by 240 pixels.
	--Than adjusts with zoom.
	--Intended for calculating dimmensions of object on the map.
	return ((tonumber(tecNumToConvert) / 240) * 100) * mapZoom
end --end function tecMapPixelToPercent</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecMapIconAdjustment</name>
					<packageName></packageName>
					<script>--position a static icon on the map "probably an exit icon".
--tecIconDimmension is the height or width of the icon being positioned.
--tecMapDimmension is the height or width of the background label of the map.
--Both should be either height or width. One being a height and the other a width may result
--in incorrect icon positioning. Later map release will offer user to not have a square map, if wanted.
function tecMapIconAdjustment(tecIconDimmension, tecMapDimmension)	
	--Turn half the icons size into a percent of what it is on a tecMap 240x240
	tecIconDimmension = tecMapPixelToPercent(tecIconDimmension / 2)
	--Device the entire dimmension of the map by tecMaps 240 size.
	--Than device the % of the icon size by that resulting number.
	return tecIconDimmension / (tecMapDimmension / 240)
end --end tecMapIconAdjustment</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaDrawMapRooms()</name>
					<packageName></packageName>
					<script>--SKOOT 6 -10,-10,20,#ff0000,17.1111,-10,10,20,#ffffff,25.5555
--This skoot is from a map that I am certain there are two rooms.
--Both the same size. One higher up is red one directly below is white
--They are the same size.
--There are door open and closed lines on them. Those are handled with skoot 10 messages
--SKOOT 6 x, y, size, color, ?
--x horizonal position of top left corner
--y is vertical position of top left corner
--size is the size of the room 
--color is the color of the room 
--No fucking idea what the fucking number at the end is!

--This is going to be the games largest in drawn pixels and most common skoot message
--SKOOT 6 -40,-40,80,#ff0000,117.624,40,-40,80,#00ff00,117.624,-120,-40,80,#00ff00,117.624,
---40,-120,80,#ffffff,117.624,-40,40,80,#ffffff,117.624,-120,40,80,#ffffff,117.624,
--40,40,80,#ffffff,117.624,40,-120,80,#ffffff,117.624,-120,-120,80,#ffffff,108.576
--Now we need to get room data in %.
--We know that 80 is the max room size for a single room. By observing skoots.
--We know, only because of playing. That these rooms are normally in a 3x3 grid.
--So we know now our draw win is 240x240
--TEC numbers map to a graph, not a window. So their 0 is x120 y120 in our window.
--To get our correct position we have to do xpos + 120. 
--x and y are both -40 / 120. It would be -.33333.
--multiply that by 100 to get the number is a full percent. -33.333
--Now since tec sees x120,y120 as position 0 and the rest of the world sees x0,y0 as zero
--We need to add our number to 50, because 120 is 50% of our total draw size of 240 pixels.
--50 + -33.333 = 16.667. so 16.667% are our x and y positions.
--size is 80 that will be our width and height.
--We need to get what percent 80 is of our overall draw size 240
-- 80 / 240 = .33333. Multiply that by 100, 33.333
--The room is 33.33% of the entire draw window.
--Subtract 1% of that so we have a border between rooms.
--ff0000 is red so the room will be red.
--17.1111 can go fuck itself because I can't figure out what is is.

--Loop through the sckoot message. Looking for a pattern of room data.
--The patterns in () get returned on gmatch. We capture those into variables.
--Those varibles will be used to draw the room.
--Explaining: "(-?%d+),(-?%d+),(%d+),(#%x+),%d+.%d+,?"
--"-?" means there MAY be a -
--"%d+" is a decimal number that CAN be more than one digit long.
--"%x+: is a hexidecimal number that CAN be more than one digit long.
-- ",?" At the very end. There MAY be a , at the end of our pattern or there
--[.%d*]? means there may be a . followed by 0 or more numbers. Like .4555
--may not be. The last number in the skoot message does not have a ,.
--Not looking for that comma in earlier messages might cause future
--pattern searches to fail.
function parthiaDrawMapRooms()
  for xpos, ypos, size, tecMapRoomcolor in string.gmatch( line, "(-?%d+),(-?%d+),(%d+),(#%x+),%d+[.%d*]?,?" ) do
  
    --TEC uses grid logic for their map. xposition is up to 120 +-.
    --240 is the total size of their draw space. What percent is our position in that space.
    -- +.5 just gives us a border.
    xposScaler = ((((tonumber(xpos) + 120) / 240) * 100)) * mapZoom
    yposScaler = ((((tonumber(ypos) + 120) / 240) * 100)) * mapZoom
  
  	--Convert the size of the room to draw into % of its size on the map.
    --size / 240 = decimalNumber like .3333. Multiply decimalNumber by 100, that is your % 
    sizeScaler = tecMapPixelToPercent(size)
  
  	if getTECMapDebugMode() then --if Display Debug Mod is on.
    	debugToDisplay("Map Room "..tostring(mapRoomsLC).." xpos: "..tostring(tonumber(xpos)+120)
  		.." xposScaler: "..tostring(xposScaler)
      .." ypos: "..tostring(tonumber(ypos)+120).." yposScaler: "..tostring(yposScaler)
      .." size: "..tostring(size).." sizeScaler: "..tostring(sizeScaler)
      .." color: "..tostring(tecMapRoomcolor))
    	cecho(mapRoom[mapRoomsLC].name,tostring(mapRoomsLC),blue,"c") --put room # on label
  	end --end if DisplayDebugMode is true
    	
    mapRoom[mapRoomsLC]:move(tostring(xposScaler).."%", tostring(yposScaler).."%") --Move the room into position.
    mapRoom[mapRoomsLC]:resize(tostring(sizeScaler).."%", tostring(sizeScaler).."%") --Change the rooms size.
  	--using style sheets set the shape and color of the room
  	if tecMapRoomcolor == "#ff0000" then mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleRed)
  	elseif tecMapRoomcolor == "#00ff00" then mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleGreen)
  	else mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleWhite) end
  	
    mapRoom[mapRoomsLC]:show() --Now show the room.
    mapRoomsLC = mapRoomsLC +1 --Iterate so we can do this again.
  end --end gmatch room data search loop
end --function parthiaDrawMapRooms()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaDrawMapExits()</name>
					<packageName></packageName>
					<script>--[[
Draw exits for map
SKOOT 10 x y, dir, open
x is horizontal position, from center of line
y is vertical position, from center of line.
dir is the direction the Exit is facing, normally it is a line so
	"hor" is horizontal, v is vertical
	"ne" is a 45 degree angle going from left to right, so north east on a map.
	"nw" is a 45 degree andle going from right to left. so north west on a map.
open if the Exit is open. 1 is open 0 is closed.
]]--

function parthiaDrawMapExits()
  --look through line for the data pattern to get exit data. Input them into variables.
  for xpos, ypos, exitDirection, exitOpen in string.gmatch( line, "(-?%d+),(-?%d+),(%w+),(%d+),?" ) do
  
  	if getTECMapDebugMode() then --if Display Debug Mode is on.
    	debugToDisplay("Map Exit "..tostring(mapExitsLC).." xpos: "
  		..tostring(tonumber(xpos)+120).." xposScaler: "..tostring(xposScaler)
      .." ypos: "..tostring(tonumber(ypos)+120).." yposScaler: "..tostring(yposScaler)
      .." Direction: "..exitDirection
      .." open: "..tostring(exitOpen)
  		.."\nExit Icon: Width: "..tecExit[exitDirection].width
  		.." Height: "..tecExit[exitDirection].height
      .." Style sheet: "..tecExit[exitDirection][exitOpen].tecExitStyleSheet)
  	end --end if DisplayDebugMode is true
  
  	--pulling sizes from the tecExit table resize the label for the icon	
    mapExit[mapExitsLC]:resize(tecExit[exitDirection].width, tecExit[exitDirection].height)
  	--Now set the style sheet for the  
  	mapExit[mapExitsLC]:setStyleSheet(tecExit[exitDirection][exitOpen].tecExitStyleSheet)
  
  	--labels start at x0y0 in mudlet, but TEC is providing a center point for our exit icons
  	--convert half the size of the icons for exits into % of the total map window.
  	--Than take the overall size of the map window / that by our standard 240 window size.
  	--The resulting number is used to adjust the icon position as the map is scaled.
  	local iconWidthAdjustment = tecMapIconAdjustment(tecExit[exitDirection].width, tecMap_back:get_width())
  	
    --TEC uses grid logic for their map. xposition is 120 +-.
    --240 is the total size of their draw space. What percent is our position in that space.
  	--halfWidth is used to center
  	local xposScaler = ((((tonumber(xpos) + 120) / 240) * 100) - iconWidthAdjustment) * mapZoom
  	
  	--same logic as aboive
  	local iconHeightAdjustment = tecMapIconAdjustment(tecExit[exitDirection].height, tecMap_back:get_height())
  	local yposScaler = ((((tonumber(ypos) + 120) / 240) * 100) - iconHeightAdjustment) * mapZoom	
  	
  	--Move the Exit into position.
    mapExit[mapExitsLC]:move(tostring(xposScaler).."%", tostring(yposScaler).."%") 
  	mapExit[mapExitsLC]:lower() --Position rooms ontop of exits.
  	mapExit[mapExitsLC]:show() --Now show the exit path.
  
    mapExitsLC = mapExitsLC +1 --Iterate so we can do this again on a new exit.
  end --end gmatch room data search loop
end --function parthiaDrawMapExits()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Settings Window</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecRefreshSettingsWindow()</name>
					<packageName></packageName>
					<script>function tecRefreshSettingsWindow()

	clearWindow("tecSettingsConsole")

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Load\n", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from last save", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Update\n", 
  [[DownloadGitReleaseJSON()]],
  "Check for updates", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Font Size\n", 
  [[printCmdLine("tecclient font size ")]],
  "Change client font size", true)
	
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Resize Windows\n", 
  [[UIManagerResizeHelp()]],
  "Tutorial on how to resize windows", true)
  
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Move windows\n", 
  [[UIManagerMoveWindowHelp()]],
  "Tutorial on how to move display tabs", true)

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Change Colors\n", 
  [[tecClientChangeColors()]],
  "Change client colors", true)

  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Report Issues\n", 
  [[tecReportIssues()]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Client Help\n", 
  [[tecClientFullHelp(false, "main")]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "\n&lt;:maroon&gt;Reset\n", 
  [[tecClientResetAll()]],
  "Reset all changes to default", true)

end --function tecRefreshSettingsWindow

</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Parthia Commands</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientResetAll()</name>
					<packageName></packageName>
					<script>--Resets all client settings
function tecClientResetAll(displayToScreen)

  displayToScreen = fuzzyBoolean(displayToScreen)
  
  --reset client settings
  tecClientReset(true)
  
  --reset display settings
  UIManagerReset(true)

  if displayToScreen then 
    pecho("All settings at default. ")
    dontForgetToSave()
  end

end --function tecClientResetAll()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Font</name>
					<packageName></packageName>
					<script>--[[
Functions that work with the font.
All windows

font like functions
setMainWindowAutoWrap() sets main windows autowrap character count, is in scripts - GUI

]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECFont</name>
						<packageName></packageName>
						<script>--Currently returns the font size.
--later hope to return font type also.
function getTECFont()
	return tecSettings.tecFontSize
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetFontSize(numbertemp)</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetFontSize(numbertemp)--set font settings with this function

	pecho("\nSetting font to: "..numbertemp.."\n")

	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if numbertemp &lt; 8 then
		numbertemp = 8
		pecho("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
	
	tecSettings.tecFontSize = numbertemp or tecDefaultFontSize --set it to size passed OR default on fail
  
  --Run change for all text windows.
  for index, windowName in ipairs(tecTextWindowNames) do 
    setFontSize(windowName, tecSettings.tecFontSize)
    debugToDisplay("Font Change: Window: "..windowName.." font is now: "
      ..tecSettings.tecFontSize)
  end --for windowName in table tecTextWindowNames
  
  --pecho("Parthia console font is now: "..tecSettings.tecFontSize..".\n")
  
  tecRefreshSettingsWindow() --Redraw text in setttings window.
  tecResetRoomCharacterWindow() --Redraw text in room characters window.
  
  dontForgetToSave() --reminder player to save

end --end tecClientSetFontSize</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetTabFontSize</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetTabFontSize(tecTmpTabFont)--set font settings with this function
  tecTmpTabFont = tecTmpTabFont or tecSettings.tecTabsFontSize
  
	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if tecTmpTabFont &lt; 8 then
		tecTmpTabFont = 8
		pecho("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
  
  pecho("Setting tab font to: "..tecTmpTabFont.."\n")
	
	tecSettings.tecTabsFontSize = tostring(tecTmpTabFont) or tostring(tecDefaultFontSize) --set it to size passed OR default on fail
  
  --Now that the setting changed, reconfig themes
  tecConfigThemes()
  
  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
    GUIframe.configs.tabEchoStyle = tabsFontStyle --reset GUIframe tabs draw style.
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
  
  --Redraw all tabs, this includes labels.  
  tecRedrawLabels()
  
  dontForgetToSave() --reminder player to save
  cecho("") --cechoLink does not new line itself.

end --end tecClientSetTabFontSize(numbertemp)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSaveWindowText(tecWindow, tecDirectory)</name>
					<packageName></packageName>
					<script>--copy text in a window to clip board
function tecSaveWindowText(tecWindow, tecDirectory)
	
	--if directory not specified default to debug folder.
	tecDirectory = tecDirectory or tecDebugSaveDir
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"

	--get total number of lines in window
	local tecWinLineCount = getLastLineNumber(tecWindow)
	--create a table with windows contents
	local windowDataToCopy = getLines(tecWindow, 1, tecWinLineCount)

	--Create a table to save to file. Has to be a file because a string can not be saved
	--to a file we specify.
	local tecWindowBufferString = "INFO: Text shown from latest line to oldest."
	--Loop through all the lines in the table created from the lines in the window.
	for i = tecWinLineCount, 1, -1 do
		--check if a password or login ID may be in the line
		if string.find(tostring(windowDataToCopy[i]), "LOGIN") 
		or string.find(tostring(windowDataToCopy[i]), "Login")
		or string.find(tostring(windowDataToCopy[i]), "login")
		or string.find(tostring(windowDataToCopy[i]), "PASSWORD")
		or string.find(tostring(windowDataToCopy[i]), "Password")
		or string.find(tostring(windowDataToCopy[i]), "password")
		then --replace them with a notice if they are
			tecWindowBufferString = tecWindowBufferString.."A login event was on this line.\n"
		else
			--Put all the lines into one easy to read string.
			tecWindowBufferString = tecWindowBufferString..tostring(windowDataToCopy[i]).."\n"
		end --if else tecWindowBufferString contains login or password
	end --for tecWinLineCount


	--Checking if folder user requested exists.
	--If it does not, then create the folder.
	--if folder created without error write the buffer string to file.
	--If a folder can not be created, output an error
  local lfs = require( "lfs" ) --load lfs module www.tutorialspoint.com/lua/lua_modules.htm
  --Attempt to change current working directory
  local tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
  if ( tecFolderExists ) then --if folder exists, can be cd into...
  	--Save window contents to file.
    io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
    io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
    io.output():close() --Close the file
		pecho("Window saved\n")
  else --if the folder does not exist.
  	lfs.mkdir( tecDirectory ) --make the directory.
		tecFolderExists = nil --clear the folder check
    tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
    if ( tecFolderExists ) then --if folder exists or can be cd into.
    	--Save window to file.
      io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
      io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
      io.output():close() --Close the file
			pecho("Window saved\n")
		else --the folder could not be created.
			pecho("unable to create folder"..tecDirectory)
			debugToDisplay("unable to create folder"..tecDirectory)
		end --if tecFolderExists
  end --if tecFolderExists else
		
end --function tecSaveWindowText</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecOpenDirectory(tecTMPDir)</name>
					<packageName></packageName>
					<script>--opens a directory in the local browser.
--This will need to have code added to detect linux and mac.

function tecOpenDirectory(tecTMPDir)
	if getOS() == "windows" then
		os.execute("start \"\" \""..tecTMPDir.."\"") --opens explorer to the folder requested
	elseif getOS() == "mac" then
		pecho("Sorry mac is currently not supported. Please open finder and go to: "
			..tecTMPDir)
	elseif getOS() == "linux" then
		pecho("Sorry linux is currently not supported. Please open a file browser and go to: "
			..tecTMPDir)
	end --if os version
end --tecOpenDirectory</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>techreplace</name>
					<packageName></packageName>
					<script>--here purely as a reminder of the first hurdle overcome to start Parthia.
--wound up finding hinsertText would sometimes cause issues with the 
--main text filter trigger. Sometimes it would stop filtering.
--Issue went away when I switched to hecho 
function techreplace(window, text)
    if not text then text, window = window, nil end
    window = window or "main"
    local str, start, stop = getSelection(window)
    if window ~= "main" then
				selectCurrentLine(window)
				replace(window, "")
				hinsertText(window, text)
				deselect()
    else
				selectCurrentLine()
        replace("")
				hinsertText(text)
				deselect()
    end
end</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Colors</name>
					<packageName></packageName>
					<script>--[[
functions for changing colors on the client.
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>tecLabelBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the background for labels that are not tabs.
function tecLabelBackgroundColor(tecColor)
  tecSettings.labelBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecTabsBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color for tab labels
function tecTabsBackgroundColor(tecColor)
  tecSettings.tabsBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetMouseHoverColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color a label changes to when a mouse hovers over it.
function tecSetMouseHoverColor(tecColor)
  tecSettings.hoverColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetHelpHighlightColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color commands are highlighted in help menus.
function tecSetHelpHighlightColor(tecColor)
  tecSettings.helpHighlightColor = tecColor
  tecRefreshSettingsWindow() --refresh settings window text
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGreenTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetGreenTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GreenTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBlueTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default blue text.
function tecSetBlueTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.BlueTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGrayTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default gray text.
function tecSetGrayTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GrayTextColor = Geyser.Color.hex(tecColor)

  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetPurpleTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default gray text.
function tecSetPurpleTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.PurpleTextColor = Geyser.Color.hex(tecColor)

  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for main text.
function tecSetTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.tecTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for console background colors.
function tecSetBackgroundColor(tecColor)
  --reference: https://wiki.mudlet.org/w/Manual:Lua_Functions#setBackgroundColor
  --https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#setBgColor
  for index, windowName in ipairs(tecTextWindowNames) do
    local rb, gb, bb = Geyser.Color.parse(tecColor)
    local hexColor = Geyser.Color.hhex(rb, gb, bb)
    hexColor = hexColor:sub(2,7)
    debugToDisplay("Color Change: "..windowName.." background to "
      ..rb..","..gb..","..bb.." hex value: "..hexColor.."\n")
    setBackgroundColor(windowName, rb, gb, bb) --change background color
    setBgColor(windowName, rb, gb, bb) --change background color for cechos
    setHexBgColor(windowName, hexColor)
  end
  
  runTECRoomObjectCheck(false)
  pecho("Text box background color changes are saved by mudlet immediately.\n"
    .."If using windows you will need to restart for text background "
    .."colors to change")
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecNotApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for not approached characters.
function tecSettecNotApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.notApproachedCharacterColor = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for approached characters.
function tecSettecApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.ApproachedCharactersColor = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecColorWindow()</name>
						<packageName></packageName>
						<script>--Creates a window for users to easily select text.

-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs,rhs)
  local lh,ll,lv = unpack(lhs.sort)
  local rh,rl,rv = unpack(rhs.sort)
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end

-- internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a,b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname &lt; bname
end

-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  
  local d = max - min
  if max == 0 then 
    s = 0 
  else 
    s = d / max 
  end
  
  if max == min then
    h = 0 -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then h = h + 6 end
    elseif max == g then 
      h = (b - r) / d + 2
    elseif max == b then 
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  
  return h, s, v
end

-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r,g,b)
  local lum = math.sqrt( .241 * r + .691 * g + .068 * b )
  local reps = 8
  
  local h, s, v = rgbToHsv(r,g,b)
  
  local h2 = math.floor(h * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then 
    v2 = reps - v2
    lum = reps - lum
  end
  return h2, lum, v2
end

local function calc_luminosity(r,g,b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end


--- Prints out a formatted list of all available named colors (EXCEPT FOR
--- the 256 colors with names of form "ansi_###" where ### is 000 to 255),
--- optional args specifies:
--- * (number) number of columns to print in, defaults to 4;
--- * (string) substring required to match to include in output, defaults to
--- showing all if not supplied;
--- * (boolean) whether to sort the output, defaults to false.
--- @usage Print list in 4 columns by default.
---   &lt;pre&gt;
---   showColors()
---   &lt;/pre&gt;
--- @usage Print list in 2 columns.
---   &lt;pre&gt;
---   showColors(2)
---   &lt;/pre&gt;
---
--- @see color_table

function tecShowColors(...)
  local cols, search, sort = 4, "", false
  for _, val in ipairs(arg) do
    if type(val) == "string" then
      search = val:lower()
    elseif type(val) == "number" then
      cols = val
    elseif type(val) == "boolean" then
      sort = val
    end
  end
  
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if not string.find(k, "ansi_%d%d%d") then
      table.insert(colors,color)
    end
  end
  
  if sort then 
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors,sortColorsByHue) 
  end
  local i = 1
  for _, k in ipairs(colors) do
    if k.name:lower():find(search) then
      local v = k.rgb
      local fgc = "white"
      if calc_luminosity(v[1],v[2],v[3]) &gt; 0.5 then
        fgc = "black"
      end
      cechoLink("Color_Selector", string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ',fgc,k.name,k.name), [[appendCmdLine("]] .. k.name .. [[")]], table.concat(v, ", "), true)
      if i == cols then
        echo("Color_Selector","\n")
        i = 1
      else
        i = i + 1
      end
    end
  end
  if i ~= 1 then echo("\n") end
end

function tecColorWindow()
  openUserWindow("Color_Selector")
  clearUserWindow("Color_Selector")
  enableScrollBar("Color_Selector")
  tecShowColors(4)
  cecho("If the color choice window opened in an odd location "
  .."it can be moved by left clicking its title bar and dragging it.\n"
  .."It does not need to be docked at any location, it can free float anywhere "
  .."in your monitor.\nIt is also fully resizable by clicking and dragging "
  .."its outer edges.\n")
  cecho("Color_Selector",
    "\nClick a color to add it to the end of the command bar.")
end --function tecColorWindow()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSetBetaTester(betaTester)</name>
					<packageName></packageName>
					<script>function tecSetBetaTester(betaTester)
  betaTester = fuzzyBoolean(betaTester) --make certain nothin odd gets sent.
  tecSettings.betaTester = betaTester --tell Parthia player is a beta tester.
  
  if tecSettings.betaTester then
    pecho("You will now receive beta updates.\n\tThank you this helps us a GREAT deal!\n")
  else
    pecho("You will not receive beta updates.\n")
  end --if betaTester
  
  dontForgetToSave() --remind player to save
end --function tecSetBetaTester(betaTester)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecGetBetaTester()</name>
					<packageName></packageName>
					<script>function tecGetBetaTester()
  return tecSettings.betaTester
end --function tecGetBetaTester</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Player Development Folders</name>
					<packageName></packageName>
					<script>--if the player development table does not exist, create it.
if not PlayerDev then PlayerDev = {} end</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.SetPackages()</name>
						<packageName></packageName>
						<script>--Install or remove player development packages.
 function PlayerDev.SetPackages(mode)
  mode = fuzzyBoolean(mode)
  --table contains information on packages needing installation
  local packageTable = { trigger = { file = "Your_Triggers.xml"},
                         alias   = { file = "Your_Aliases.xml"},
                         script  = {file  = "Your_Scripts.xml"}, 
                         timer   = {file  = "Your_Timmers.xml"},
                         keybind = {file  = "Your_Key_Bindings.xml"},
                       }
  
  --loop through the packageTable. Check if the package needs to be installed.
  for packageType, packageToInstall in pairs(packageTable) do
    --the folder the package makes after it is installed.
    local packageFolder = packageToInstall.file:match("^(%a+_%a+_?%a*)")
    debugToDisplay("function PlayerDevCreateScripts, packageType is "..packageType..", packageToInstall.file is "
      ..packageToInstall.file.." packageFolder is "..packageFolder)
    local localPackageFile = tecSettingsFolder..packageToInstall.file --full folder and file name of package to install
    if mode then --if the function was sent true, install needed packages.
      if exists(packageFolder, packageType) == 0 then --check if the package's folder does not exist
        --check if the file for the package exists, if it does install it.
        if io.exists(localPackageFile) then --package file found
          debugToDisplay("function PlayerDevCreateScripts, "..localPackageFile
            .." found attempting package installation.")
          installPackage(localPackageFile) --install the package.
        else --the file for the package does not exist, show an error.
          errorFound = "player package file "..localPackageFile.." does NOT exits.\n"
          tecErrorNotification("function PlayerDevCreateScripts, "..errorFound)
        end --if io.exists(localPackageFile)
      end --if exists(packageFolder, packageType)
    else --mode is false, remove the player packages
      if exists(packageFolder, packageType) &gt; 0 then --check if the package's folder exist
          uninstallPackage(packageFolder) --remove the package.
          tecSettings.PlayerDevelopmentSpaceEnabled = mode
      else --the package does not exist.
          errorFound = "player package "..packageFolder.." does NOT exits.\n"
          tecErrorNotification("function PlayerDevCreateScripts, "..errorFound)
       end --if exists(packageFolder, packageType) &gt; 0
    end --if mode
  end --for pairs(packageTable)
  if not mode then --if uninstalling packages
    pecho("Packages removed. If changes are not saved, packages will reinstall with next update.\n")
    dontForgetToSave() --tell player to save
  end --if not mode
end --function PlayerDev.SetPackages(mode)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.Triggers()</name>
						<packageName></packageName>
						<script>--create triggers in the player development space.
--reference https://wiki.mudlet.org/w/Manual:Lua_Functions
function PlayerDev.Triggers()

  --[[
  To add a trigger to a player's development space, it needs to be in the triggersTable
  An example of a trigger to add to the triggersTable is:
  COPY BELOW  
    subTableNameMustBeUnique = { 
        name = "Trigger name, must be unique", 
        parent = "Player Game Events",
        triggerType = "substring",
        patterns = {"trigger ", "patterns here"},
        code = "--Should be a commented description.\n" }
  COPY ABOVE
    name, is the name that will show in the triggers section of the editor.
    parent, is the group the trigger needs to go in. Most likely will be "Player Game Evets"
    triggerType, can be "substring" "regex" or "beginofline"
    patterns, is a table. It can contain one or more triggers like "You fall"
      The patterns have to be surrounded by {}, with commas between each trigger.
      for example {"trigger one", "trigger two", "trigger three}
    code, is the lua code that the trigger will run. I recommend making this commented
      code to describe when the trigger will trigger.
  ]]--
  
  local triggerSuffix = " -Do not change this name-" --Will be added to the end of each trigger. To give it a unique name and tell player not to change it.
  local playerTriggersParentGroup = "Player Game Events"..triggerSuffix

  local triggersTable = {

    PlayerApproaches = { 
      name = "Player approaches a character", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"You stop next to "},
      code = "--triggers when the player approaches something.\n" },

    PlayerRetreat = { 
    	name = "Player retreats", 
    	parent = playerTriggersParentGroup,
    	triggerType = "beginofline",
    	patterns = {"You retreat."},
    	code = "--triggers when a player retreats or falls back.\n" },

    PlayerIsApproached = { 
	   name = "Player is approached", 
	   parent = playerTriggersParentGroup,
	   triggerType = "substring",
	   patterns = {"stops next to you."},
	   code = "--triggers when a player's character is approached.\n" },

    CharacterEntersRoom = { 
      name = "Character walks into players room", 
	    parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"walks in", "runs in", "flies in"},
      code = "--triggers when a character enters the players room.\n" },

    CharacterLeavesRoom = { 
      name = "Character leave players room", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"walks away", "runs away", "flies away"},
      code = "--triggers when a character leaves the players room.\n" },
      
    NPCSpawns = { 
      name = "Character Arrives", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"arrives."},
      code = "--triggers when an NPC is spawned.\n" },
      
    PlayerRoomChange = { 
      name = "Player enters a room", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"You arrive at "},
      code = "--triggers when the player enters a new room.\n" },
      
    SuccessfulLogin = { 
      name = "Successful login", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"&lt;center&gt;*** Login successful"},
      code = "--triggers after a successful login.\n" },
      
    VisionLoss = { 
      name = "Vision loss", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"It is too dark to see anything."},
      code = "--Triggers when the player can not see.\n" }
  } --substringTriggers

  --loop through the triggers to install.
  --if they do no already exist. Install them.
  for _, triggerTable in pairs(triggersTable) do
    local createTrigger = nil --Will be used to store a function to create desired trigger type
    if exists(triggerTable.name..triggerSuffix, "trigger") == 0 then --the trigger does NOT exists
      debugToDisplay("function PlayerDev.Triggers, Trigger "..triggerTable.name
        ..triggerSuffix.." does not exist, creating it.\n")
      --Find the type of trigger being created. 
      --Once found make createTrigger a copy of the function needed to create the trigger
      if triggerTable.triggerType:lower() == "substring" then --check the type of trigger needed to be made
        createTrigger = permSubstringTrigger --createTrigger is now permSubstringTrigger, it will create a substring trigger when called
      elseif triggerTable.triggerType:lower() == "beginofline" then --check the type of trigger needed to be made
        createTrigger = permBeginOfLineStringTrigger --createTrigger is now permBeginOfLineStringTrigger, it will create a begin of line or start of line trigger when called
      elseif triggerTable.triggerType:lower() == "regex" then --check the type of trigger needed to be made
        createTrigger = permRegexTrigger --createTrigger is now permRegexTrigger, it will create a perl regex trigger when called
      else --no good trigger type found
        tecErrorNotification("function PlayerDev.Triggers, no good trigger type found. "
          .."Correct trigger types are substring, beginofline and regex.")
      end --if TriggerTable.triggerType.lower() == "substring"
      if exists(triggerTable.parent, "trigger") == 0 then --the parent ground the trigger needs to go to does not exist
        tecWarningNotification("function PlayerDev.Triggers, parent group "..triggerTable.parent.." does not exist.\n") 
      else --the parent group to the trigger exists, so make the trigger.
        createTrigger(triggerTable.name..triggerSuffix, triggerTable.parent, triggerTable.patterns, triggerTable.code)
        disableTrigger(triggerTable.name..triggerSuffix) --disable the trigger, so it is not needlessly checked
      end --if exists(triggerTable.parent, "trigger") == 0
    end --if exists(TriggerName, "trigger") == 0
  end --for pairs(triggersTable)

end --function PlayDevSubstringTriggers()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.GetEnabled()</name>
						<packageName></packageName>
						<script>--returns if the player development mode
function PlayerDev.GetEnabled()
  if tecSettings.PlayerDevelopmentSpaceEnabled then --if the variable exists and is true
    return tecSettings.PlayerDevelopmentSpaceEnabled --return it
  else --if the variable does not exist.
    return false --We know the player has not set the enabled variable, so return false
  end --if tecSettings.PlayerDevelopmentSpaceEnabled
end --function PlayerDev.Get()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.Update()</name>
						<packageName></packageName>
						<script>--Add new code to the players development folders.
function PlayerDev.Update(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  if PlayerDev.GetEnabled() then --if player dev space is enabled
    if displayToScreen then pecho("Checking if player development modules need to be installed.\n") end
    PlayerDev.SetPackages(true) --Install modules if they do not already exist.
    if displayToScreen then pecho("Installing new player development triggers.\n") end
    PlayerDev.Triggers() --create player triggers
    if displayToScreen then pecho("Completed updating player development folders.\n") end
  end --if PlayerDev.GetEnabled()
end --function PlayerDev.runUpdate()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.SetEnabled(mode)</name>
						<packageName></packageName>
						<script>--set and save if the player wanted their player development space created
function PlayerDev.SetEnabled(mode)
  mode = fuzzyBoolean(mode) --make certain correct boolean sent.
  tecSettings.PlayerDevelopmentSpaceEnabled = mode --make certain this setting can be saved
  if mode then --player wants the player development space created.
    pecho("Creating folders for you in the script editor. Each section will have a folder "
      .."starting with Your_. Save your code to these folders.\nWe will never remove "
      .."code from these folders. With updates we may add code to these folders. "
      .."Only if it will not replace code you have created. In mudlet\'s editor "
      .."folders are called groups.\n")
    PlayerDev.Update() --installed player modules and code, or updates it
    pecho("Player development folders have been created. "
      .."Press alt\+e to open the script editor.\n")
  else --player does not want to contine to receive updates.
    pecho("If you save changes, you will no longer receive updates to the player "
      .."Your_ folders in the editor. This will not remove those folders.\n")
  end --if mode
  dontForgetToSave()
end --function PlayerDev.set(mode)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Git Updates</name>
					<packageName></packageName>
					<script>--Installs updates from github.
--Intended for projects that do not support downloading over telnet
--To allow error checking package file names must contain package type starting with a capitol
--IE: "My Project Name Scripts.xml" or "MyPackageNameTriggers.xml".

--start of section dedicated for functions used by update process.
--To understand the flow of updates you will need to scroll past these.
--There will be a comment stating when update flow starts.

-- fuzzyBoolean Provided by demonnic
-- Expands boolean definitions to be more flexible.
-- True values are "true", "yes", "0", 0, and true
-- False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
if not fuzzyBoolean then
  function fuzzyBoolean(bool)
    if type(bool) == "boolean" or bool == nil then
      return bool
    elseif tostring(bool) then
      local truth = {
        "yes",
        "true",
        "0"
      }
      local untruth = {
        "no",
        "false",
        "1"
      }
      local boolstr = tostring(bool)
      if table.contains(truth, boolstr) then
        return true
      elseif table.contains(untruth, boolstr) then
        return false
      else
        return nil
      end
    else
      return nil
    end
  end
end --if not fuzzyBoolean

function GitUpdateconfig() --Create variables used for updates

  if GitUpdate then 
    --if events were previously created, kill them.
    if GitUpdate.downloadDoneID then
      killAnonymousEventHandler(GitUpdate.downloadDoneID)
    end --if GitUpdate.downloadDoneID
    if GitUpdate.downloadErrorID then
      killAnonymousEventHandler(GitUpdate.downloadErrorID)
    end --if GitUpdate.downloadErrorID
    if GitUpdate.installPackageID then
      killAnonymousEventHandler(GitUpdate.installPackageID)
    end --if GitUpdate.installPackageID
    if GitUpdate.uninstallPackageID then
      killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
    end --if GitUpdate.downloadDoneID
  end --if GitUpdate

  GitUpdate = GitUpdate or {} --table to hold project variables

  --API URL for git hub for project
  GitUpdate.gitReleaseURL = [[https://api.github.com/repos/TheEternalCitizens/mudlet-integration/releases]]
  GitUpdate.localRespitory = getMudletHomeDir().."/settings/" --local directory for source files
  if not io.exists(GitUpdate.localRespitory) then --if folder does not exists
    lfs.mkdir(GitUpdate.localRespitory) --create the folder
    debugToDisplay("Update: ERROR localRespitory was not present. Has been created.")
  end --if GitUpdate.localRespitory not exist
  GitUpdate.gitReleaseURLJSONFile = "ParthiaLatest.json" --local file name REST API latest JSON
  GitUpdate.localVersion = "0.1.32" --Must match the tag in your github release
  GitUpdate.aliasName = "parthia update" --Name of alias user runs to process update
  --Name of the alias to check if an update is available.
  GitUpdate.updateCheckAlias = "parthia update check" 
  --The full name or a word in the file that this update script is in.
  GitUpdate.updateFileNameReference = "Scripts"
  --notify update engine if player is a beta tester. If the player is a beta
  --tester they will receive update notices for pre-releases for your project
  GitUpdate.betaTester = tecSettings.betaTester 
  --packages that are no longer used in the project and should be removed.
  --They can not share a name with a package that you need. Otherwise this will uninstall it.
  GitUpdate.removePackages = {"TECClientScripts", "TECClientTriggers",
    "TECClientAliases", "TECClientKeyBindings"}
  GitUpdate.removeModules = {} --modules that are no longer used in the project and should be removed.
  --Used to tell player correct installation method if they installed scripts as modules
  GitUpdate.installationURL = "https://github.com/TheEternalCitizens/mudlet-integration/wiki/Installation"
  --use in a repair aliase, set this variable to true if a repair install is needed.
  GitUpdate.repairInstall = fuzzyBoolean(GitUpdate.repairInstall)
  --cecho compatible color, it will hightlight cecholinks in the update process
  GitUpdate.cmdHighlight = "blue"
  --Copy a function you would like to have run when an update is completed.
  --Make false if you do not want it to run after the update has completed.
  GitUpdate.postUpdateFunction = PlayerDev.Update

  --No need to change variables below
  GitUpdate.filePattern = ".*%/(.*%..*)$" --string pattern to detect file name at end of url or file path string
  GitUpdate.downloadError = false --Sets to true if there is a download error.
  GitUpdate.installationError = false --sets to true if there is a package installation error.
  GitUpdate.installationInProgress = false --notifies update engine if update is running.
  GitUpdate.releaseIndex = 0 --Position on proper update in gitHub JSON table
  GitUpdate.trackedURLs = {} --will be URLs that need to have downloads tracked
  --create event handlers.
  GitUpdate.downloadDoneID = registerAnonymousEventHandler("sysDownloadDone", "GitUpdateEventHandler")
  GitUpdate.downloadErrorID = registerAnonymousEventHandler("sysDownloadError", "GitUpdateEventHandler")
  GitUpdate.installPackageID = registerAnonymousEventHandler("sysInstallPackage", "GitUpdateEventHandler")
  GitUpdate.uninstallPackageID = registerAnonymousEventHandler("sysUninstallPackage", "GitUpdateEventHandler")
  trackedDownloads = {} --leave blank, needed for events. Is initialized in function trackDownloads
  trackedDownloads.fileList = "" --leave blank, needed for events. Initialized in function trackDownloads
  trackedDownloads.urlList = "" --leave blank, used to check for download errors.
  
  debugToDisplay("function GitUpdate.config: Initialized update engine.\n\tgitReleaseURL: "..GitUpdate.gitReleaseURL
    .."\n\tScriptFileNameReference: "..GitUpdate.updateFileNameReference
    .."\n\tlocalRespitory: "..GitUpdate.localRespitory
    .."\n\tgitReleaseURLJSONFile: "..GitUpdate.gitReleaseURLJSONFile
    .."\n\tLocal Parthia version: "..GitUpdate.localVersion)
end --function GitUpdateconfig()

--displays messages to debugc.
--can be changed to send to what ever console you would like with cecho
if not debugToDisplay then 
  function debugToDisplay(textMessage)
  		debugc(textMessage) -- print message to screen
  end --end displayToDebug function
end --if not debugToDisplay

if not pecho then
  pecho = cecho
end

if not pechoLink then
  pechoLink = cechoLink
end

--Displays a yellow notice to debug console
if not tecWarningNotification then
  --fully notifies user when an error is found.
  function tecWarningNotification(errorFound)
    debugc("Warning: "..errorFound)
  end --function tecErrorNotification
end --if not tecWarningNotification then

if not ReplaceStringMagicChar then
  --used to replace magic characters in a string with the proper escape character 
  --sequence. Useful for replacing file names on sysDownload events.
  function ReplaceStringMagicChar(tmpString)
    tmpString = tmpString:gsub("%%", "%%%")
    tmpString = tmpString:gsub("%(", "%%(")
    tmpString = tmpString:gsub("%)", "%%)")
    tmpString = tmpString:gsub("%.", "%%.")
    tmpString = tmpString:gsub("%+", "%%+")
    tmpString = tmpString:gsub("%[", "%%[")
    tmpString = tmpString:gsub("%^", "%%^")
    tmpString = tmpString:gsub("%$", "%%$")
    tmpString = tmpString:gsub("%-", "%%-")
    tmpString = tmpString:gsub("%*", "%%*")
    tmpString = tmpString:gsub("%?", "%%?")
  return tmpString
  end --function ReplaceStringMagicChar(tmpString)
end --if not ReplaceStringMagicChar

--displays a message to player that an error was found, and to contact a developer
if not tecErrorNotification then 
  function tecErrorNotification(errorFound)
    debugc("Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer.")
  end --function tecErrorNotification
end --if not tecErrorNotification

--Used to easily change update notification. There are multiple instances where
--Parthia notifies player an update is available.
local function updateAvailable(updateBody)
  --if this is a repair install. Download and install without prompting player.
  if GitUpdate.repairInstall then 
    --Start downloading scripts as a temptimer so the function that called
    --updateAvailable can complete.
    tempTimer(1, "DownloadGitScripts()")
    GitUpdate.repairInstall = false --reset so it will not run if player checks for updates
  else --this is not a repair install prompt the user if they would like to update.
    enableAlias(GitUpdate.aliasName) --enable alias so user can run update with command
    if pecho then --if parthia echo exists
      pecho("An update is available. The new features it offers are: \n\t")
      pecho(updateBody)
      pecho("\n&lt;:maroon&gt;To update now, run command ")
      pechoLink("&lt;:blue&gt;"..GitUpdate.aliasName, --link text to display
        [[expandAlias(GitUpdate.aliasName)]], --link command to run
        "Update game client", true) --link tool tip for mouse hover
      echo("\n") --cechoLinks don't cause the window to autoscroll.
    else --parthia echo does not exist
      cecho("An update is available. The new features it offers are: \n\t")
      cecho(updateBody)
      cecho("\n&lt;:maroon&gt;To update now, please run: ")
      cechoLink("&lt;:blue&gt;"..GitUpdate.aliasName, --link text to display
        [[expandAlias(GitUpdate.aliasName)]], --link command to run
        "Update game client", true) --link tool tip for mouse hover
      echo("\n") --cechoLinks don't cause the window to autoscroll.
    end --if pecho
  end --if GitUpdate.repairInstall
end --function updateAvailable

--gather urls from github release that player needs to update to
local function collectURLs()
  if GitUpdate.releaseIndex == 0 then --make certain releaseIndex has been initialized
    debugc("function: collectURL, url collection releaseIndex was not initialized.")
    return "function: compareVersions, url collection releaseIndex was not initialized."
  elseif GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets.browser_download_url then
    debugc("function: collectURL, url collection JSONTable lacks assets.")
    return "function: compareVersions, url collection JSONTable lacks assets."
  else
    for index, gitAsset in --loop through git release assets.
      ipairs(GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets) do
        --save URL needing download to a new table.
        --debugc("function: compareVersions tracking URL: "..gitAsset.browser_download_url)
        GitUpdate.trackedURLs[index] = gitAsset.browser_download_url
    end --for GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets
    debugToDisplay("function collectURLs(): GitUpdate.trackedURLs initialized.") 
  end --if releaseIndex == 0
end --collectURLS

--Search for latest nonbeta release or release that is NOT a prerelease
--function is here to reduce complexity of function that calls it.
local function releaseSearch()
  if GitUpdate.gitJSONTable[1].name then --if the table exists
    --debugc("gitUpdate release search, JSON table exists.")
    for index, releaseData in ipairs(GitUpdate.gitJSONTable) do --loop through the JSON table
      --debugc("gitUpdate release search, searching index: "..tostring(index))
      debugToDisplay("function releaseSearch, searching index: "..tostring(index))
      --Find the latest release that is NOT a prerelease.
      if not releaseData.prerelease then --if the release is not a prerelease
        --debugc("gitUpdate release search, found latest release at: "..tostring(index))
        debugToDisplay("function releaseSearch, found latest release at: "..tostring(index)
          .."\n\tRelease tab_name: "..releaseData.tag_name
          .." Local release: "..GitUpdate.localVersion)
        --If the installed Parthia is different that latest release
        if releaseData.tag_name ~= GitUpdate.localVersion then
          GitUpdate.releaseIndex = index --collect the release index
          local errorFound collectURLs() --gather URLs into trackedURLs table
          if errorFound then --collectURLs returns a string if error occured.
            return errorFound
          else
            updateAvailable(releaseData.body) --notify player an update is available
            return
          end --if errorFound else
        else --if releaseData.tag_name ~= GitUpdate.localVersion, Parthia up to date.
          --if this is a repair install. Run the update even if the versions match 
          if GitUpdate.repairInstall then
            GitUpdate.releaseIndex = index --collect the release index
            local errorFound collectURLs() --gather URLs into trackedURLs table
            if errorFound then --collectURLs returns a string if error occured.
              return errorFound
            else
              updateAvailable(releaseData.body) --notify player an update is available
              return --end releaseSearch
            end --if errorFound
          else --this is not a repair install. So let the player know no update is available.
            if pecho then pecho("Parthia is up to date.\n")
            else cecho("Parthia is up to date.\n") end
            return --end releaseSearch()
          end 
        end --if releaseData.prerelease.tag_name ~= GitUpdate.localVersion
      end --if releaseData.prerelease == "false"
    end --for
  else --if the JSON table does NOT exist.
    errorFound = "function releaseSearch, Error, JSON table not found during release search."
    return errorFound--error found stop update.
  end --if GitUpdate.gitJSONTable[1].name exists
end --function releaseSearch

--Tracks downloads so updates do not start until all downloads have completed.
--This has been created to allow it to be module.
--downloadURL is a table containing a urls that need to be downloaded.
--!!!trackDownloads(downloadURLs) HAS to be ran BEFORE the downloads are initiated!!!
function trackDownloads(downloadURLs)  
  if downloadURLs[1] then --if downloadURLs is a table
    debugToDisplay("function trackDownloads, table passed.")
    --move the URL containing the script name to the end of the table.
    for index, urlToTrack in ipairs(downloadURLs) do
      if urlToTrack:match(GitUpdate.updateFileNameReference) then
        debugToDisplay("function trackDownloads, URL containing update script was found at\n\t"
          ..urlToTrack.." moving it to end of table.")
        table.remove(downloadURLs, index) --remove the URL from the table
        table.insert(downloadURLs, urlToTrack) --insert it on the end of the table
        break --Update script can only be in one file.
      end --urlToTrack:match(GitUpdate.updateFileNameReference)
    end --for downloadURLs
    --Make a global table to store URLs that require tracking.
    trackedDownloads = {files = {}, URLs = {}, downloaded = {}, fileList = "", tmpFiles = {}
                        , urlList = ""}
    for index, urlToTrack in ipairs(downloadURLs) do --initialize trackedDownloads table
      --Get the name of the file you need to download.
      local TmpPackageFileName = urlToTrack:match(GitUpdate.filePattern)
      --debugc("TmpPackageFileName "..TmpPackageFileName)
      --Collect package name removing any .s periods that are in it.
      --in git releases spaces in filenames are replaced with .s mudlets install package process
      --is sometimes not compatible with this.
      local PackageNameNoExtension = string.gsub(TmpPackageFileName:match("(.*)%..*$"), "%.", " ") 
      --debugc("PackageNameNoExtension: "..PackageNameNoExtension)
      local PackageNameExtensionOnly = TmpPackageFileName:match(".*(%..*)$")
      --debugc("PackageNameExtensionOnly: "..PackageNameExtensionOnly)
      --Combine the package name with file extension.
      trackedDownloads.files[index] = PackageNameNoExtension..PackageNameExtensionOnly
      debugToDisplay("function: trackDownloads tracking file: "..trackedDownloads.files[index])
      --Boolean to notify client when download has completed.
      trackedDownloads.downloaded[index] = false
      --Get the name of the file you need to download.
      trackedDownloads.URLs[index] = urlToTrack
      --create a string that contains a list of files needing download.
      --This list will be used during sysDownloadDone event to veirfy the correct download
      trackedDownloads.fileList = trackedDownloads.fileList..trackedDownloads.files[index].." "
      --Used to catch download errors.
      trackedDownloads.urlList = trackedDownloads.urlList..urlToTrack.." "
    end --for downloadURLs

  elseif type(downloadURLs) == "string" then --if the variable passed is a string
    debugToDisplay("function: trackDownloads string passed.")
    debugToDisplay("function trackedDownloads: URL passed: "..downloadURLs)  
    if trackedDownloads.files[1] then --make certain the trackedDownloads table exists
      --Look through trackedDownloads table to see if this is one of the tracked URLs
      for index, trackedDownload in ipairs(trackedDownloads.files) do      
        --if the string passed matches a file name in trackedDownloads
        if trackedDownload:match(downloadURLs) then
          debugToDisplay("function trackedDownload: download completed and recorded for: "
            ..trackedDownload)
          trackedDownloads.downloaded[index] = true --record that this URL downloaded successfully.
            --check if all downloads have completed.
            for index, urlDownloaded in ipairs(trackedDownloads.downloaded) do
              if urlDownloaded then --has the current URL affiliaed with the bool been downloaded.
                --debugc("function trackedDownloads: Verifing download completed for index "..index)
                --If all downloaded booleans in table are true.
                if index == #trackedDownloads.downloaded then
                  debugToDisplay("function trackedDownloads: downloads completed.")
                  return true --tells parthia all downloads are complete.
                end --if index == #trackedDownloads.downloaded
              else --Some file in the set has not been downloaded.
                return false --tells parthia all downloads are not complete
              end --if urlDownloaded
            end --for trackedDownloads.downloaded
          break --break the for loop.
        end --if trackedDownload == downloadURLs
      end --for trackedDownloads
    else
      --display error to debug, and return error message to called function
      errorc("function trackDownloads: was not initialized with a table of URLs.")
      return "function trackDownloads: was not initialized with a table of URLs."
    end --if downloadURLs
  else --argument was not a table or string.
    local errorFound = "function trackDownloads: does not accept "..type(downloadURLs)
      .." as an argument.\n\tOnly supports tables for initilization and strings for tracking."
    errorc(errorFound)
    return errorFound
  end --if downloadURLs type check
end --function trackDownloads

--Here moving forward if you would like to understand the flow of updates
--it starts here.

--downloads the github JSON REST API JSON file
function DownloadGitReleaseJSON()
  --check if an installation is in progress.
  if GitUpdate then if GitUpdate.installationInProgress then
    echo("An update is currently processing. Only one update can run at a time.\n")
    return --stop updates one is processing.
  end end
  GitUpdateconfig() --initialize update engine.
  GitUpdate.installationInProgress = true --notify Parthia an update is in progress
  debugToDisplay("Update: Downloading "..GitUpdate.gitReleaseURL
    .."\n\tTo: "..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
  downloadFile(GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile,
    GitUpdate.gitReleaseURL) --download the projects latest release JSON info file.
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
end --function DownloadGitReleaseJSON

--after the JSON files is downloaded GitUpdateEventHandler will run compareVersions

--check if version in use is the latest released
--If player is beta test we compare the latest release both prerelease and release 
--If standard player we look for latest release not prerelease
local function compareVersions()
  debugToDisplay("function compareVersions, opening &amp; reading file:\n\t"
    ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
  --open the local github latest release JSON file in read only mode
  local gitJSONFile, errorFound = 
    io.open(GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile, "r")
  if not gitJSONFile then --file was not created error occured.
    tecErrorNotification("function compareVersions: "..errorFound)
    gitJSONFile:close() --incase of partial failure, close file.
    gitJSONFile = nil
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return  --error found stop update.
  end --if not gitJSONFile
  local gitJSONString = gitJSONFile:read("*a") --read the entire file to a string
  gitJSONFile:close() --close the file
  gitJSONFile = nil
  if not gitJSONString then --the file did not read correctly.
    tecErrorNotification("function compareVersions, file read failure.\n\t"
      ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --error found stop update.
  end --if not gitJSONString
  --Convert github release JSON into a table
  GitUpdate.gitJSONTable = yajl.to_value(gitJSONString)
  if GitUpdate.gitJSONTable[1].name then --if the table was made.
    debugToDisplay("function compareVersions, file read successful.")
  else --if the table was not successfully made we can not continue. Notify player.
    errorFound = "Update: Error, JSON to table conversion unsuccessfull.\n\tOpened file: "
      ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile
      .."\n\tIt contained: "..gitJSONString
    tecErrorNotification(errorFound) --Notify player provide method to report error
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --error found stop update.
  end --GitUpdate.gitJSONTable exists
  
  --Look the table for the latest non beta release.
  if GitUpdate.betaTester then --if player is a beta tester install latest release   
    --if latest release tag_name does not match local version number.
    debugToDisplay("Update: Release installed: "..GitUpdate.localVersion
      .."\n\tLatest release: "..GitUpdate.gitJSONTable[1].tag_name)
    if GitUpdate.gitJSONTable[1].tag_name ~= GitUpdate.localVersion then
      GitUpdate.releaseIndex = 1 --notify update engine which version to use
      updateAvailable(GitUpdate.gitJSONTable[1].body) --notify player update is available
      local errorFound collectURLs() --gather URLs into trackedURLs table
      if errorFound then
        tecErrorNotification(errorFound)
        GitUpdate.installationInProgress = false --notify Parthia installation not running.
        return --error found stop update.
      end --if error found
    else
      --if this is a repair install. Run the update even if the versions match 
      if GitUpdate.repairInstall then
        GitUpdate.releaseIndex = 1 --collect the release index
        local errorFound collectURLs() --gather URLs into trackedURLs table
        if errorFound then --collectURLs returns a string if error occured.
          tecErrorNotification(errorFound)
          GitUpdate.installationInProgress = false --notify Parthia installation not running.
        else
          updateAvailable(GitUpdate.gitJSONTable[1].body) --notify player an update is available
          return --end releaseSearch
        end --if errorFound
      else --this is not a repair install. So let the player know no update is available.
        if pecho then pecho("Thank you for beta testing!\n\tNo new releases at this time.\n")
        else cecho("Thank you for beta testing!\n\tNo new releases at this time.\n") end
      end --if GitUpdate.repairInstall
    end --if beta tester is not using latest release
  else --The user is not a beta tester.
    local errorFound = releaseSearch() --search for latest NONbeta release
    if errorFound then
      tecErrorNotification(errorFound)
      GitUpdate.installationInProgress = false --notify Parthia installation not running.
      return --error found stop update.
    end --if error found
  end --if betaTester

  --We do not know how large the git release JSON is we will trash it just incase
  --doing this after error catch, if error is found this table will still exist
  GitUpdate.gitJSONTable = nil
  
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
  
end --function compareVersions

--The user has now run the aliase GitUpdate.aliasName to continue forward.

--Download the scripts in the latest release 
function DownloadGitScripts()
  --turn off the standard update command. So user will not attempt to run it while
  --it is running. Also leave it off so user can not process an update when one 
  --is not required.
  disableAlias(GitUpdate.aliasName)
  GitUpdate.downloadError = false --in case of previous download error.

  --check if an installation is in progress.
  if GitUpdate.installationInProgress then
    if pecho then
      pecho("An update is currently processing. Please wait for it to complete.\n"
        .."Once the update is done you will need to check if an update is still "
        .."required by running: ")
      pechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;"..GitUpdate.updateCheckAlias, 
        [[DownloadGitReleaseJSON()]],
        "Check for updates", true)
    else
      echo("An update is currently processing. Please wait for it to complete.\n"
        .."Once the update is done you will need to check if an update is still "
        .."required by running: ")
      cechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;"..GitUpdate.updateCheckAlias, 
        [[DownloadGitReleaseJSON()]],
        "Check for updates", true)
    end
    return
  end
  GitUpdate.installationInProgress = true --notify Parthia an update is in progress

  --if GitUpdate.trackedURLs has been initialized.
  if type(GitUpdate.trackedURLs[1]) == "string" then 
    trackDownloads(GitUpdate.trackedURLs) --initialize trackDownloads
  else --GitUpdate.trackedURLs was not initialized throw error.
    errorFound = "function DownloadGitScripts, trackedURLs was not initialized."
    tecErrorNotification(errorFound)
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --stop because we can not proceed.
  end --if GitUpdate.trackedURLs is not nil.

  --download the files required.
  for index, trackedDownload in ipairs(GitUpdate.trackedURLs) do
    debugToDisplay("function DownloadGitScripts, downloading "
      ..trackedDownload.."\n\tto "
      ..GitUpdate.localRespitory..trackedDownloads.files[index])
    --download file
    downloadFile(GitUpdate.localRespitory..trackedDownloads.files[index], trackedDownload)
  end --for GitUpdate.trackedURLs

--[[
  --this code can be used to test trackedDownloads without using sysDownloadDone function
  for index, trackedDownload in ipairs(GitUpdate.trackedURLs) do
    debugToDisplay("function GitUpdate.downloadScripts downloading "
      ..trackedDownload.."\n\tto "
      ..GitUpdate.localFileStore..trackedDownloads.files[index])
    boolOrErrorMessage = trackDownloads(trackedDownloads.files[index])
    local tmpString = GitUpdate.localFileStore..trackedDownloads.files[index]
    cecho("File name: "..tmpString:match(GitUpdate.filePattern).."\n")
    cecho("fileList is: "..trackedDownloads.fileList.."\n")
    cecho("Found match in fileList for file downloaded: "..
      trackedDownloads.fileList:match(tmpString:match(GitUpdate.filePattern)).."\n")
    if boolOrErrorMessage then
      debugToDisplay("Downloads completed!!!")
    end
  end --for GitUpdate.trackedURLs
]]--

end --function GitUpdate.downloadScripts()

--After all files have been downloaded GitUpdateEventHandler will call InstallGitUpdates

local function InstallGitUpdates()
  if GitUpdate.downloadError then --if a download error occured.
    tecErrorNotification("function InstallGitUpdates, Download error occured. Update can not be processed.\n")
    GitUpdate.downloadError = false --Reset now that we have caught the error.
  end --if GitUpdate.downloadError
  local localSourceDirectory = GitUpdate.localRespitory --Keep required data outside of GitUpdate
  for index, fileName in ipairs(trackedDownloads.files) do --loop through scripts, and install them
    local packageName = fileName:match("(.*)%.") --remove extension from filename
    local packageTypeList = {"alias", "trigger", "timer", "keybind", "script", 
                             "Alias", "Trigger", "Timer", "Keybind", "Script",
                             "KeyBind"}                               
    for index, packageTypeName in ipairs(packageTypeList) do
      packageType = packageName:match(packageTypeName) --find packageType in the package name
      if packageType then --package name contains a package type. Use it to error check.
        debugToDisplay("function InstallGitUpdates: Package type found, "
          ..packageType..". Error checking will be processed for" ..packageName)
        break --packageType found. Contining this would would nil packageType
      end --if packageType
    end --for ipairs(packageTypeList)

    --if this package is installed as a module. Do not install it.
    if getModulePath(packageName) then
      local errorFound = packageName..", is installed as a module. Having one script installed as "
        .."both a module and a package is not supported."
      tecWarningNotification("function InstallGitUpdates, "..errorFound)
      pecho(errorFound.." If you are not a developer player installation instructions "
        .."can be found ")
      pechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;here", 
        [[openUrl("]]..GitUpdate.installationURL..[[")]],
        "Player installation site", true)
      cecho("\n")
      
    else --script is not installed as a module already proceed with instalation as package
      uninstallPackage(packageName) --remove old package
      --comment out uninstallPackage and uncomment raiseEvent to test without uninstalling package
      --raiseEvent("sysUninstallPackage", packageName)
      
      if packageType then --package name contains a package type. Use it to error check.
        if 0 ~= exists(packageName, packageType) then --if packagename appears in mudlet
          debugToDisplay("&lt;yellow:&gt;Warning function InstallGitUpdates: appearance of the package "
            ..packageName.." in the "..packageType.." section unexpected.")
        end --if 0 ~= exists(packageName, packageType)
      end --if packageType
      
      installPackage(localSourceDirectory..fileName) --install new package
      --comment out installPackage and uncomment raiseEvent to test without installing package
      --raiseEvent("sysInstallPackage", packageName, localSourceDirectory..fileName)
      
      if packageType then --package name contains a package type. Use it to error check.
        if 0 == exists(packageName, packageType) then --if packageName does not exist in mudlet
          local errorFound = "function InstallGitUpdates: "..packageName.." was not found in "
            .." the "..packageType.." section. After package installation."
          tecErrorNotification(errorFound) --display error.
          GitUpdate.installationError = true --Notify InstallGitUpdates there is an error
        end --if 0 ~= exists(packageName, packageType)
      end --if packageType
    end --if getModulePath(packageName)

  end --for InstallGitUpdates
  
  if GitUpdate.installationError then --there were errors during installation.
    pecho("Errors during installation. Please report issues using the report issues button "
      .."in the settings window.\n")
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
      --if events were previously created, kill them.
    if GitUpdate.downloadDoneID then
      killAnonymousEventHandler(GitUpdate.downloadDoneID)
    end --if GitUpdate.downloadDoneID
    if GitUpdate.downloadErrorID then
      killAnonymousEventHandler(GitUpdate.downloadErrorID)
    end --if GitUpdate.downloadErrorID
    if GitUpdate.installPackageID then
      killAnonymousEventHandler(GitUpdate.installPackageID)
    end --if GitUpdate.installPackageID
    if GitUpdate.uninstallPackageID then
      killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
    end --if GitUpdate.downloadDoneID
    return --stop update process
  end --if GitUpdate.installationError
  
  --go through list of unwanted packages and modules remove them. GitUpdate.removeModules
  for _, removeScriptsTable in pairs({GitUpdate.removePackages, GitUpdate.removeModules}) do
    for _, packageToRemove in ipairs(removeScriptsTable) do
      uninstallPackage(packageToRemove) --uninstall unwanted packages.
      --check for a folder that shares a name with an unwanted package in each section type
      for _, packageType in ipairs( {"alias", "trigger", "timer", "keybind", "script"}) do
        --if the a folder exists with the name of an unwanted package
        if (exists(packageToRemove, packageType) &gt; 0) then 
          tecWarningNotification("function InstallGitUpdates, package "
            ..packageToRemove.." was removed but a folder for it still exits "
            .."in the "..packageType.." section.")
        end --if exists(packageToRemove)
      end --for ipairs( "alias", "trigger", "timer", "keybind", "script")
    end --for ipairs(GitUpdate.removePackages) 
  end --for pairs(GitUpdate.removePackages, GitUpdate.removeModules)
  
  --resetProfile() --reset to profile so UI will properly reset.
  pecho("Loading display please wait.\n")
  UIManagerSetTheme("PlayersTheme", false) --reset the display
  debugToDisplay("Updates completed.\n")
  pecho("Updates completed.\n")
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
    --if events were previously created, kill them.
  if GitUpdate.downloadDoneID then
    killAnonymousEventHandler(GitUpdate.downloadDoneID)
  end --if GitUpdate.downloadDoneID
  if GitUpdate.downloadErrorID then
    killAnonymousEventHandler(GitUpdate.downloadErrorID)
  end --if GitUpdate.downloadErrorID
  if GitUpdate.installPackageID then
    killAnonymousEventHandler(GitUpdate.installPackageID)
  end --if GitUpdate.installPackageID
  if GitUpdate.uninstallPackageID then
    killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
  end --if GitUpdate.downloadDoneID

  --runs a function specified in config
  if GitUpdate.postUpdateFunction then GitUpdate.postUpdateFunction(true) end

end --function InstallGitUpdates

function GitUpdateEventHandler(event, ...)
  if event == "sysDownloadDone" then --if it is a downloadDone event.
    --arg[1] is full file including directory
    --ReplaceStringMagicChar puts ecscape % before lua magic characters
    local file = ReplaceStringMagicChar(arg[1]) 
    debugToDisplay("function GitUpdateEventHandler, file downloaded post magic "
      .."character replacement it is:\n\t"..file)
    
    if GitUpdate.gitReleaseURLJSONFile:match(file:match(GitUpdate.filePattern)) then --download is version check file
      debugToDisplay("function GitUpdateEventHandler, Download: "..file
        .."\n\tcompareVersions() called.")
      compareVersions() --Use downloaded JSON file to check if latest version is installed
    --if the name of the file being downloaded is in trackedDownloads.fileList
    elseif trackedDownloads.fileList:match(file:match(GitUpdate.filePattern)) then
      local boolOrErrorMessage = trackDownloads(file:match(GitUpdate.filePattern))
          if boolOrErrorMessage then --if true, all files have downloaded.
            debugToDisplay("function GitUpdateEventHandler, all downloads completed. "
              .."Running function InstallGitUpdates()")
            InstallGitUpdates() --install the downloaded scripts
          elseif type(boolOrErrorMessage) == "string" then --if error found
            tecErrorNotification(boolOrErrorMessage) --notify player of error
          else --all downloads are not completed.
            debugToDisplay("function GitUpdateEventHandler, "..file.." completed downloading. Not all tracked files downloaded yet.")
          end --if boolOrErrorMessage
    else
      debugToDisplay("function GitUpdateEventHandler, Downloaded file: "..file
        .."\n\tWas NOT caught by event handler. If this SHOULD be a tracked download, system "
        .."attempted to track: "..file:match(GitUpdate.filePattern))
    end --elseif file downloaded is new script
  elseif event == "sysDownloadError" then --if there is a download error.
    local errorFound = arg[1] --sysDownloadError only argument is error message.
    local erroredURL = arg[1]:match(".*(https:%/%/%S+)") --retreive URL in error message
    --debugc("Errored URL: "..erroredURL)
    --if  then error download's URL matches downloads for this update engine
    if trackedDownloads.urlList:match(erroredURL) or GitUpdate.gitReleaseURL == erroredURL then
      tecErrorNotification("fuction GitUpdate.downloadErrorEventHandler, "..errorFound)
      GitUpdate.downloadError = true --notify InstallGitUpdates not to proceed.
    else --for any other download errors.
      debugToDisplay("fuction GitUpdate.downloadErrorEventHandler, "..errorFound)
    end --if trackedDownloads.urlList:match(erroredURL)
  elseif event == "sysInstallPackage" then --after a package has installed.
    local localInstalledPackageName = arg[1] --notify 
    local localInstalledPackageFileName = arg[2]
    debugToDisplay("function GitUpdateEventHandler: "..localInstalledPackageName.." package installed from file: "
      ..localInstalledPackageFileName)
  elseif event == "sysUninstallPackage" then --after a package has installed.
    local tecUninstalledPackage = arg[1]
    debugToDisplay("function GitUpdateEventHandler: "..tecUninstalledPackage.." package uninstalled.")
  end --if event name
end --function tecUpdate.eventHandler()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>parthia talk</name>
					<packageName></packageName>
					<script>--functions to manage the tts system.</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetVoice(voiceName, displayToScreen)</name>
						<packageName></packageName>
						<script>--set the voice the player wants to use.
function parthiaTalkSetVoice(voiceName, displayToScreen)
  
  displayToScreen = fuzzyBoolean(displayToScreen) --verify boolean is good.  
  --make certain variable passed is a string or a number.
  if not type(voiceName) == "string" or not type(voiceName) == "number" then
    tecErrorNotification("function parthiaTalkSetVoice, sent a non string variable for name.")
  end --if not type(voiceName) == "string"

  local ttsVoicesSupported = ttsGetVoices() --get list of voice types the player's system supports.
  local voiceNameCorrect = false --used to check if name sent matches one supported by the players computer.
  
  --check if voiceName is a supproted voice or index for ttsVoicesSupported table
  for integer, ttsName in ipairs(ttsVoicesSupported) do --loop through supported ttsnames table
    if type(voiceName) == "string" then --if voice name is a string
      if voiceName == ttsName then --if the voiceName sent matches a name supported by this system
        ttsSetVoiceByName(voiceName) --set the voice to voiceName
        voiceNameCorrect = true --the name was correct
        tecSettings.parthiaTalkVoice = ttsName --set voice name for startup
        if displayToScreen then
          pecho("Parthia talk voice set to "..ttsName..".\n")
          dontForgetToSave() --remind player to save
        end --if displayToScreen
      end --if voiceName == ttsName then
    elseif type(voiceName) == "number" then --if voice name is a number
      if voiceName == integer then --argument number passed is smaller or same size as ttsVoicesSupported table
        ttsSetVoiceByIndex(voiceName) --set the voice to index voiceName
        voiceNameCorrect = true --the name was correct
        tecSettings.parthiaTalkVoice = ttsName --set voice name for startup
        if displayToScreen then --if player ran command remind them to save
          pecho("Parthia talk voice set to "..ttsName..".\n")
          dontForgetToSave() --remind player to save
        end --if displayToScreen
      end --if voiceName == integer then
    end --if type(voiceName) == "string"
  end --of ipairs(ttsVoicesSupported)
  
  if not voiceNameCorrect then --if voiceName was incorrect show player correct usage
    if displayToScreen then --if player ran command send messages to screen
      pecho("Supported voice commands are ")
      for index, ttsName in ipairs(ttsVoicesSupported) do --loop through supported ttsnames table
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice "..ttsName, --show clickable command
          [[ parthiaTalkSetVoice("]]..ttsName..[[", true)]],
          "Set parthia talk name to "..ttsName, true)
        pecho("parthia talk voice "..ttsName, true) --speak message only if parthia talk is enabled
        pecho(" whose numbered version is ")
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice "..tostring(index), 
        [[ parthiaTalkSetVoice("]]..ttsName..[[", true)]],
        "Set parthia talk name to "..ttsName, true)
        pecho("parthia talk voice "..index, true) --speak message only if parthia talk is enabled
        pecho(". ")
      end --of ipairs(ttsVoicesSupported)
      pecho("\n")
    else
      tecWarningNotfication("function parthiaTalkSetVoice, autmated call sent incorrect name or number. "
        .." function sent "..tostring(voiceName))
    end --if displayToScreen
  end --if not voiceNameCorrect then

end --function parthiaTalkSetVoice(name)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetVoice()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetVoice()
  return tecSettings.parthiaTalkVoice
end --function parthiaTalkGetVoice()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetThoughts()</name>
						<packageName></packageName>
						<script>--get the enabled or disabled state of ParthiaTalkThoughts
function parthiaTalkGetThoughts()
  return tecSettings.parthiaTalkThoughts
end --function function parthiaTalkGetThoughts</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetThoughts(displayToScreen, mode)</name>
						<packageName></packageName>
						<script>--set if thoughts speak even if parthia talk is disabled
--mode is optional, normally it will toggle
function parthiaTalkSetThoughts(displayToScreen, mode)

  displayToScreen = fuzzyBoolean(displayToScreen) --should messages be displayed to player
  mode = fuzzyBoolean(mode) --set mode if it is not being toggled

  if mode == nil then --if mode was not passed at all
    if parthiaTalkGetThoughts() then --if parthia talk thoughts only is enabled
      tecSettings.parthiaTalkThoughts = false --switch parthia talk thoughts to off
      if displayToScreen then pecho("Parthia talk thoughts disabled\n") end
    else --if parthia talk thoughts is not enabled
      tecSettings.parthiaTalkThoughts = true --switch parthia talk thoughts to on
      if displayToScreen then pecho("Parthia talk thoughts enabled\n") end
    end --if parthiaTalkGetThoughts()
  else --if mode was passed
    tecSettings.parthiaTalkThoughts = mode --set variable to the mode passed
    if displayToScreen then pecho("Parthia talk thoughts set to "..tostring(mode).."\n") end
  end --if mode == nil
  
  if displayToScreen then dontForgetToSave() end --if player ran command remind them to save

end --parthiaTalkSetThoughts(displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetSpeech()</name>
						<packageName></packageName>
						<script>--get the enabled or disabled state of parthia talk speech
function parthiaTalkGetSpeech()
  return tecSettings.parthiaTalkSpeech
end --function function parthiaTalkGetSpeech</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetSpeech(displayToScreen, mode)</name>
						<packageName></packageName>
						<script>--set if game speech speaks even if parthia talk is disabled
--mode is optional, normally it will toggle
function parthiaTalkSetSpeech(displayToScreen, mode)

  displayToScreen = fuzzyBoolean(displayToScreen) --should messages be displayed to player
  mode = fuzzyBoolean(mode) --set mode if it is not being toggled

  if mode == nil then --if mode was not passed at all
    if parthiaTalkGetSpeech() then --if parthia talk speech is enabled
      tecSettings.parthiaTalkSpeech = false --switch parthia talk speech to off
      if displayToScreen then pecho("Parthia talk speech disabled.\n") end
    else --if parthia talk speech is not enabled
      tecSettings.parthiaTalkSpeech = true --switch parthia talk speech to on
      if displayToScreen then pecho("Parthia talk speech enabled.\n") end
    end --if parthiaTalkGetSpeech()
  else --if mode was passed
    tecSettings.parthiaTalkSpeech = mode --set variable to the mode passed
    if displayToScreen then pecho("Parthia talk speech set to "..tostring(mode)..".\n") end
  end --if mode == nil
  
  if displayToScreen then dontForgetToSave() end --if player ran command remind them to save

end --parthiaTalkSetSpeech(displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetSpeed(speed, displayToScreen)</name>
						<packageName></packageName>
						<script>--set speed parthia talks speaks at
function parthiaTalkSetSpeed(speed, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  speed = tonumber(speed) --convert speed to number incase it is a string
  if not speed then speed = 12 end --if speed was not a number, set it out of supported range to display supported commands
  
  if displayToScreen then --player called funtion, send messages to screen
    if speed &gt; 11 or speed &lt; 1 then --speed is out of supported range
      pecho("Supported parthia talk speed commands are\n")
      for i=1,11 do --loop from 1 to 11
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speed "..i, --display clickable link to screen
          [[ parthitaTalkSetSpeed("]]..i..[[", true)]],
          "Set parthia talk speech rate to "..i, true)
        pecho(", set the speed parthia talk speeks at to "..tostring(i)..".")
        if i &lt; 3 then --show player lower numbers mean slower, higher means faster.
          pecho(" very slow\n")
        elseif i &gt; 2 and i &lt; 6 then 
          pecho(" slow\n")
        elseif i == 6 then
          pecho("&lt;green&gt; Default\n")
        elseif i &gt; 6 and i &lt; 10 then
          pecho(" fast\n")
        elseif i &gt; 9 and i &lt; 12 then
          pecho(" very fast\n")
        else 
          cecho("\n") 
        end --if i &lt; 3
      end --for i=1,10
      pecho("Click a command above or type it into the command line.\n")
      return --exit function
    end --if speed &gt; 11 or speed &lt; 1
  end --if displayToScreen
  
  --mudlets supported speech rates range is -1 to 1
  local speechRate = (speed - 6) * .2 
  debugToDisplay("function parthitaTalkSetSpeed, speech rate is "..tostring(speechRate))
  --pecho("Setting speech rate to "..tostring(speechRate).."\n")
  ttsSetRate(speechRate)
  tecSettings.parthiaTalkSpeed = speed --store speed setting for startup
  if displayToScreen then
    pecho("Parthia talk speed set to "..tostring(speed)..".\n")
    dontForgetToSave()
  end --if displayToScreen
end --parthitaTalkSetSpeed(speed)
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetSpeed()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetSpeed()
  return tecSettings.parthiaTalkSpeed
end --function parthiaTalkGetSpeed()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetPitch(pitch, displayToScreen)</name>
						<packageName></packageName>
						<script>--set Pitch parthia talks speaks in
function parthiaTalkSetPitch(pitch, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --will messages be displayed
  pitch = tonumber(pitch) --convert pitch to number incase it is a string
  if not pitch then pitch = 12 end --if pitch was not a number, set it out of supported range to display supported commands
  
  
  if displayToScreen then 
    if pitch &gt; 11 or pitch &lt; 1 then --if pitch is out of supported range
      pecho("Supported parthia talk pitch commands are\n")
      for i=1,11 do --loop from 1 to 11
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pitch "..i, 
          [[ parthitaTalkSetPitch("]]..i..[[", true)]],
          "Set the pitch parthia talk speaks in to "..i, true)
        pecho(", set the speed parthia talk speeks at to "..tostring(i)..".")
        if i &lt; 3 then
          pecho(" very deep\n")
        elseif i &gt; 2 and i &lt; 6 then 
          pecho(" deep\n")
        elseif i == 6 then
          pecho("&lt;green&gt; Default\n")
        elseif i &gt; 6 and i &lt; 10 then
          pecho(" high\n")
        elseif i &gt; 9 and i &lt; 12 then
          pecho(" very high\n")
        else 
          cecho("\n")
        end --if i &lt; 3
      end --for i=1,10
      pecho("Click a command above or type it into the command line.\n")
      return --exit function
    end --if speed &gt; 11 or speed &lt; 1
  end --if displayToScreen
  
  --mudlets supported pitch range is -1 to 1
  local pitchLevel = (pitch - 6) * .2 
  debugToDisplay("function parthitaTalkSetSpeed, pitch level is "..tostring(pitchLevel)
    .." function was sent pitch number "..tostring(pitch))
  ttsSetPitch(pitchLevel) --set the pitch level
  tecSettings.parthiaTalkPitch = pitch --store pitch setting for startup
  if displayToScreen then
    pecho("Parthia talk pitch set to "..tostring(pitch)..".\n")
    dontForgetToSave() --remind player to save
  end --if displayToScreen
end --parthitaTalkSetSpeed(speed)
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetPitch()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetPitch()
  return tecSettings.parthiaTalkPitch
end --function parthiaTalkGetPitch()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--[[
Scripts for working with filtering the approach check command 
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>getTECRoomCheckActive()</name>
					<packageName></packageName>
					<script>function getTECRoomCheckActive()
	return tecRoomObjects.checkActive
end --end function getRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)</name>
					<packageName></packageName>
					<script>function setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --verify good boolean sent
  tecRoomCheckActive = fuzzyBoolean(tecRoomCheckActive) --verify good boolean sent
	tecRoomObjects.checkActive = tecRoomCheckActive --tell triggers to expect a room check
  tecRoomObjects.displayToScreen = displayToScreen --will ac . display to main?
end --end function setRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="no" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--Moved to variables Data Themese - Variables script</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>runTECRoomObjectCheck(displayToScreen)</name>
					<packageName></packageName>
					<script>--used for functions that track objects in the current room.
function runTECRoomObjectCheck(displayToScreen)

  displayToScreen = displayToScreen or false --if not declared default is false

	clearTECRoomObjects() --clear room data before running check

	clearRoomCharacterWindow() --clear all roomCharacter windows
	
	setTECRoomCheckActive(true,displayToScreen)--set a room check to true.

  send("ac .", false) --send an ac . command to list characters in the room.

end --function runRoomCharacterCheck()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>echoLeftRoomCharacterWindows(message)</name>
					<packageName></packageName>
					<script>--display text to left side of all Room Character Windows
function echoLeftRoomCharacterWindows(message)
  if type(message) ~= "string" then --if the type is incorrect
    tecErrorNotification("function echoLeftRoomCharacterWindows, sent a none string variable.")
  end --if type(message) ~= "string"
  --display messages to side of the screen
  debugToDisplay("function echoLeftRoomCharacterWindows, message: "..message)
  hecho(roomCharacters.console.name,message) --send message or standard room character window
  hecho(MultiWindow.roomCharacters.console.name,message) --send message to room character multi window
end --function echoLeftRoomCharacterWindows()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>echoRightRoomCharacterWindows(message)</name>
					<packageName></packageName>
					<script>function echoRightRoomCharacterWindows(message)
  if type(message) ~= "string" then --if the type is incorrect
    tecErrorNotification("function echoRightRoomCharacterWindows, sent a none string variable.")
  end --if type(message) ~= "string"
  --display messages to side of the screen
  debugToDisplay("function echoRightRoomCharacterWindows, message: "..message)
  hecho(roomCharacters.rightConsole.name,message) --send message or standard room character window
  hecho(MultiWindow.roomCharacters.rightConsole.name,message) --send message to room character multi window
end --function echoLeftRoomCharacterWindows()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearRoomCharacterWindow()</name>
					<packageName></packageName>
					<script>function clearRoomCharacterWindow()
	clearWindow(roomCharacters.console.name) --clear left side standard room characters window
  clearWindow(MultiWindow.roomCharacters.console.name) --clear left side of the MultiWindow room characters console
  clearWindow(MultiWindow.roomCharacters.rightConsole.name) --clear right side of standard room character window
  clearWindow(roomCharacters.rightConsole.name) --clear the right side of the multi window room characters console
  tecRoomObjects.refreshMessageDisplayed = false --tell Parthia refresh message has not been shown
end --clearRoomCharacterWindow</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRoomCharRefreshNotification()</name>
					<packageName></packageName>
					<script>--Show notification to the player than something has changed and a room check is needed
local function tecRoomCharRefreshMessage()
  --displaying to right panel, because it will have very little text in it
  echoRightRoomCharacterWindows("Refresh Recommended ")
    cechoLink(roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cechoLink(MultiWindow.roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  echoRightRoomCharacterWindows(" or press ctrl+r.\n")
end --function tecRoomCharRefreshMessage()

function tecRoomCharRefreshNotification()

  if not tecRoomObjects.refreshMessageDisplayed then
    tecRoomCharRefreshMessage()
    tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
  end --if tecRefreshNotification is needed
  
end --function recRoomCharRefreshNotification()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecResetRoomCharacterWindow()</name>
					<packageName></packageName>
					<script>--clear out the room character windows and tell player how to refresh
function tecResetRoomCharacterWindow()
  clearRoomCharacterWindow() --Room characters window no longer accurate, clear it.
  echoLeftRoomCharacterWindows("Populate this space with characters in this room by:")
  echoRightRoomCharacterWindows("running command ")
  cechoLink(roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cechoLink(MultiWindow.roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  echoRightRoomCharacterWindows(" or pressing ctrl+r.\n")
  tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
end --function tecResetRoomCharacterWindow</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Game commands</name>
				<packageName></packageName>
				<script>--[[
Commands used to interact with the game itself.

IE: `wait for drover`
]]--</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>wait for drover</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaSetWaitForDrover(waiting)</name>
						<packageName></packageName>
						<script>function parthiaSetWaitForDrover(waiting)
  waiting = fuzzyBoolean(waiting) --make certain it is a good variable
  parthiaWaitingForDrover = waiting
end --function parthiaSetWaitForDrover(waiting)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaGetWaitForDrover()</name>
						<packageName></packageName>
						<script>function parthiaGetWaitForDrover()
  return parthiaWaitingForDrover 
end --function parthiaGetWaitForDrover()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>numpad navigation</name>
				<packageName></packageName>
				<script>--enable or disable numpad naviation</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setNumpadNavigation(mode)</name>
					<packageName></packageName>
					<script>--enable or disable numberpad navigation support
function setNumpadNavigation(mode)
  mode = fuzzyBoolean(mode) --made certain variable sent is good.
  numNaviationkeyName = "numpad navigation" --name of the navitation group the navigation keys are in
  
  if mode then --if true enable numpadgroup
    enableKey(numNaviationkeyName)
  else --if false disable
    disableKey(numNaviationkeyName)
  end --if mode then
  
  --save to file if player wants numpad navigation enabled.
  tecSettings.numpadNavigationEnabled = mode
  
end --function setNumNaviation(mode)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getNumpadNaviation()</name>
					<packageName></packageName>
					<script>--returns the enabled or disabled state of numpad navigation
function getNumpadNaviation()
  return tecSettings.numpadNavigationEnabled
end --function getNumpadNaviation()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Windows</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>status bar</name>
				<packageName></packageName>
				<script>status_bar = Geyser.Container:new({
  name = "Status",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
--GUIframe.addWindow(status_bar,"status_bar","bottom")

--set location for container in GUIframe.
status_bar.GUIframeLocation = "bottom"
--add cobntainer to UI manager.
UIManagerRegisterWindow(status_bar)</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Health Bar</name>
					<packageName></packageName>
					<script>hpbar = Geyser.Gauge:new({
  name="hpbar",
  x=0, y=0,
  width="50%", height="50%",
},status_bar)

hpbar.frontStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ffdcdc, stop: 0.1 #ff8c8c, stop: 0.49 #ff4c4c, stop: 0.5 #ff4c4c, stop: 1 #ff6666);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]
hpbar.front:setStyleSheet(hpbar.frontStyleSheet) --set the forground gradiant

hpbar.backStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ff6666, stop: 0.1 #F05050, stop: 0.49 #E03030, stop: 0.5 #E03030, stop: 1 #E03030);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]]                                             
hpbar.back:setStyleSheet(hpbar.backStyleSheet) --set the background gradiant

hpbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Health&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Fatigue Bar</name>
					<packageName></packageName>
					<script>fatiguebar = Geyser.Gauge:new({
  name="fatiguebar",
  x=0, y="50%",
  width="50%", height="50%",
},status_bar)

fatiguebar.frontStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0fff0, stop: 0.1 #f0ffca, stop: 0.49 #f0d09a, stop: 0.5 #f0d09a, stop: 1 #f0d09a);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]
fatiguebar.front:setStyleSheet(fatiguebar.frontStyleSheet)

fatiguebar.backStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0d09a, stop: 0.1 #e0c08a, stop: 0.49 #d0b07a, stop: 0.5 #d0b07a, stop: 1 #d0b07a);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]]
fatiguebar.back:setStyleSheet(fatiguebar.backStyleSheet)

fatiguebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Fatigue&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Hunger Bar</name>
					<packageName></packageName>
					<script>hungerbar = Geyser.Gauge:new({
  name="hungerbar",
  x="50%", y=0,
  width="50%", height="50%",
},status_bar)
hungerbar.frontStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FEe0, stop: 0.1 #E6FDe0, stop: 0.49 #A0E070, stop: 0.5 #A0E070, stop: 1 #A0E070);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]
hungerbar.front:setStyleSheet(hungerbar.frontStyleSheet)
hungerbar.backStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #A0E070, stop: 0.1 #99d869, stop: 0.49 #60c830, stop: 0.5 #60c830, stop: 1 #60c830);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]]
hungerbar.back:setStyleSheet(hungerbar.backStyleSheet)
hungerbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Hunger&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Encumbrance Bar</name>
					<packageName></packageName>
					<script>encumbrancebar = Geyser.Gauge:new({
  name="encumbrancebar",
  x="50%", y="50%",
  width="50%", height="50%",
},status_bar)
encumbrancebar.frontStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FBFE, stop: 0.1 #E6F8FD, stop: 0.49 #AFDDED, stop: 0.5 #AFDDED, stop: 1 #AFDDED);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]
encumbrancebar.front:setStyleSheet(encumbrancebar.frontStyleSheet)
encumbrancebar.backStyleSheet = [[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #AFDDED, stop: 0.1 #A7D7E9, stop: 0.49 #80AEC7, stop: 0.5 #80AEC7, stop: 1 #80AEC7);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]]
encumbrancebar.back:setStyleSheet(encumbrancebar.backStyleSheet)
encumbrancebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Encumbrance&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>compasbar</name>
				<packageName></packageName>
				<script>--Reference https://wiki.mudlet.org/w/Manual:Geyser#Create_a_Clickable_Compass

--create compass object
--dirs directory
tecCompass = tecCompass or {
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"},
} --end tecCompass object declaration

--main container for tecCompass
tecCompass.window = Geyser.Container:new({
  name = "Compass",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--back label for tecCompass
tecCompass.back = Geyser.Label:new({
  name = "tecCompass.back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecCompass.window) --The parent of this label. Main is main window.

--set background image for compass
tecCompass.back:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/background.svg");]])
    
tecCompass.overlay = Geyser.Label:new({
  name = "tecCompass.overlay",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },tecCompass.back) --put the label into the Compass container
tecCompass.overlay:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/CompassOverlay.svg");]]) --set the background label

--Horizontal box
tecCompass.hbox = Geyser.HBox:new({
    name = "tecCompass.box",
    x = 0, --horizonal position in parent
    y = 0, --vertical position in parent
    width = "100%", --How wide box is, % of parent
    height = "100%", --How tall box is, % of parent
  },tecCompass.back) --parent of this Hbox

--create 3 vertical rows
--in parent object compas.box
tecCompass.row1 = Geyser.VBox:new({name = "tecCompass.row1",},tecCompass.hbox)
tecCompass.row2 = Geyser.VBox:new({name = "tecCompass.row2",},tecCompass.hbox)
tecCompass.row3 = Geyser.VBox:new({name = "tecCompass.row3",},tecCompass.hbox)

--create labels to hold compas images
--Each parent is the row that were 
--created with VBox above.
--row1 left row2 center row3 right
tecCompass.nw = Geyser.Label:new({
  name = "tecCompass.nw",
},tecCompass.row1)

tecCompass.w = Geyser.Label:new({
  name = "tecCompass.w",
},tecCompass.row1)

tecCompass.sw = Geyser.Label:new({
  name = "tecCompass.sw",
},tecCompass.row1)

tecCompass.n = Geyser.Label:new({
  name = "tecCompass.n",
},tecCompass.row2)
        
tecCompass.center = Geyser.VBox:new({
  name = "tecCompass.center",
},tecCompass.row2)

tecCompass.up = Geyser.Label:new({
  name = "tecCompass.up",
},tecCompass.center)

tecCompass.down = Geyser.Label:new({
  name = "tecCompass.down",
},tecCompass.center)

tecCompass.s = Geyser.Label:new({
  name = "tecCompass.s",
},tecCompass.row2)

tecCompass.ne = Geyser.Label:new({
  name = "tecCompass.ne",
},tecCompass.row3)
    
tecCompass.e = Geyser.Label:new({
  name = "tecCompass.e",
},tecCompass.row3)
  
tecCompass.se = Geyser.Label:new({
  name = "tecCompass.se",
},tecCompass.row3)
--end of compas labels

--when a label is clicked we want to
--go in that direction
function tecCompass.click(name)
  send(name)
end

--Function that will put images to direction labels. name will be n nw so on in tecCompass under triggers
function tecCompass.lit(name)
  tecCompass[name]:setStyleSheet([[background-color: "#5577dd77";]])
end
--when the space should be unlit change it back to white.
function tecCompass.unlit(name)
  tecCompass[name]:setStyleSheet([[
    background-color: "#00000000";
  ]])
end

--Each of the 9 labels need an image of an arrow.
--Rather than setting each individually, we'll
--iterate over the tecCompass.dirs table we made 
--awhile back and add the respective image to each.
--The names of images are a reflection of the tecCompass.dirs 
--table. This keeps it consistent and easy to refer to.
--During the iteration, the callback, setLabelOnEnter and
--setLabelOnLeave are also set for each label.

--loop through dirs in table tecCompass
for _,v in pairs(tecCompass.dirs) do
  tecCompass[v]:setStyleSheet([[
    background-color: "#000000FF";
  ]]) --apply pictures to directions on compass
  
  SetTooltip(tecCompass[v].name, "Go "..v.." ") --create hover tooltip for direction
  
	--if tecCompass is clicked, go in that direction
	tecCompass[v]:setClickCallback("tecCompass.click",v)  
end --end loop through tecCompass.dirs

--keeps the tecCompass square as the windows are adjusted.
function tecCompass.drawKeepSquare()

  --tecCompass.window:move(0,2) --small black break at top.

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_width() &lt; tecCompass.window:get_height() then
  	tecCompass.back:resize(tecCompass.window:get_width(), tecCompass.window:get_width())
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_height() &lt; tecCompass.window:get_width() then
  	tecCompass.back:resize(tecCompass.window:get_height(), tecCompass.window.height)
	end --end if height is less than width
  
  if tecCompass.back:get_width() &lt; tecCompass.window:get_width() then
    tecCompass.back:move((tecCompass.window:get_width() - tecCompass.back:get_width()) * .5)
  end
	
end --end function keep square.

--Add the status bar to the screen. On the bottom
--GUIframe.addWindow(tecCompass.window,"Compass","topleft")

--set location for container in GUIframe.
tecCompass.window.GUIframeLocation = "topleft"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecCompass.window)

--Now that we created the window. Make certain it is drawn correctly.
--tecCompass.drawKeepSquare() --function at the bottom of this script.</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Settings bar</name>
				<packageName></packageName>
				<script>tecSettingsBar = Geyser.Container:new({
  name = "Settings",    -- give it a unique name here
  x=0, y=0,                   
  width = 0, height=0, 
})

--box that will store the miniconsoles
tecSettingsBack = Geyser.Label:new({
  name = "tecSettingsBack",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},tecSettingsBar)

tecSettingsBack:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
tecSettingsConsole = Geyser.MiniConsole:new({
  name = "tecSettingsConsole",
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},tecSettingsBack)
tecSettingsConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
tecSettingsConsole:raise()

function tecSettingsWindowResize()
	
	--Resize the back label by 6. We want a 3px border around the entire window
	tecSettingsBack:resize(tostring(tecSettingsBar:get_width() - 0)
		, tostring(tecSettingsBar:get_height() - 0))
	tecSettingsBack:move (0, 0) --left and top borders
	
	--Resize the room character window by 6. We want a 3px border around the entire window
	tecSettingsConsole:resize(tostring(tecSettingsBack:get_width() - 0)
		, tostring(tecSettingsBack:get_height() - 0))
	tecSettingsConsole:move (0, 0) --left and top borders
  
  tecScrollBarCheck("tecSettingsConsole") --Checks if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." tecSettingsBack width: "..tecSettingsBack:get_width()
			.." tecSettingsBack Height: "..tecSettingsBack:get_height()
			.." tecSettingsConsole Width: "..tecSettingsConsole:get_width()
			.." tecSettingsConsole Height: "..tecSettingsConsole:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecSettingsWindowResize()

--set location for container in GUIframe.
tecSettingsBar.GUIframeLocation = "bottomleft"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecSettingsBar)

--tecRefreshSettingsWindow() --Refreshes text in settings window.
--tecSettingsWindowResize() --resize the Room Character window now</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tec map</name>
				<packageName></packageName>
				<script>--creates tec's 2d getAllMapUserData
--future ideas. create a zoom scroll with --tecMap_back:addScrollbars(tecMap, "RV")
--will probably need to complete that function for mudlet...

--Don't forget. Creating room and exit labels ahead of time reduces the time it takes to draw
--rooms while the user is playing. Do not create a system where we create labels as they play.

tecMap = Geyser.Container:new({
  name = "TEC Map",    -- give it a unique name here
  x=0, y=0,                   
  width = 0, height=0, 
  GUIframeLocation = "bottomright",
})

--Creating the background for the 2d tec map.
tecMap_back = Geyser.Label:new({
  name = "tecMap_back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecMap) --The parent of this label.

--set the appearance of what is behind the map
tecMap_back:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/map/background.svg");]])

--rgba(25, 50, 150)

mapRoom = {} --Table to hold labels we will draw the rooms with
mapExit = {} --Table to hold labels we will draw the exits with.
--Creating empty rooms for our map system.
for i = 1, 150 do
	--Create empty room and exit labels. Hide them so no junk is on screen.
  mapRoom[i] = Geyser.Label:new({name = "mapRoom"..tostring(i),},tecMap_back) 
  mapExit[i] = Geyser.Label:new({name = "mapExit"..tostring(i),},tecMap_back) 
  mapRoom[i]:hide() --Hide the tab so they don't layer
	mapExit[i]:hide() --Hide the tab so they don't layer
end --end loop create tabs and consoles

function tecMapdrawKeepSquare()

  tecMap:move(0,0) --move the map down so there is a border on the top.
  --tecMap:resize(tecMap:get_width(), (tecMap:get_height() - 2))

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height the equal.
	if tecMap:get_width() &lt; tecMap:get_height() then
  	tecMap_back:resize(tecMap:get_width(), tecMap:get_width())
    --local centerAdjustment = ((tecMap:get_height() - tecMap_back:get_width()) * .5)
    tecMap_back:move(0,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecMap:get_height() &lt; tecMap:get_width() then
  	tecMap_back:resize(tecMap:get_height(), tecMap:get_height())
    local centerAdjustment = ((tecMap:get_width() - tecMap_back:get_height()) * .5)
    tecMap_back:move(centerAdjustment,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
	echo(mapRoom[150].name,"Map exits may be misaligned until you walk.")
  mapRoom[150]:resize(tecMap_back:get_width(), (tecMap:get_height() * .1))
  mapRoom[150]:setStyleSheet(labelsStyle)
  mapRoom[150]:move(0,0)
  mapRoom[150]:show()
  mapRoom[150]:raise()
	
end --end function keep square.

--set location for container in GUIframe.
--tecMap.GUIframeLocation = "bottomright"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecMap)

--tecMapdrawKeepSquare() --call it to size the map properly</script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>3d map</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--Creates an interactive list of PC and NPCs in players current room.

roomCharacters = Geyser.Container:new({
  name = "Room Characters",    -- give it a unique name here
  x=0, y=0,                   
  width = 0, height=0, 
})

--box that will store the miniconsoles
roomCharacters.back = Geyser.HBox:new({
  name = "roomCharacters.back",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},roomCharacters)

--This are the miniconsoles that will hold the text
roomCharacters.console = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.console", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.console:raise()

--This are the miniconsoles that will hold the text
roomCharacters.rightConsole = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.rightConsole", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.rightConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.rightConsole:raise()

function tecCRWindowResize()
	
	--Resize the back label by keeping it square.
	roomCharacters.back:resize(tostring(roomCharacters:get_width())
		, tostring(roomCharacters:get_height()))
	roomCharacters.back:move (0, 0) --left and top borders
	
	--Resize the back label by keeping it square.
	roomCharacters.console:resize(tostring(roomCharacters.back:get_width() - 0)
		, tostring(roomCharacters.back:get_height() - 0))
	roomCharacters.console:move (0, 0) --left and top borders
  tecScrollBarCheck("roomCharacters.console") --check if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." roomCharacters.back width: "..roomCharacters.back:get_width()
			.." roomCharacters.back Height: "..roomCharacters.back:get_height()
			.." roomCharacters.console Width: "..roomCharacters.console:get_width()
			.." roomCharacters.console Height: "..roomCharacters.console:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecCRWindowResize()

--set location for container in GUIframe.
roomCharacters.GUIframeLocation = "topright"
--add cobntainer to UI manager.
UIManagerRegisterWindow(roomCharacters)

--tecCRWindowResize() --resize the Room Character window now
--tecResetRoomCharacterWindow() --fill room characters window with text</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Communications Menu</name>
				<packageName></packageName>
				<script>--Communications windows at the top of the screen.

--ideas for future
--When click a tab is stays dark to show that is the active tab.
--fix the minor resizing issue with the back label not having a right margin.
--take tabs out of that damn tecComWindows table
--create the option for a combat bar. Only shows combat text...

--Origional menu from the tabs tutorial.
--Only kept it because using a lone table caused issues.
--Feelfree to take the tabs table out of the menu table.
--For me it is a logic not I just didn't feel like unting.
--menu has to be global.
tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
tecComWindows.current = tecComWindows.current or tecComWindows.tabs[1]

--A container for everything to be in.
--No size or position because that is handled in UI manager
tecComWindows.container = Geyser.Container:new({
  name = "Communications",
})

--box that will hold the tabs
tecComWindows.header = Geyser.HBox:new({
  name = "tecComWindows.header",
  x = 0, --horizontal
	y = 0, --vertical position 
  width = "100%",
  height = tabsHeight, --for now using % rather than pixel math
},tecComWindows.container)

--box that will store the miniconsoles
tecComWindows.footer = Geyser.Label:new({
  name = "tecComWindows.footer",
  x = 0, --horizontal position
	y = tabsHeight, --adjusted for tabs
  width = "100%",
	height = tecSettings.comTextWindowHeight
},tecComWindows.container)
tecComWindows.footer:setStyleSheet(labelsStyle) --set to default label style

--Create the tabs
for k,v in pairs(tecComWindows.tabs) do
  tecComWindows[v.."tab"] = Geyser.Label:new({
    name = "tecComWindows."..v.."tab",
		x = 0, --horizontal position 
		y = 0, --vertical position
		width = "100%",
		height = tabsHeight,
  },tecComWindows.header)
	
  tecComWindows[v.."tab"]:setStyleSheet(tabsStyle) --set style in themes
	
	tecComWindows[v.."tab"]:echo(tabsFontStyle..v) --lable the tabs, set style in themes

	tecComWindows[v.."tab"]:setClickCallback("tecComWindows.click",v) --for charing tabs

	--These are the miniconsoles that will hold the text
  tecComWindows[v] = Geyser.MiniConsole:new({ --tecComWindows v will be a tab name.
    name = v, --Issues experienced if I attempt to name them v.."Console"
  	x = 0, --%horizontally position in parent
  	y = 0, --%vertical position in parent
  	width = "100%", --% of parent
  	height = tecSettings.comTextWindowHeight - 1, 
		autoWrap = true, --allows text to wrap if too long
		fontSize = getTECFont(), --in variables
		font = getFont(), --get font type from main
  },tecComWindows.footer) --attach to footer show they show below tabs
	tecComWindows[v]:setColor(getBgColor()) --set miniconsoles to main consol BG color 
  tecComWindows[v]:hide() --Hide the tab so they don't layer
  if tecSettings.showScrollBars then tecComWindows[v]:enableScrollBar() end
end --end loop create tabs and consoles

function tecComWindows.click(tab) --Choose what happens when a tab is clicked.
  tecComWindows[tecComWindows.current]:hide() --Hide the current tab
  tecComWindows.current = tab --Make the clicked tab the current one.
  tecComWindows[tecComWindows.current]:show() --Show the current tab.
end --end tecComWindows.click(tab) function

--A tecComWindows has to be selected otherwise on startup it will just show.
--The label behind the tecComWindows, becuase they are hidden directly after creation.
tecComWindows[tecComWindows.current]:show()

function tecComWindowResize()
  local tecResizedFooterHeight = 50
	local tecResizedFooterWidth = 300

  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then  
	 --subtract GUIframe.defaults.resizeHeight from tecComWindows.footer.height 
	 tecResizedFooterHeight = tecComWindows.container:get_height() - GUIframe.defaults.resizeHeight
	 tecResizedFooterWidth = tecComWindows.container:get_width()
  else --UI manager not specified.
	 tecResizedFooterHeight = tecComWindows.container:get_height()
	 tecResizedFooterWidth = tecComWindows.container:get_width()
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
  
	tecComWindows.footer:resize(tecResizedFooterWidth, tecResizedFooterHeight) --resize the footer
	tecComWindows.footer:move(0,(tabsHeight))
	
	--reflect changes in tecSettings so there is a chance to save the size.
	tecSettings.comTextWindowHeight = tecResizedFooterHeight
	
	--resize all of the miniconsoles
	for k,v in pairs(tecComWindows.tabs) do 
  	tecComWindows[v]:move(0, 0)
  	tecComWindows[v]:resize(tecResizedFooterWidth, tecResizedFooterHeight - 1)
	end --for tecComWindows.tabs
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Communication Window, tecComWindows.footer Height: "..tecComWindows.footer:get_height()
			.." tecComWindows.ctainer Height: "..tecComWindows.container:get_height()
			.." New tecComWindows.footer Height: "..tecResizedFooterHeight
			.." mini consoles width: "..(tecResizedFooterWidth - 0).."%"
			)--end debugToDisplay
	end --end if display debug is enabled.

end --resizeKeepTabsStatis

--tecComWindowResize() --resize com window

--set location for container in GUIframe.
tecComWindows.container.GUIframeLocation = "top"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecComWindows.container)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Macro Menu</name>
				<packageName></packageName>
				<script> --If no UI mananger is in use, do not draw the window.
--if GetUIManager() == "none" then return end

--[[
Tec uses a macro system that players can set within the game.
The command they use is @macro.
To avoid additional time for now we can piggy back of their system.
They support 15 gui buttons that can be macroed in the game.
All we need to do, is when the button is clicked it sends command fe#
so button 1 send("fe1")
After that TECs macro system will take over.
For formating you could set the grid style setup for labels in compasbar
In 5 rows of 3 columns.
Normally does 5 columns of 3 rows. Tec has a combat rotation that requires three unique moves 
in a row or if you are attacking a person you receive a major debuff.
The 5 is while training. You need to do 5 unique moves to get the most skill points.
I like the 3 columns because it gives us big chunky buttons that will work well with touch
screens.
]]--

--Create a global table or namespace
--Creating a global table will make each of our variables unique. Our namespace will be called
--macroMenu and everything we make from here on out will be stored within the macroMenu table.

macroMenu = macroMenu or {}

--Create the container
--Containers are windows that can contain other windows. Actually, since all other Geyser windows
--subclass container, every window can do that. But containers do not have any visible content by
--themselves. Our tabbed "Macros" window will need a container. This will be the bottom layer.
--Containers are invisible, so no need to set a stylesheet. At the end of the file, we will add this
--container as a "window".
macroMenu.container = Geyser.Container:new({
  name = "Macros",
})

--Create the parent label
--The 'parent label' refers to the label on the bottom layer. The entire macro menu will be created 
--within this label.
macroMenu.back = Geyser.Label:new({
  name = "macroMenu.back",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.container)
macroMenu.back:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/macro/background.svg");]])

--Create a 3x5 grid
--The macro menu is split into 15 sections, one for each macro. This 3x5 grid is created by 5 HBoxes
--that sit within a single VBox (or vice versa, it doesn't matter). So first off, we create the VBox.
--It will be the same size as its parent, macroMenu.back.

macroMenu.box = Geyser.VBox:new({
  name = "macroMenu.box",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.back)

--Next, we create our 5 HBoxes. We don't need to specify position or size because these are placed
--within macroMenu.box, a VBox.
macroMenu.row1 = Geyser.HBox:new({
  name = "macroMenu.row1",
}, macroMenu.box)
macroMenu.row2 = Geyser.HBox:new({
  name = "macroMenu.row2",
},macroMenu.box)
macroMenu.row3 = Geyser.HBox:new({
  name = "macroMenu.row3",
}, macroMenu.box)
macroMenu.row4 = Geyser.HBox:new({
  name = "macroMenu.row4",
}, macroMenu.box)
macroMenu.row5 = Geyser.HBox:new({
  name = "macroMenu.row5",
}, macroMenu.box)
macroMenu.row5:hide()

--Finally, we add our 15 labels. Take note that they are split up into five groups of three. Each group
--is placed into a different "macroMenu.row" number.
local tecMacroMappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = macroMenu.row1, --the geyser box we want this label to go in
  },
  {
    name = "fe2",
    label = "II",
    row = macroMenu.row1,
  },
  {
    name = "fe3",
    label = "III",
    row = macroMenu.row1,
  },
  {
    name = "fe4",
    label = "IV",
    row = macroMenu.row2,
  },
  {
    name = "fe5",
    label = "V",
    row = macroMenu.row2,
  },
  {
    name = "fe6",
    label = "VI",
    row = macroMenu.row2,
  },
  {
    name = "fe7",
    label = "VII",
    row = macroMenu.row3,
  },
  {
    name = "fe8",
    label = "VIII",
    row = macroMenu.row3,
  },
  {
    name = "fe9",
    label = "IX",
    row = macroMenu.row3,
  },
  {
    name = "fe10",
    label = "X",
    row = macroMenu.row4,
  },
  {
    name = "fe11",
    label = "XI",
    row = macroMenu.row4,
  },
  {
    name = "fe12",
    label = "XII",
    row = macroMenu.row4,
  },
  {
    name = "fe13",
    label = "XIII",
    row = macroMenu.row5,
  },
  {
    name = "fe14",
    label = "XIV",
    row = macroMenu.row5,
  },
  {
    name = "fe15",
    label = "XV",
    row = macroMenu.row5,
  },
}

--add onto standard label. We want a small margin for this label.								
--macroLabelStyle = labelsStyle.."margin: 1px\n"; 537dC0
macroLabelStyle = [[
  	QLabel{
  		background-color: "#55537dC0";
      border-bottom: 1px;
      border-right: 1px;
      border-style: outset;
      border-color: lightgray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: "#33436db0";
      border-bottom: 1px;
      border-right: 1px;
      border-style: outset;
      border-color: gray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]

for _, tecMacroMap in pairs(tecMacroMappings) do --loop trough mappings table using data within
  macroMenu[tecMacroMap.name] = Geyser.Label:new({
    name = "macroMenu." .. tecMacroMap.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. tecMacroMap.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, tecMacroMap.row) --parent is gettings passed via mapping table row reference
    local localMacroTooltip = "run macro "..tecMacroMap.name:match("(%d%d?)$").."  "
  SetTooltip(macroMenu[tecMacroMap.name].name, localMacroTooltip) --create hover tooltip
  macroMenu[tecMacroMap.name]:setClickCallback("onMacroClick", tecMacroMap.name)
  macroMenu[tecMacroMap.name]:setStyleSheet(macroLabelStyle) --create window layout
end

--Create a callback function
--When the user clicks a macro button, this function will send the button name to the server. For
--example, when the user clicks the first button, we will send "fe1" to the server.
function onMacroClick(name)
  send(name, false)
end

function tecMacroMenuResize()
  --macroMenu.back:move(0,0)
end --function tecMacroMenuResize

--set location for container in GUIframe.
macroMenu.container.GUIframeLocation = "bottomleft"
UIManagerRegisterWindow(macroMenu.container)
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>multiWindow</name>
				<packageName></packageName>
				<script>MultiWindow = multiWindow or {}

MultiWindow.back = Geyser.VBox:new({ name = "Multi Window", }) --Horizonal box to hold our multiwindows.
MultiWindow.back.GUIframeLocation = "topright" --set location for container in GUIframe.

--MultiWindow.top = Geyser.VBox:new({ name = "MultiWindow.top", }, MultiWindow.back) --Vertical window break for the room characters windows

--Create a window that is a copy of the Room Characters window.
MultiWindow.roomCharacters = MultiWindow.roomCharacters or {} --create a table to hold roomCharters window
MultiWindow.roomCharacters.back = Geyser.HBox:new({
  name = "MultiWindow Room Characters",
  }, MultiWindow.back)
--MultiWindow.roomCharacters.back:setStyleSheet(labelsStyle) --set label for background
MultiWindow.roomCharacters.console = Geyser.MiniConsole:new({ --Create the mini console that will hold the text.
  name = "MultiWindow.roomCharacters.console",
	x = 0, y = 0, width = "100%", height = "100%", --position and size of console
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},MultiWindow.roomCharacters.back)
MultiWindow.roomCharacters.console:raise()
MultiWindow.roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
MultiWindow.roomCharacters.rightConsole = Geyser.MiniConsole:new({ --Create the mini console that will hold the text.
  name = "MultiWindow.roomCharacters.rightConsole",
	x = 0, y = 0, width = "100%", height = "100%", --position and size of console
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},MultiWindow.roomCharacters.back)
MultiWindow.roomCharacters.rightConsole:raise()
MultiWindow.roomCharacters.rightConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color

--create the window that holds the macros.
MultiWindow.macroMenu = MultiWindow.macroMenu or {} --table to hold the windows variables
MultiWindow.macroMenu.container = Geyser.Container:new({ name = "MultiWindow.Macros", }, MultiWindow.back)
MultiWindow.macroMenu.back = Geyser.Label:new({ --Create a label that could be used as a background
  name = "MultiWindow.macroMenu.back",
  x = 0,y = 0, width = "100%", height = "100%" --Position and size of window
  }, MultiWindow.macroMenu.container) --end of MultiWindow.macroMenu.back
MultiWindow.macroMenu.back:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/macro/background.svg");]])
MultiWindow.macroMenu.box = Geyser.VBox:new({ --creates the verticle window breaks
  name = "MultiWindow.macroMenu.box",
  x = 0, y = 0, width = "100%", height = "100%"
  }, MultiWindow.macroMenu.back) --end MultiWindow.macroMenu.box
--Create the five rows of buttons
MultiWindow.macroMenu.row1 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row1",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row2 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row2",
  },MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row3 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row3",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row4 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row4",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row5 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row5",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row5:hide()
--create table to hold data for macro buttons.
local tecMacroMappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = MultiWindow.macroMenu.row1, --the geyser box we want this label to go in
  },
  { name = "fe2", label = "II", row = MultiWindow.macroMenu.row1, },
  { name = "fe3", label = "III", row = MultiWindow.macroMenu.row1, },
  { name = "fe4", label = "IV", row = MultiWindow.macroMenu.row2, },
  { name = "fe5", label = "V", row = MultiWindow.macroMenu.row2, },
  { name = "fe6", label = "VI", row = MultiWindow.macroMenu.row2, },
  { name = "fe7", label = "VII", row = MultiWindow.macroMenu.row3, },
  { name = "fe8", label = "VIII", row = MultiWindow.macroMenu.row3, },
  { name = "fe9", label = "IX", row = MultiWindow.macroMenu.row3, },
  { name = "fe10", label = "X", row = MultiWindow.macroMenu.row4, },
  { name = "fe11", label = "XI", row = MultiWindow.macroMenu.row4, },
  { name = "fe12", label = "XII", row = MultiWindow.macroMenu.row4, },
  { name = "fe13", label = "XIII", row = MultiWindow.macroMenu.row5, },
  { name = "fe14", label = "XIV", row = MultiWindow.macroMenu.row5, },
  { name = "fe15", label = "XV", row = MultiWindow.macroMenu.row5, },
} --tecMacroMappings table
--macroLabelStyle = labelsStyle --make a standard label for
for _, tecMacroMap in pairs(tecMacroMappings) do --loop trough mappings table using data within
  MultiWindow.macroMenu[tecMacroMap.name] = Geyser.Label:new({
    name = "MultiWindow.macroMenu." .. tecMacroMap.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. tecMacroMap.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, tecMacroMap.row) --parent is gettings passed via mapping table row reference
  local localMacroTooltip = "run macro "..tecMacroMap.name:match("(%d%d?)$").."  "
  SetTooltip(MultiWindow.macroMenu[tecMacroMap.name].name, localMacroTooltip) --create hover tooltip
  MultiWindow.macroMenu[tecMacroMap.name]:setClickCallback("onMacroClick", tecMacroMap.name)
  MultiWindow.macroMenu[tecMacroMap.name]:setStyleSheet(macroLabelStyle)
end --for pairs(tecMacroMappings)
function onMacroClick(name) send(name, false) end --Create a click callback function

--used to hold compass and the status bars aside eachother at the bottom of the multiwindow
--MultiWindow.bottom = Geyser.HBox:new({ name = "MultiWindow.Bottom", }, MultiWindow.back) --Vertical window break for the bottom of the window
MultiWindow.bottom = Geyser.Container:new({ name = "MultiWindow.Bottom", }, MultiWindow.back) --Vertical window break for the bottom of the window

--Create the compass in the MultiWindow
MultiWindow.Compass = MultiWindow.Compass or { --table to hold compass
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"}, --directions for the compass
  } --end MultiWindow.Compass object declaration
MultiWindow.Compass.window = Geyser.Container:new({ --container for compass
  name = "Multi Compass",
  x=0, y=0, width = "50%", height="100%", --position and size of container
  },MultiWindow.bottom) --put the window in the HBox at the bottom of the MultiWindow
MultiWindow.Compass.back = Geyser.Label:new({
  name = "MultiWindow.Compass.back",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },MultiWindow.Compass.window) --put the label into the Compass container
MultiWindow.Compass.back:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/background.svg");]]) --set the background label
--MultiWindow.Compass.back:setStyleSheet(labelsStyle) --set the background label
MultiWindow.Compass.overlay = Geyser.Label:new({
  name = "MultiWindow.Compass.overlay",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },MultiWindow.Compass.back) --put the label into the Compass container
MultiWindow.Compass.overlay:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/CompassOverlay.svg");]]) --set the background label
--MultiWindow.Compass.overlay:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/vectorcompass.svg");]]) --set the background label
--MultiWindow.Compass.overlay:raise()
MultiWindow.Compass.hbox = Geyser.HBox:new({ --container to make columns
    name = "MultiWindow.Compass.box",
    x = 0, y = 0, width = "100%", height = "100%", --position and size of container
  },MultiWindow.Compass.back) --parent of this Hbox
--create three rows of the compass
MultiWindow.Compass.row1 = Geyser.VBox:new({name = "MultiWindow.Compass.row1",},MultiWindow.Compass.hbox)
MultiWindow.Compass.row2 = Geyser.VBox:new({name = "MultiWindow.Compass.row2",},MultiWindow.Compass.hbox)
MultiWindow.Compass.row3 = Geyser.VBox:new({name = "MultiWindow.Compass.row3",},MultiWindow.Compass.hbox)
--Create labels for the compass
MultiWindow.Compass.nw = Geyser.Label:new({ name = "MultiWindow.Compass.nw", },MultiWindow.Compass.row1)
MultiWindow.Compass.w = Geyser.Label:new({ name = "MultiWindow.Compass.w", },MultiWindow.Compass.row1)
MultiWindow.Compass.sw = Geyser.Label:new({ name = "MultiWindow.Compass.sw", },MultiWindow.Compass.row1)
MultiWindow.Compass.n = Geyser.Label:new({ name = "MultiWindow.Compass.n", },MultiWindow.Compass.row2)
MultiWindow.Compass.center = Geyser.VBox:new({ name = "MultiWindow.Compass.center", },MultiWindow.Compass.row2)
MultiWindow.Compass.up = Geyser.Label:new({ name = "MultiWindow.Compass.up", },MultiWindow.Compass.center)
MultiWindow.Compass.down = Geyser.Label:new({ name = "MultiWindow.Compass.down", },MultiWindow.Compass.center)
MultiWindow.Compass.s = Geyser.Label:new({ name = "MultiWindow.Compass.s", },MultiWindow.Compass.row2)
MultiWindow.Compass.ne = Geyser.Label:new({ name = "MultiWindow.Compass.ne", },MultiWindow.Compass.row3)
MultiWindow.Compass.e = Geyser.Label:new({ name = "MultiWindow.Compass.e", },MultiWindow.Compass.row3)
MultiWindow.Compass.se = Geyser.Label:new({ name = "MultiWindow.Compass.se", },MultiWindow.Compass.row3)
--function that occurs when a label above is clicked, 
function MultiWindow.Compass.click(name) send(name) end --send the name of the 
function MultiWindow.Compass.lit(name) --When a player can go in the direction, make the label an active image
  MultiWindow.Compass[name]:setStyleSheet([[background-color: "#5577dd77";]])
end --function MultiWindow.Compass.lit(name)
--when the space should be unlit change it back to white.
function MultiWindow.Compass.unlit(name) --When a player cannot go in the direction, make the label an active image
  MultiWindow.Compass[name]:setStyleSheet([[background-color: "#00000000";]])
end --function MultiWindow.Compass.unlit(name)
for _,v in pairs(MultiWindow.Compass.dirs) do --loop through dirs table
  SetTooltip(MultiWindow.Compass[v].name, "Go "..v.." ") --create hover tool tips
  MultiWindow.Compass[v]:setStyleSheet([[background-color: "#00000000";]]) --blank the compass directions
	MultiWindow.Compass[v]:setClickCallback("MultiWindow.Compass.click",v) --give each label an event to run the click function above.
end --end loop through MultiWindow.Compass.dirs

--create satus bar
MultiWindow.status_bar = Geyser.Container:new({
  name = "MultiWindow Status",    -- give it a unique name here
  x="50%", y=0, width = "50%", height="100%", --position and size of container
},MultiWindow.bottom)
MultiWindow.hpbar = Geyser.Gauge:new({ --create HP bar
  name="hpbar",
  x=0, y=0, width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.hpbar.front:setStyleSheet(hpbar.frontStyleSheet) --set the forground gradiant                                          
MultiWindow.hpbar.back:setStyleSheet(hpbar.backStyleSheet) --set the background gradiant
MultiWindow.hpbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Health&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
MultiWindow.fatiguebar = Geyser.Gauge:new({ --create fatigue bar
  name="MultiWindow fatiguebar",
  x=0, y="25%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.fatiguebar.front:setStyleSheet(fatiguebar.frontStyleSheet)
MultiWindow.fatiguebar.back:setStyleSheet(fatiguebar.backStyleSheet)
MultiWindow.fatiguebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Fatigue&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
MultiWindow.hungerbar = Geyser.Gauge:new({ --create hunger bar
  name="MultiWindow hungerbar",
  x=0, y="50%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.hungerbar.front:setStyleSheet(hungerbar.frontStyleSheet)
MultiWindow.hungerbar.back:setStyleSheet(hungerbar.backStyleSheet)
MultiWindow.hungerbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Hunger&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
MultiWindow.encumbrancebar = Geyser.Gauge:new({ --make encumberance bar
  name="MultiWindow encumbrancebar",
  x=0, y="75%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.encumbrancebar.front:setStyleSheet(encumbrancebar.frontStyleSheet)
MultiWindow.encumbrancebar.back:setStyleSheet(encumbrancebar.backStyleSheet)
MultiWindow.encumbrancebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Encumbrance&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])

--redraw windows within MultiWindow so they fill spaces properly
function MultiWindow.redrawWindows()
  local localMultiWindowWidth = MultiWindow.back:get_width() --get width of entire multi window
  local localMultiWindowHeight = MultiWindow.back:get_height() --get width of entire multi window
  local localCompassWidth = MultiWindow.Compass.window:get_width() --get the width of the window
  local localCompassHeight = MultiWindow.Compass.window:get_height() --get the height of the window
  local localMultiWindowBottomHeight = MultiWindow.bottom:get_height() --get the height of the window
  MultiWindow.lastResizeWidth = MultiWindow.lastResizeWidth or 0 --used to detect when a resize is needed
  MultiWindow.lastResizeHeight = MultiWindow.lastResizeHeight or 0 --used to detect when a resize is needed
  displayDebug("function MultiWindow.redrawWindows,\n\t"
    .."CompassWidth "..localCompassWidth.." localCompassHeight "..localCompassHeight.." localMultiWindowBottomHeight "..localMultiWindowBottomHeight
    .."\n\tlocalMultiWindowWidth "..localMultiWindowWidth.." MultiWindow.lastResizeWidth "..MultiWindow.lastResizeWidth
    .."\n\tlocalMultiWindowHeight "..localMultiWindowHeight.." MultiWindow.lastResizeHeight "..MultiWindow.lastResizeHeight
    .."\n")
  --only run window resizing if it is needed.
  if  localMultiWindowWidth ~= MultiWindow.lastResizeWidth or  --if the multiWindow has changed size since last run
      localMultiWindowHeight ~= MultiWindow.lastResizeHeight or --if the multiWindow has changed size since last run
      localCompassWidth ~= localCompassHeight then --if the compass is not square
    localCompassHeight = localMultiWindowBottomHeight --Record the height of the bottom of the multi window to resize compass with
  	if localCompassWidth &lt; localCompassHeight then --if the compass width is less than the height of the bottom portion of the multiwindow
    	MultiWindow.Compass.window:resize(localCompassHeight, localCompassHeight) --make compass square, while widening it
      localCompassWidth = localCompassHeight --make the width variable the same as height, used to resize status bar.
  	elseif localCompassWidth &gt; localCompassHeight then --if the compass width is more than the height of the bottom portion of the multiwindow
    	MultiWindow.Compass.window:resize(localCompassHeight, localCompassHeight) --make compass square, while widening it
      localCompassWidth = localCompassHeight --make the width variable the same as height, used to resize status bar.
  	end --if elseif window is not square
    MultiWindow.status_bar:move(localCompassWidth) --move the status bar past the compass
    MultiWindow.status_bar:resize(localMultiWindowWidth - localCompassWidth) --changed the width to fill space to the right of the compass
    MultiWindow.lastResizeWidth = localMultiWindowWidth --record the current width, to only run resizing when needed
    MultiWindow.lastResizeHeight = localMultiWindowHeight --record the current height, to only run resizing when needed
    displayDebug("Multi window resize run.\n")
  end --if not localMultiWindowWidth == MultiWindow.lastResizeWidth or not localMultiWindowHeight == MultiWindow.lastResizeHeight
end --end function keep square.

UIManagerRegisterWindow(MultiWindow.back) --send the window to the UI Manager</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Events</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>guiChange()</name>
				<packageName></packageName>
				<script>--calls events that are needed when a window change occurs.
--Do NOT put any function that changes the GUI here!!!

--I am suspicious that calling multiple functions in one event is a no no
--I did this though because creating multiple AnonymousEvents caused issues.
--If I Recall the last event would not occur.

function guiChange()
	setMainWindowAutoWrap() --adjusts word wrap for main window.
	if getTECDisplayDebugMode() then geyserDebug() end --if displaydebug is on
  --only resize windows managed by UIManager if they are enabled
	if UIManagerSettings[tecCompass.window.name] then --if window exists chek if it is enabled
    if not UIManagerSettings[tecCompass.window.name].disabled then tecCompass.drawKeepSquare() end --Keep the windowed compass square
  end --if UIManagerSettings[tecCompass.window.name]
  if UIManagerSettings[MultiWindow.back.name] then --if window exists chek if it is enabled
    if not UIManagerSettings[MultiWindow.back.name].disabled then MultiWindow.redrawWindows() end--keep the compass in the multi window square
  end --if UIManagerSettings[MultiWindow.back.name]
  if UIManagerSettings[tecMap.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecMap.name].disabled then tecMapdrawKeepSquare() end --resize map
  end --if UIManagerSettings[tecMap.name]
  if UIManagerSettings[tecComWindows.container.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecComWindows.container.name].disabled then tecComWindowResize() end --resize commmunications window
  end --if UIManagerSettings[tecComWindows.container.name]
  if UIManagerSettings[tecSettingsBar.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecSettingsBar.name].disabled then tecSettingsWindowResize() end--resize the Room Character window now
  end --if UIManagerSettings[tecSettingsBar.name]
end --end function guiChange

--whenever event sysWindowReizeEvent occurs run setMainWindowAutowrap.
--In otherwords when any window geyser or main is CHANGED, run setMainWindowAutoWrap.
--That is NOT just resizing.
registerAnonymousEventHandler("sysWindowResizeEvent", "guiChange")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>controlInput(_, command)</name>
				<packageName></packageName>
				<script>--use bool checks to control user input.
--Use this when you do not know what will be entered but DO know a trigger that will
--occur before the command that will be sent.
function controlInput(_, tecPassword) 
  if tecPasswordEntry then --if password entry is set, we expect a password.
  	tecPasswordEntry = false --set this if check to false to it doesn't occur every input.
    --Log into the game. md5.sumhexa converts user ID and password to md5 hash.
    sendAll("USER " .. tecUsername:lower() .. "\n", "SECRET NONE", "HASH "
  	 .. md5.sumhexa(tecUsername:lower() .. tecPassword .. "NONE") .. "\n", false)
    tecUsername = nil --Clear out the username.
    clearCmdLine() --clear password from command input bar.
    denyCurrentSend() --Deny the origional command, in this case the password.
    
    --clear the password off the screen.
    local tecMainLastLine = (getLastLineNumber("main") - 1)
    moveCursor(1,tecMainLastLine) --Move cursor to second from the newest line in main console
    selectString(tecPassword,1) --Select the password in main.
    replace("") --Replaced the selected password with.
    deselect() --Don't forget your deselects!
    pecho("Password Entered\n")
    
    tecPassword = nil --Just in case, lets make certain the password is cleared out.
    command = nil --
	end --tecPasswordEntry
end --function tecPasswordPrompt

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysDataSendRequest
registerAnonymousEventHandler("sysDataSendRequest", "controlInput")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tecExitHandler()</name>
				<packageName></packageName>
				<script>--runs when mudlet profile closes.
function tecExitHandler()
  send("logout") --Forces a complete logout of TEC
end --function tecExitHandler

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysExitEvent
registerAnonymousEventHandler("sysExitEvent", "tecExitHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Post Initilization</name>
				<packageName></packageName>
				<script>--For changing default settings that would be time consuming to change during
--also very helpful for GUI objects that did not have a size on creation.

UIManagerFileLoad(true) --load display settings from file.
UIManagerSetTheme("PlayersTheme", false) --load windows into display
tecRefreshSettingsWindow() --Refreshes text in settings window.
tecResetRoomCharacterWindow() --fill room characters window with text

--Enable or disable scroll bars. Dependant on user preference.
tecSetScrollBars(tecSettings.showScrollBars, false)


--set proper state for numpad navigation
setNumpadNavigation(getNumpadNavigation)

--set tts to players preferences
if getParthiaTalk() then
  parthiaTalkSetVoice(parthiaTalkGetVoice(), false) --set voice
  parthiaTalkSetSpeed(parthiaTalkGetSpeed(), false) --set talking speed
  parthiaTalkSetPitch(parthiaTalkGetPitch(), false) --set pitch voice speaks in
  ttsSpeak(" ") --Start the queue after startup
end
--if getParthiaTalk() then ttsClearQueue() end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
