<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>fuzzyBoolean(bool)</name>
			<packageName></packageName>
			<script>-- Provided by demonnic
--- Expands boolean definitions to be more flexible.
-- &lt;br&gt;True values are "true", "yes", "0", 0, and true
-- &lt;br&gt;False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
function fuzzyBoolean(bool)
  if type(bool) == "boolean" or bool == nil then
    return bool
  elseif tostring(bool) then
    local truth = {
      "yes",
      "true",
      "0"
    }
    local untruth = {
      "no",
      "false",
      "1"
    }
    local boolstr = tostring(bool)
    if table.contains(truth, boolstr) then
      return true
    elseif table.contains(untruth, boolstr) then
      return false
    else
      return nil
    end
  else
    return nil
  end
end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TextToSpeech</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>setParthiaTalk(mode)</name>
				<packageName></packageName>
				<script>function setParthiaTalk(mode)
  tecSettings.parthiaTalkEnabled = fuzzyBoolean(mode)
end --function setParthiaTalk(mode)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>getParthiaTalk()</name>
				<packageName></packageName>
				<script>function getParthiaTalk()
  return tecSettings.parthiaTalkEnabled
end --function setParthiaTalk(mode)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>parthiaTalkFilter(message)</name>
				<packageName></packageName>
				<script>function parthiaTalkFilter(message)
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "parthiaTalkFilter, was sent a non string variable. Type sent was "..tostring(type(message))
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    if getParthiaTalk() then --if parthia talk is enabled
      ttsQueue(error..errorFound) --send error to tts queue
    end --if getParthiaTalk() then
  else --message is a string, filter it
    message = string.gsub(message, '&lt;font color="#%x+"&gt;', '')
    message = string.gsub(message, [[&lt;/font&gt;]], '')
    message = string.gsub(message, "#%x+", "")
	  message = string.gsub(message, "&lt;center&gt;", "")
	  message = string.gsub(message, "&lt;/center&gt;", "")
    --below are some filters that I attempted appling to troubleshoot how the queue hangs on some computers.
    --message = string.gsub(message, "%(", "")
    --message = string.gsub(message, "%)", "")
    --message = string.gsub(message, "%*", "")
    --message = string.gsub(message, ":", "")
    --message = string.gsub(message, "\n", "")
    --message = string.gsub(message, "^%s+", "")
    --message = string.gsub(message, "%s+$", "")
    --message = string.gsub(message, "^%p+", "")
    --message = string.gsub(message, "&lt;%a&gt;", "")
    if message:match("think") then --if there is a thought remove &lt;&gt;
      message = string.gsub(message, [[^&lt;]], '') --remove or thoughts will not read
      message = string.gsub(message, [[&gt;$]], '') --remove or thoughts will not read
    end --if message:match("think")
    if not message:match("%S") then message = "" end
    --remove all multiple spaces from the talk like.
    while message:match("  ") do --loop through the line 
      message = message:gsub( "  ", " ") --remove all double spaces
    end --while parthiaTalkLine:match("  ") do
    return message --send the filtered message back
  end --if not type(message) == "string"
end --function parthiaTalkFilter(message)</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>pecho(message, talkOnly, forceSpeech)</name>
			<packageName></packageName>
			<script>function parthiaEcho(message, talkOnly, forceSpeech)
  talkOnly = fuzzyBoolean(talkOnly) --only speak do not show to screen
  forceSpeech = fuzzyBoolean(forceSpeech) --Speak even if parthia talk is disabled, for parthia talk thoughts and parthia talk speech
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "function parthiaEcho, was sent a non string variable. Type sent was "..tostring(type(message))
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    message = "Error function parthiaEcho, was sent a non string variable. Type sent was "..tostring(type(message))
  else --message is a string, display it
    if not talkOnly then cecho(message) end
    if getParthiaTalk() or forceSpeech then --if parthia talk is enabled, or forceSpeech is set
      message = parthiaTalkFilter(message) --filter message for tts
      if message ~= "" then
        if tecSettings.parthiaTalkQueueEnabled then --if the player wants the queue enabled
          --ttsSpeak(" ") --sometimes the queue stops, this prevents that. Disabled to queue stops the abrupt pausing when something new is sent. Also does not appear to resolve que stopping.
          ttsQueue(message)
        else --if parthia talk queue is disabled
          ttsSpeak(message)
        end --if tecSettings.parthiaTalkQueueEnabled
      end --If there is a message send it to the tts queue
    end --if Parthia talk is enabled que the message
  end --if not type(message) == "string" then

end --function parthiaEcho(message)

pecho = parthiaEcho --make pecho a reference of parthiaEcho so it can be used as shorter reference.</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>pechoLink(message, command, hint, bool)</name>
			<packageName></packageName>
			<script>function pechoLink(message, command, hint, bool)

  local errorFound = false --used to detect errors

  --make certain arguments are good
  if not type(message) == "string" then --if the message variable is not a string
    local errorFound = "function parthiaEcho, arg[1] message is a non string variable. Type sent was "..tostring(type(message))
  end --if not type(message) == "string"
  if not type(command) == "string" then --if the command variable is not a string
    local errorFound = "function parthiaEcho, arg[2] command is a non string variable. Type sent was "..tostring(type(command))
  end --if not type(command) == "string"
  if not type(hint) == "string" then --if the hint variable is not a string
    local errorFound = "function parthiaEcho, arg[3] hint is a non string variable. Type sent was "..tostring(type(command))
  end --if not type(hint) == "string"
  bool = true --bools in echoLinks are always true
  
  if errorFound then 
    debugc("Error: "..errorFound)
    cecho("tecDebugWindow","\n".."&lt;red:&gt;Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    message = "&lt;red:&gt;Error: "..errorFound
  end --if errorFound

  cechoLink(message, command, hint, bool) --show echo to screen
  if getParthiaTalk() then --if parthia talk is enabled
    message = parthiaTalkFilter(message) --filter message for tts
    if message ~= "" then 
      if tecSettings.parthiaTalkQueueEnabled then --if the player has enabled the parthia talke queue
          --ttsSpeak(" ") --sometimes the queue stops, this prevents that.
          ttsQueue(message) --que the message
        else --parthia talk queue is disabled
          ttsSpeak(message) --speak the message right now.
        end --if tecSettings.parthiaTalkQueueEnabled
    end --If there is a message send it to the tts queue
  end --if Parthia talk is enabled que the message
end --function pechoLink(linkTable)</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Variables Data Themese</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--[[
Used for creating variables that should be global.
Anything in the tecSettings table WILL be saved from file.
Meaning it WILL be loaded from file on a load.
]]--

function tecClientReset(displayToScreen) --reset all client settings to defaults
  if displayToScreen then echo("Please wait defaulting Parthia settings.\n") end

  --Creating a table that will be used to easily save these
  --Variables to file. So NOT putting tec.Settings. before
  --a variable will mean that it does not get saved to file.
  tecSettings = {}
  
  --folder where settings are kept. 
  --tecUpdate.versionsRespitory is in tec Auto Updates script
  tecSettingsFolder = getMudletHomeDir().."/settings/"
  
  --set primary text color in game
  --needs to be a hex number WITH # before it.
  --If the back ground is dark this will AUTOMATICALLY be changed
  --in the text filter trigger.
  tecSettings.tecTextColor = "#c0c0c0"
  
  --colors for compass highlighting
  tecSettings.compassDefaultHighlight = "#AA6666ff"
  
  --Changes colors because defaults have too much contrast.
  tecSettings.GreenTextColor = "#77dd77"
  tecSettings.BlueTextColor = "#8888ff"
  tecSettings.PurpleTextColor = "#cca9dd"
  tecSettings.GrayTextColor = "#646464"
  tecSettings.notApproachedCharacterColor = "#77dd77"
  tecSettings.ApproachedCharactersColor = "#ff6666"
  
  --background color for labels.
  tecSettings.labelBackgroundColor = "#000000"
  
  --background color for tabs.
  tecSettings.tabsBackgroundColor = "#000000"
  
  --Table to control settings to allow player to change images in parthia.
  --This table is used in each window that has a customizeable image. By using the image variable to save that players custom choice.
  --for example tecSettings.images.tabs.image or tecSettings.images["tabs"].image would be the image for tabs
  --The images are changed with function parthiaSetImages()
  tecSettings.images = {
    tabs = {
      folder = getMudletHomeDir()..[[/imgs/tabs/]], 
      image = getMudletHomeDir()..[[/imgs/tabs/scroll dark.png]],
      name = "tabs",
    },
    compassBackground = {
      folder = getMudletHomeDir()..[[/imgs/backgrounds/]], 
      image = getMudletHomeDir().. [[/imgs/backgrounds/old canvas light.jpg]],
      name = "compass background",
    },
    compassOverlay = {
      folder = getMudletHomeDir()..[[/imgs/compass/overlay/]], 
      image = getMudletHomeDir()..[[/imgs/compass/overlay/gray and black compass.svg]],
      name = "compass overlay",
    },
    mapBackground = {
      folder = getMudletHomeDir()..[[/imgs/backgrounds/]],  
      image = getMudletHomeDir()..[[/imgs/backgrounds/desk bottom.jpg]],
      name = "map background",
    },
    macroBackground = {
      folder = getMudletHomeDir()..[[/imgs/backgrounds/]], 
      image = getMudletHomeDir()..[[/imgs/backgrounds/mountains.svg]],
      name = "macro background",
    },
    healthBackground = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/plank.svg]],
      name = "health bar background",
    },
    healthBar = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/red gradient.svg]],
      name = "health bar",
    },
    fatigueBackground = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/plank.svg]],
      name = "fatigue bar background",
    },
    fatigueBar = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/yellow gradient.svg]],
      name = "fatigue bar",
    },
    hungerBackground = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/plank.svg]],
      name = "hunger bar background",
    },
    hungerBar = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/green gradient.svg]],
      name = "hunger bar",
    },
    encumbranceBackground = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/plank.svg]],
      name = "encumbrance bar background",
    },
    encumbranceBar = {
      folder = getMudletHomeDir()..[[/imgs/status/]], 
      image = getMudletHomeDir()..[[/imgs/status/blue gradient.svg]],
      name = "encumbrance bar",
    },
    
    
  } --tecSettings.imageSettings table
  
  --Color of label backgrounds and tabs as mouse hovers over them.
  tecSettings.hoverColor = "#9b9b9b"
  
  --color that help text is highlighted in
  tecSettings.helpHighlightColor = "SteelBlue"
  
  --default font size. Do not save it to file.
  tecDefaultFontSize = 12
  
  --adjustable font size
  tecSettings.tecFontSize = 12
  
  --Text size applied to tabs.
  tecSettings.tecTabsFontSize = 18
  
  --enable or disable debug mode.
  --Currently display red background main line to screen.
  --The code for this is at the bottom of
  --tec client triggers - text filters - text filters
  tecSettings.tecDebugMode = false
  
  --For gui messages debug, having all this put to screen when not needed muxs things up.
  tecSettings.tecDisplayDebugMode = false
  
  --for map debug messages.
  tecSettings.tecMapDebugMode = false
  
  --Height of the communications window text area.
  tecSettings.comTextWindowHeight = 100
  
  --This line is used to buffer the main line.
  --Than we filter this line in triggers - filter text 
  --It is important that this variable be global.
  --DO NOT SAVE THIS TO FILE
  filteredLine = "Reset filteredLine."
  
  --Zoom level of the map. 
  mapZoom = 1
  
  --used to keep track of characters in current room.
  tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
  
  --used to filters data from stats command 
  statsFilter = {}
  --used to filter data from the condition command 
  conditionFilter = {}
  
  --Stores player related data
  parthiaPlayer = {}
  --data for currently played character
  parthiaPlayer.CurrentCharacter = {}
  
  --stores a command list for the room character window
  --Done this way so it can be customized. 
  tecSettings.commandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.commandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  tecSettings.approachedCommandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.approachedCommandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  	
  --Used to check if a room Character check is needed.
  doRoomCharacterCheck = false

  --used for if timer debug is or is not wanted.
  tecSettings.tecTimerDebugMode = false
  
  --controls if scroll bars are of are now viewd.
  tecSettings.showScrollBars = true
  
  --Spaces inventory list 
  tecInventorySpacer = ""
  
  --use for functions that need to loop through all text windows 
  tecTextWindowNames = {"main", "tecSettingsConsole"
    ,"roomCharacters.console" , "Communication"
    ,"Thoughts", "Speech"}
    
  --Holds list of labels that use default lable stylesheet 
  tecWindowLabels = {} --normally configured with tecGetWindowLabelList
    
  tecTabNames = {} --contains names of tabs

	tecDebugSaveDir = getMudletHomeDir().."\/DebugingFiles\/"
  
  --is the player a beta tester
  tecSettings.betaTester = false
  
  --Is the player using GUIframe UI manager
  tecSettings.useGUIframe = true
  
  --Does the player want to have the player development folders managed
  tecSettings.PlayerDevelopmentSpaceEnabled = false
  
  --should keybindings to navigate with the numpad be enabled
  tecSettings.numpadNavigationEnabled = true
  
  --keep track of UI manager names. Not case sensative.
  UIManagers = { "GUIframe" , "none"}
  
  --holds geyser windows for UI manager
  tecGeyserWindows = tecGeyserWindows or {}
  
  --Used to save settings for GUI objects.
  UIManagerSettings = UIManagerSettings or {}
  
  tecSettings.parthiaTalkEnabled = false --is parthia talk enabled
  tecSettings.parthiaTalkQueueEnabled = false --decides if queue is used for tts.
  tecSettings.parthiaTalkThoughts = false --is parthia talk thoughts enabled
  tecSettings.parthiaTalkSpeech = false --is parthia talk speech enabled
  tecSettings.parthiaTalkSpeed = 6 --speed parthia talk speaks at
  tecSettings.parthiaTalkPitch = 6 --pitch parthia talk speaks in
  tecSettings.parthiaTalkVolume = 5 --volume parthia talk speaks in
  tecSettings.parthiaTalkVoice = "" --default voice parthia talk speaks in. No way to know what voices are supported

  --save if player wants to collect data for developers.
  helpDevDataFolder = getMudletHomeDir().."\/HelpDevelopers\/"
  helpDevDataFile = helpDevDataFolder.."Help The Developers Data.txt"
  tecSettings.helpDevelopers = false
  HelpDevsData = {} --table to save data with
  HelpDevsData.RoomTypes = {} --room types are the short description of a room, that appears after "You arrive" when you walk into a room.
  HelpDevsData.NPCTypes = {} --names of characters in TEC
  HelpDevsData.ObjectTypes = {} --names of objects in TEC
  HelpDevsData.Combat = {} --holds combat data
  HelpDevsData.Combat.AgainstPlayer = {} --attacks directed at the player
  HelpDevsData.Combat.PlayerAttacks = {} --attacks the player is using
  HelpDevsData.Combat.Unsorted = {} --attacks that we do not know if the player is using or someone is using against the player
  HelpDevsData.NonCombatActions = {} --hold non combat actions
  HelpDevsData.NonCombatActions.Unsorted = {} --hold unsorted non combat actions
  HelpDevsData.NonCombatActions.Healing = {}
  HelpDevsData.NonCombatActions.Hunting = {}
  HelpDevsData.NonCombatActions.Locksmithing = {}
  HelpDevsData.NonCombatActions.Tailoring = {}
  HelpDevsData.NonCombatActions.Outdoors = {}
  HelpDevsData.NonCombatActions.Pickpocket = {}
  HelpDevsData.NonCombatActions.Setups = {}
  HelpDevsData.NonCombatActions.StreetSmarts = {}

  --used for data checks
  parthiaDirectionsTable = {"north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up", "down", "upwards", "downwards"}

  lookRan = false --used to tell triggers when player has run the look command

  windowsCurlFile = tecSettingsFolder..[[curl.exe]] --used as local file for curl.
  windowsCurlDownloaded = false --used to verify the curl file has downloaded
  downloadcURLEventID = false --used to tell parthia it needs to download windows curl
  passwordInputEventID = false --will hold the event ID used to listen for username and password at command line
  tecUsernameEntry = false --used to tell parthia when the user is entering their username.
  tecUsername = "" --used store user's name during login process. Gets removed when login was successful.

  courses = {} --used to track settings for courses scripts.
  courses.threePart = false --if true scripts for three part course will run
  courses.fourPart = false --if true scritpts for four part course will run
  
  parthiaStopRan = false --if true player ran the stop command

  tecSettings.parthiaMapEnabled = false --tells parthia if it's mapping system should be running.  

	if displayToScreen then pecho("Parthia settings set to default.\n") end

end --function tecClientReset()
</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--Functions that work directly with many variables that have nothing logically in common.
--For example they aren't all variables for display settings, all for font or debuging.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecFileSaveSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--Save client settings to file
function tecFileSaveSettings(displayToScreen)

--Idealy implimenting some kind of error checking would be great.
--Maybe making tecFileLoadSettings into a function that returns a table
--rather than loads the data into a global settings table

  --Save the table to file.
  table.save(tecSettingsFolder.."TECClientData.lua", tecSettings)
	
	--display save to screen
	if displayToScreen then pecho("Client settings saved.\n") end

end --function tecFileSaveSettings(displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecFileLoadSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--Loads variable and theme settings from file.
--displayToScreen is boolean, to let the user know the event occured.
--In this case it is also a to screen notification that it was 
--successfull
function tecFileLoadSettings(displayToScreen)
  local tecTmpSettingsTable = {}
	--Set the location and name of file.	
	local path = tecSettingsFolder.."TECClientData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		cecho("tecDebugWindow","tecFileLoadSettings: "..path.." file doesn't exist.") --TEC debug screen
		--debugc("tecFileLoadSettings: "..path.." file doesn't exist.") --mudlets debug screen
		if displayToScreen then
      pecho("[ Info ]  - No settings file. Parthia using default settings.\n")
    end
	return --kill the function before real errors occur
	else
    table.load(path, tecTmpSettingsTable) --Load the settings in from file
    --Load settings from file updating default settings where different.
    tecSettings = table.update(tecSettings, tecTmpSettingsTable)
    if displayToScreen then 
      pecho("[  OK  ]  - Parthia settings successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
  
end --function tecFileLoadSettings

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientSaveAll(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientSaveAll(displayToScreen)
  --Save client data to file.
  tecFileSaveSettings(displayToScreen)
  --Save display data to file. 
  UIManagerFileSave(displayToScreen)
end --function tecClientSaveAll</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--used to keep track of characters in current room.
function clearTECRoomObjects()
	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
end --fuctoin clearTecRoomObjects</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>downloadcURL()</name>
					<packageName></packageName>
					<script>function downloadcURL(reconnectWhenDone)
  reconnectWhenDone = fuzzyBoolean(reconnectWhenDone)
  if getOS() == "windows" then --if the OS is windows built in curl will not work
    if not io.exists(windowsCurlFile) then --if file windowsCurlFile does not exists. windowsCurlFile declared in tecClientReset
      pecho("[ Info ]  - downloading cURL for secure authentication.\n")
      downloadcURLReconnectWhenDone = reconnectWhenDone
      downloadcURLEventID = registerAnonymousEventHandler("sysDownloadDone", "downloadcURLEventHandler") --track the download
      downloadFile(windowsCurlFile, [[https://github.com/TheEternalCitizens/mudlet-integration/releases/download/tecLatest/curl.exe]])
    end 
  end
end

function downloadcURLEventHandler(event, ...)
  if event == "sysDownloadDone" then --if it is a downloadDone event.
    --arg[1] is full file including directory
    local file = arg[1]
    debugToDisplay("function downloadcURLEventHandler, found download "..file)
    
    if windowsCurlFile == file then 
      debugToDisplay("function downloadcURLEventHandler, found a match for windowsCurlFile.")
      windowsCurlDownloaded = true
      killAnonymousEventHandler(downloadcURLEventID)
      downloadcURLEventID = false
      if downloadcURLReconnectWhenDone then
        pecho("cURL download completed. Please wait, reconnecting.")
      end --if downloadcURLDisplayToScreen
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>tecConfigThemes()</name>
				<packageName></packageName>
				<script>--People expressed interest in having themes.

--Important reference for themes
--https://doc.qt.io/qt-5.12/stylesheet-reference.html
--QT style sheets don't always act they was
--standard css does. Just buggy...

--lua showColors(3) shows a color chooser on screen.
--A good reference of colors, but when we offer color custimization to users, it can give them a 
--list to choose from.

--Upgrade options.
--add these variables to tecSettings so they can be saved and loaded.


function tecConfigThemes() --configure and initalize settings for tabs.
  --Default tab height
  tabsHeight = 30
  
  --set the style sheet for the tabs
  tabsStyle = [[
    QLabel{
      background-color: ]]..tecSettings.tabsBackgroundColor..[[;
      border-image: url("]]..tecSettings.images["tabs"].image..[[");
    }
    QLabel::hover{
      background-color: ]]..tecSettings.hoverColor..[[;
      border-image: url("]]..tecSettings.images["tabs"].image..[[");
    }
  ]]
  
  --This is now tabs text looks
  tabsFontStyle = [[&lt;center&gt;&lt;p style="font-size:]]
    ..tecSettings.tecTabsFontSize..[[px; color:black"&gt;]]

  labelsStyle = [[
  	QLabel{
  		background-color: ]]..tecSettings.labelBackgroundColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: gray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: ]]..tecSettings.hoverColor..[[;
      border-width: 1px;
      border-style: outset;
      border-color: gray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]
  								
  buttonsStyle = [[QPushButton{
                  		background-color: gray;
                      border-width: 1px;
                      border-style: outset;
                      border-color: lightgray;
                      border-top-left-radius: 15px;
                      border-top-right-radius: 15px;
  										border-bottom-left-radius: 15px;
                      border-bottom-right-radius: 15px;
                      margin-right: 1px;
                      margin-left: 1px;
                  		font-size: 50px;
                      qproperty-alignment: 'AlignCenter | AlignCenter';}
  								 QPushButton::on{}
  								 QPushButton::hover{}
  ]]					
  
  --This is now tabs text looks
  buttonsFontStyle = '&lt;center&gt;&lt;p style="font-size:18px; color:white"&gt;'
  
  --Used to shape rooms on map. Intentionally left without a } at the end.
  mapRoomStyle = [[
  	QLabel{
  	border-bottom-right-radius: 3;
  	border-bottom-left-radius: 3;
  	border-top-right-radius: 3;
  	border-top-left-radius: 3;
  	margin: 2px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  ]]
  
  --Create a red style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleRed = mapRoomStyle..[[
  	background-color:  #ff6666;
    }
  ]]
  
  --Create a Green style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleGreen = mapRoomStyle..[[
  	background-color: #77dd77;
    }
  ]]
  
  --Create a white style for creating map rooms
  --Done by completing the intentially unfinished mapRoomStyle
  mapRoomStyleWhite = mapRoomStyle..[[
  	background-color: GhostWhite;
    }
  ]]
  
  mapStraitOpenExitStyle = [[
  	QLabel{
  	background-color: GhostWhite;
  	}
  ]]
  
  mapStraitClosedExitStyle = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  
  --create table used for exits
  tecExit = { "hor", "ver", "ne", "nw" }
  
  --set the horizontal exit table
  tecExit["hor"] = {"0", "1", width, height}
  tecExit["hor"]["0"] = { tecExitStyleSheet = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  } --end tecExit["hor"][0] table declaration
  tecExit["hor"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
  tecExit["hor"].width = 10
  tecExit["hor"].height = 3
  
  --now set verticle table
  tecExit["ver"] = {"0", "1", width, height}
  tecExit["ver"]["0"] = { tecExitStyleSheet = [[
  	QLabel{
  	background-color: black;
  	}
  ]]
  } --end tecExit["ver"][0] table declaration
  tecExit["ver"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
  tecExit["ver"].width = 3
  tecExit["ver"].height = 10
  
  --Use these to adjust nenw icons
  local nenwExitIconSize = 10 --square size of icon
  
  --now set ne table
  tecExit["ne"] = {"0", "1", width, height}
  tecExit["ne"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/ne_closed.png");]]}
  tecExit["ne"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/ne_open.png");]]}
  tecExit["ne"].width = nenwExitIconSize
  tecExit["ne"].height = nenwExitIconSize
  
  --now set nw table
  tecExit["nw"] = {"0", "1", width, height}
  tecExit["nw"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/nw_closed.png");]]}
  tecExit["nw"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
  	..[[/]].."imgs"..[[/]].."exits"..[[/nw_open.png");]]}
  tecExit["nw"].width = nenwExitIconSize
  tecExit["nw"].height = nenwExitIconSize
end --function tecConfigThemes</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Pre initialization</name>
			<packageName></packageName>
			<script>--[[
Place functions here that need to run before function and window creations.
Runs after variable creations.
Intended for setting default settings for variables and loading settings from file.
]]--

tecClientReset(false) --create default settings.

--remove all messages from tts queue
if getParthiaTalk() then ttsClearQueue() end

downloadcURL() --cURL is needed for login. Windows cURL can not be seen from an os.execute or io.open so we have to download one and run it from the settings directory

--Call the function so data loads when mudlet starts.
tecFileLoadSettings(true)

--Now change some settings since data has been loaded
setFontSize(tecSettings.tecFontSize) --font size

tecConfigThemes() --configure display themes</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>mudlet Communidy Functions</name>
			<packageName></packageName>
			<script>--[[
Space for mudlet functions the community makes that we need.
]]--</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.text = {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then 
      gapSpaces = 2 
    else 
      gapSpaces = 1 
    end
  end
  options.effWidth = options.width - ((options.capLen * 2) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then 
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else 
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}


function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",

  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  if type(entry) ~= "string" then
    if type(entry) == "function" then
      local entryReturn = entry()
      if type(entryReturn) ~= string and not tostring(entryReturn) then entry = 0 end
    elseif not tostring(entry) then
      entry = 0
    end
  end
  return entry
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

function demonnic.TableMaker:assemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  return sheet
end


function demonnic.TableMaker:new(options)
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>guiFramework</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2

-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.

-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.

-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.

-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.

-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.

-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.

--Do not load GUIframe script if other UI manager is in use.
if tecSettings.useGUIframe then --if using GUIframe manager

--stylesheet that is applied to resizeLabels
tecResizeLabelStyleSheet = [[
QLabel{
	border-image: url("]]..getMudletHomeDir()..[[/imgs/resize/blue_arrows_10t.png")
}
QLabel::hover{ 
	border-image: url("]]..getMudletHomeDir()..[[/imgs/resize/blue_arrows.png");
}
]]

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)

GUIframe.configs = GUIframe.configs or {}

--Default settings for display.
--These will load on a reset, and will be
--what loads when the application is run before
--saving display settings.
GUIframe.defaults = {
    tabHeight = tabsHeight,
    tabStyle = tabsStyle,
    tabEchoStyle = tabsFontStyle,
    leftStartWidth = eighthW,
    leftStartHeight = halfH,
    rightStartWidth = quarterW,
    rightStartHeight = halfH,
    topStartHeight = eighthH,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/resize/blue_arrows.png",
    resizeRestImage = "/imgs/resize/blue_arrows_20t.png",
    borderOffset = 0,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}

    tabsInfo = {
        topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
            height = configs.tabHeight},
        bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
            width = configs.leftStartWidth, height = configs.tabHeight},
        topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
            width = configs.rightStartWidth, height = configs.tabHeight},
        bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
    }
    containerInfo = {
        topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
            y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth},
        topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth}
    }
    resizeInfo = {
        resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
            y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
            y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
            y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
        resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
            y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
            width = configs.resizeWidth}
    }

    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end

    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(tecResizeLabelStyleSheet) --DaveWithTheNiceHat
        --Dave commented this out. Favoring qts hover setting over mudlets event engine.
        --done while making tooltip functions. Below code was not working with tooltip system.
        --later found the source, but left this uncommented.
        --GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        --GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
        --    string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        --GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
        --    string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    if tecSettings.showScrollBars then --if tecSettings.showScrollBars is false
      setBorderRight(configs.rightStartWidth + configs.borderOffset)
    else
      setBorderRight(-16) --hide the scroll bar off the screen.      
    end --if tecSettings.ShowScrollBars
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
            local name = tab.name:gsub("Tab","")
            local show = GUIframe.windows[name].showText
            if show then
                tab:echo(configs.tabEchoStyle..name)
            end
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container, hideText)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local showText = not hideText
        window.showText = showText
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        if showText then
            lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    local text = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
        text[con] = text[con] or {}
        text[con][k] = v.showText
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, {wname, text[con][wname]})
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(tecSettingsFolder .. "GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = tecSettingsFolder .. "GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
      debugToDisplay("function GUIframe.loadSettings, wins: "..tostring(wins)) --DaveWithTheNiceHat
        for _,name in ipairs(wins) do
            debugToDisplay("function GUIframe.loadSettings, adding window: "..tostring(name)) --DaveWithTheNiceHat
            if type(name) == "string" then
                GUIframe.addWindow(GUIframe.windows[name], name, con)
            else
                local n, s = name[1], not name[2]
                GUIframe.addWindow(GUIframe.windows[n], n, con, s)
            end
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- can be called to activate a given tab without clicking on it
function GUIframe.activate(name)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local window = GUIframe.windows[name]
	if window then
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    end
end

-- can be called to apply a style to a given tab
function GUIframe.styleTab(name, style)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local tab = GUIframe.tabs[name]
	if tab then
	    tab:setStyleSheet(style)
    end
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
    raiseEvent("GUIframe.buttonClick",name,event)
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""), not window.showText)
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
  if not tecSettings.showScrollBars then --hides scroll bar when right click button is released.
    setBorderRight(-16) --Moves the scroll bar off the screen
    debugToDisplay("GUIframe.buttonRelease: setBorderRight to -16.")
  end --DaveWithTheNiceHat
	raiseEvent("GUIframe.buttonRelease",name,event)
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
    trackTooltip("Right-click &amp; drag to resize") --DaveWithTheNiceHat
	    lbl = GUIframe[name]
	    if lbl.isClicked then
        hideWindow(tooltips.name) --avoid tooltip being chopped DaveWithTheNiceHat
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab then trackTooltip("Right-Click &amp; drag to move tab") end --DaveWithTheNiceHat
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
	raiseEvent("GUIframe.buttonMove",name,event)
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

--register the event above
registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")

end --if tecSettings.useGUIframe</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>md5</name>
				<packageName></packageName>
				<script>md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n &lt;= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big &lt; #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n &lt; 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n &gt; 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 &gt; 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TECFunctions</name>
			<packageName></packageName>
			<script>--Functions made by The Eternal Citizens
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>debug</name>
				<packageName></packageName>
				<script>--[[
Debug like functions:


]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setTECDebugMode(tectmpSetDebug)</name>
					<packageName></packageName>
					<script>--opens a debug window.
--triggers system to send debug information to it.

function setTECDebugMode(tectmpSetDebug)
	
	--Set debug mode
	tecSettings.tecDebugMode = tectmpSetDebug or false
	
	if tecSettings.tecDebugMode then --if enabling debug
		openUserWindow("tecDebugWindow")
		--saveWindowLayout() --save floating miniconsole locations
		--loadWindowLayout() --load previously save miniconsole position.
		--tecDebugWindow:addScrollbars(parent, "Vertical")
    if tecSettings.showScrollBars then enableScrollBar("tecDebugWindow") end
		pecho("Debug mode enabled.\n")
	else --else disabling debug
		pecho("Debug mode disabled.\n")
		setTECDisplayDebugMode(tectmpSetDebug)
		setTECMapDebugMode(tectmpSetDebug)
		setTECTimerDebugMode(tectmpSetDebug)
    closeUserWindow("tecDebugWindow")
	end -- if tectmpSetDebug
	
end --end function setTecDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDebugMode() 
	return tecSettings.tecDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>debugToDisplay()</name>
					<packageName></packageName>
					<script>--this takes a string from function input, and displays it to the debug screen.

--error("") Test this one.
--debugc("") fairly certain this exports to mudlets debug screen.

--Idealy we would want this function to check if a TECClient debug child window 
--Is open, and create one if it is not. Than send debug code to it rather than 
--main, where users can easily see it or mudlets debug, which is meant for true
--blue errors.
function debugToDisplay(textMessage)
  textMessage = textMessage:gsub("%\n","") --remove new lines so they do not show in debug window.
	if getTECDebugMode() then --Is debug mode on?
		cecho("tecDebugWindow","\n"..textMessage) -- print message to screen
	end --if debug mode if check
end --end displayToDebug function
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyserDebug()</name>
					<packageName></packageName>
					<script>--poll GUIFrame for 
--Geyser API Reference https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html

function Geyser.Container:getDebug ()
	 
 if getTECDisplayDebugMode() then
	 
  	 local string guiLog = ""
  	 
     guiLog ="Name: "..tostring(self.name)..
		 " | Type: "..tostring(self.type)..
		 " | Parent: "..tostring(self.parent.name)..
		 " | X position: "..tostring(self:get_x())..
		 " | Y Position: "..tostring(self:get_y())..
		 " | Width: "..tostring(self:get_width())..
		 " | Height: "..tostring(self:get_height())..
		 "\n"
  	 
		 --just in case we are going to make a infinite loop killer.
		 guiloop = guiloop + 1
		 if guiloop &lt; 100 then
		 
       --Loop through all children of this container
       for k,v in pairs(self.windowList) do
    	 		
          if k ~= self then
    				guiLog = guiLog..v:getDebug() --Collect debug data to string
    					
          end --end if k not = self check
       end --end for loop pair(self windowlist)
		 end --if guiloop is less than 100
		 
		 --Returns debug data for all of the windows we have looped through
		 return guiLog
		 
	end --if getTECDisplayDebugMode()
end --end Geyser.Container:debugMode


function geyserDebug() --geyserWindow needs to be a string with the name of the window.	

	if getTECDisplayDebugMode() then --Is debug mode on?
		local debugOut = ""
    
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
  		--Send all of the windows information to the debug display.
  		guiloop = 0
  		debugToDisplay(GUIframe.topLeftContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomLeftContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomContainer:getDebug())
  		guiloop = 0
  		debugToDisplay(GUIframe.bottomRightContainer:getDebug())
  		guiloop = 0
  		debugOut =GUIframe.topRightContainer:getDebug()
  		debugOut = debugOut:sub(1, -2)
  		debugOut = debugOut:sub(2)
  		debugToDisplay(debugOut)
  		guiloop = 0
  		debugOut = GUIframe.topContainer:getDebug()
  		debugOut = debugOut:sub(1, -2)
  		debugToDisplay(debugOut)
    end --if if GetUIManager() == "GUIframe" and GUIframe.initialized
    else --if unknown
    tecWarningNotification("function getTECDisplayDebugMode, no UI manager specified.")
	end --if tecDebugMode is true

end --end geyserDebug() function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecReportIssuesHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>--help user create an issue request
--tecBrief is if screen reporting should be brief
--tecWindow is the string name of the window to send the command help to
function tecReportIssuesHelp(tecBrief) 

	--if a window was forgotten default to main
	--tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug report issue", 
  	[[tecReportIssues()]], 
  	"Report client issues", true)
  if not tecBrief then --if we do not want to be brief
  	pecho(", Report client issues to developers.\n")
	else echo("\n")
  end --end if not tecBrief

end --function tecReportIssues

function tecReportDebugHelp()
	pecho("\n---Debug collection helper---\n")
	pecho("Please do not follow these steps unless you have opened an issue report and "
		.."were asked to collect debug data from a developer.\n"
		.."The debug modes available are: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on&lt;reset&gt;, ", 
  	[[setTECDebugMode(true)]], 
  	"Enable basic debug", true)
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on&lt;reset&gt;, ", 
  	[[setTECDisplayDebugMode(true)]], 
  	"Enable display debugging", true)
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on&lt;reset&gt;, ", 
  	[[setTECMapDebugMode(true)]], 
  	"Enable map debugging", true)
	pecho("and ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timer on&lt;reset&gt;.\n", 
  	[[setTECTimerDebugMode(true)]], 
  	"Enable timer debugging", true)
	pecho("After enabling the debug mode or modes requested clear your main window with, ") 
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[UIManagerClearMainWindow() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	pecho("Now cause the issue reported to occur. After you have disable debug mode with ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off.\n", 
  	[[setTECDebugMode(false)]], 
  	"Disable debugging", true)
	pecho("Please verify the debug window has text in it than click ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save debug window.\n", 
  	[[tecSaveWindowText("tecDebugWindow")]], 
  	"Save debug window text to file", true)
	pecho("Please save the text in the main window to file by clicking: ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	pecho("Open your issue report, at the TEC gitHub ")
	  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	pecho("Open the folder that contains the debug window text by clicking ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	pecho("Open main.txt and tecDebugWindow.txt and verify nothing is in it that you would "
		.."not want to be viewed by the public.\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Drag the files tecDebugWindow.txt and main.txt into the comment area of your "
		.."gitHub issues report.&lt;reset&gt;\n"
		.."To update your issue click the green button labeled -Comment-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --function tecReportDebugHelp()

function tecReportStandardIssue()
	pecho("\n---Create an issue request helper---\n")
	pecho("Go to the client's issue reporting gitHub page: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	pecho("Please view our current open issues to see if your issue was already reported.\n"
		.."If you have not you will need to log into gitHub.\n"
		.."To create an issue report click the green -New Issue- button, on the right side of the page.\n"
		.."A new page will load. In the -Title- section please provide a brief description of your issue\(s\).\n"
		.."In the comment section labeled -Leave a comment-. Fully describe your issue\(s\).\n"
		.."It is highly recommendable to clear you main display and recreate your issue "
		.."before continuing forward.\n"
		.."If you would like to, clear your display with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[UIManagerClearMainWindow() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	pecho("This file is called main.txt and can easily found by clicking: ")
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	pecho("Open main.txt and verify nothing is in it that you would not want to be viewed "
		.."by the public!\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Now drag the file main.txt into the comment area of the gitHub issues report.&lt;reset&gt;\n"
		.."At this time, please do not attach any other files to the issue report.\n"
		.."To submit your issue click the green button labeled -Submit new issue-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --end function tecReportMajorIssue

function tecReportIssues()

	pecho("&lt;black:red&gt;\nPlease follow the instructions below.\n")

	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---Start an issue request---\n", 
  	[[tecReportStandardIssue()]], 
  	"Standard issue report tutorial", true)
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---A developer asked you to enable debug---", 
  	[[tecReportDebugHelp()]], 
  	"Debug collection tutorial", true)
		
	echo("\n") --leave this as the last line. cechlink does not autoscroll main display.
	
end --function tecReportIssues</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>function setTECDisplayDebugMode(tmpDebugMode)
	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecDisplayDebugMode = tmpDebugMode or false
	
	if tecSettings.tecDisplayDebugMode then pecho("Display debug mode on.\n")
	else pecho("Display Debug Off.\n") end
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDisplayDebugMode() 
	return tecSettings.tecDisplayDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>displayDebug(textMessage)</name>
					<packageName></packageName>
					<script>--intended for sending debug messages to debug window IF display mode is enabled.
function displayDebug(textMessage)
  if getTECDisplayDebugMode() then
    debugToDisplay(textMessage)
  end -- if getTECDisplayDebugMode()
end --function displayDebug
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>mapDebug(textMessage)</name>
					<packageName></packageName>
					<script>--intended for sending debug messages to debug window IF display mode is enabled.
function mapDebug(textMessage)
  if getTECMapDebugMode() then
    debugToDisplay(textMessage)
  end -- if getTECDisplayDebugMode()
end --function displayDebug
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecColorTest()</name>
					<packageName></packageName>
					<script>--Just a simple test outputting colors to screen using three main methods.

function tecColorTest()

  echo("\ndefault text\n")
  cecho("\ncecho: &lt;:"..tecSettings.helpHighlightColor.."&gt;blue background, &lt;red:white&gt;Red text white background.\n")
  decho("\ndecho: &lt;:255,0,0&gt;Red background, &lt;0,0,255:0,255,0&gt;Blue text green background.\n")
  hecho("\nhecho: #ff0000Red text, #3c00ffBlue text.\n")

end --end tecColorTest function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECMapDebugMode(boolean)</name>
					<packageName></packageName>
					<script>function setTECMapDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecMapDebugMode = tmpDebugMode or false --enable map debug mode
	
	if tecSettings.tecMapDebugMode then pecho("Debug map mode on.\n")
	else pecho("Map Debug Off.\n") end
	
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECMapDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECMapDebugMode()
	return tecSettings.tecMapDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECTimerDebugMode(boolean)</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function setTECTimerDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode

	tecSettings.tecTimerDebugMode = tmpDebugMode or false
	if tecSettings.tecTimerDebugMode then pecho("Debug timer mode on.\n")
	else pecho("Timer Debug Off.\n") end
end --setTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECTimerDebugMode()</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function getTECTimerDebugMode()
	return tecSettings.tecTimerDebugMode
end --getTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecErrorNotification(errorFound)</name>
					<packageName></packageName>
					<script>--[[
Used show messages when errors occur

Usage:
  tecErrorNotification(errorFound, displayToScreen)
  erroFound, is a string describing the error
  displayToScreen, is if the error should be displayed to main console. It is true by default. EVEN when nothing is passed as argument 2.
examples:
  tecErrorNotification("function functionName, error found failed something.", false) --would show error message to parthia debug console and mudlets error window
  tecErrorNotification("function functionName, error found failed something.", true) --would show error message to parthia debug console and mudlets error window, and main console
]]--
function tecErrorNotification(errorFound, displayToScreen)
  if displayToScreen == nil then displayToScreen = true end
  displayToScreen = fuzzyBoolean(displayToScreen)
  debugc("Error: "..errorFound)
  debugToDisplay("&lt;red:&gt;Error: "..errorFound)

  if displayToScreen then
    pecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer with command ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
      [[tecReportIssues()]],
      "Report issues or bugs", true)
    cecho("")
  end --if displayToScreen
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecWarningNotification(errorFound)</name>
					<packageName></packageName>
					<script>--fully notifies user when an error is found.
function tecWarningNotification(errorFound)
  debugc("Warning: "..errorFound)
  debugToDisplay("&lt;yellow:&gt;Warning: "..errorFound)
--  cecho("&lt;yellow:&gt;Warning: "..errorFound
--    .."\n\tIf you experence issues contact a developer with: ")
--  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Report Issues\n", 
--    [[tecReportIssues()]],
--    "Report issues or bugs", true)
--  cecho("")
end --function tecErrorNotification</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>data</name>
				<packageName></packageName>
				<script>--[[
Functions that write to file or socket
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>parthiaFileToString(path, remove)</name>
					<packageName></packageName>
					<script>--[[
This function opens a file and returns the contents of the file as a string.
Usage:
  parthiaFileToString(path, remove)
  path is the path and name of the file to open.
  remove is boolean if the file should be removed when completed.

Examples: 
  
  myFriends, errorFound = parthiaFileToString("C:\My friends list.txt")
  if erroFound then
    pecho("Error found in data read: "..errorFound")
  end
  Above would read in file C:\My friends list.txt into variable myFriends
  If an error was found it would display the error to screen and myFriends variable will be nil.
    
  myFriends, errorFound = parthiaFileToString("C:\My friends list.txt", true)
  if erroFound then
    pecho("Error found in data read: "..errorFound")
  end
    Above would read in file C:\My friends list.txt into variable myFriends AND delte the file if the read was successful.
    If an error was found it would display the error to screen and myFriends variable will be nil.
    
  myFriends = parthiaFileToString("C:\My friends list.txt")
    Above would read in file C:\My friends list.txt into variable myFriends
    If an error was found myFriends will be nil.
]]--
function parthiaFileToString(path, remove)

  --make certain the arguments are correct
  remove = fuzzyBoolean(remove)
  if type(path) ~= "string" then --make certain a string was passed
    return "", "function parthiaFileToString, argument 1 is a non string variable. Received: "..tostring(stringToCheck).." expected a string."
  end --if type(path) ~= "string" then

  --open the file
  local fileOpened, errorFound = io.open(path, "r") --open the file as read
  if not fileOpened then --file was not created error occured.
    fileOpened:close() --incase of partial failure, close file.
    fileOpened = nil
    return  nil, "function parthiaFileToString: "..errorFound--error found stop function
  end --if not fileOpened
  
  --read from the file
  local fileString = fileOpened:read("*a") --read the entire file to a string
  fileOpened:close() --close the file
  fileOpened = nil
  
  --verify read was correct and return the file as a string
  if fileString then --file read correctly
    if remove then os.remove(path) end --remove the file
    return fileString --return it as a string
  else --File had read error
    return nil, "function parthiaFileToString, failure converting file: "..path.." to string"--error found stop the function
  end --if fileString

end --parthiaFileToString</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaStringToFile(data,path,displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
saves a lua string to file
in ANSI format

Usage:
  parthiaStringToFile(str,path,displayToScreen)
  str, a string to be saved to file.
  path, is the full directory and file name to save to
  displayToScreen, if true display message to screen, false no messages will display to main console

Examples:
  errorFound = parthiaStringToFile("Write me to file.", "C:\users\dave\.config\testfile.txt", false)
    writes string "Write me to file." to C:\users\dave\.config\testfile.txt. Not displaying any message to main console.
  errorFound = parthiaStringToFile("Write me to file.", "/root/users/dave/.config/testfile.txt", false)
    writes string "Write me to file." to /root/users/dave/.config/testfile.txt. Not displaying any message to main console.
]]--
function parthiaStringToFile(str,path,displayToScreen)
  --make certain variables are good
  if not type(str) == "string" then
    local erroFound = "argument 1 needs to be a string to save. Received a "..type(str).." as argument 1."
    if displayToScreen then
      tecErrorNotification("function parthiaStringToFile, "..errorFound)
    else
      tecErrorNotification("function parthiaStringToFile, "..errorFound, false)
    end
    return errorFound
  end --if not type(tbl) == "table"
  if not type(path) == "string" then
    local errorFound = "argument 2 needs to be a full path and file name as string variable. Received a "..type(path).." as argument 1."
    if displayToScreen then
      tecErrorNotification("function parthiaStringToFile, "..errorFound)
    else
      tecErrorNotification("function parthiaStringToFile, "..errorFound, false)
    end
    return errorFound
  end --if not type(path) == "string"
  displayToScreen = fuzzyBoolean(displayToScreen)

  local f, errorFound = io.open(path, "w") --open in write mode or create file
  if not f then --file was not created error occured.
    f:close() --incase of partial failure, close file.
    f = nil
    if displayToScreen then
      tecErrorNotification("function parthiaStringToFile, "..errorFound)
    else
      tecErrorNotification("function parthiaStringToFile, "..errorFound, false)
    end
    return  errorFound--error found stop write
  end --if not f
  f:write(str) --Write string to file
  f:close() --close the file
  f = nil
  
  if displayToScreen then pecho("String writen to "..path.." successful.\n") end
  
end --function parthiaStringToFile(str,path,displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaTableSave(tbl, path, jsonFormat, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
Saves a lua table to file. Creating a thread to avoid locking main thread.
Includes option to save table in json format
File is in ANSI format

Usage:
  parthiaTableSave(table, path, jsonFormat, displayToScreen)
  table, is a table to save
  path, is the full directory and file name to save to
  jsonFormat, boolean true if you want to save in json format false saves to standard lua table format
  displayToScreen, if true display message to screen, false no messages will display to main console

Examples:
  errorFound = parthiaTableSave(aTableToSave, "/root/users/dave/.config/testfile.json", true, false)
    will save aTableToSave to /root/users/dave/.config/testfile.json, in json format, and not display messages to screen. If there is a error errorFound will contain a string explaining the error.
  parthiaTableSave(aTableToSave, "C:\users\dave\.config\testfile.lua", false, true)
    will save aTableToSave to C:\users\dave\.config\testfile.lua, in standard lua table format, success or errors will display to screen
  errorFound = parthiaTableSave(aTableToSave, "C:\users\dave\.config\testfile.lua", false, true)
    will save aTableToSave to C:\users\dave\.config\testfile.lua, in standard lua table format, success or errors will display to screen. If there is a error errorFound will contain a string explaining the error.
]]--

--this function is used in a coroutine to save lua tables with table.save
--includes error checking. table.save does not return an error message
function saveLUATableThread(tbl, path, displayToScreen)
  local dir = path:match("(.*\\)") --return the directory portion of path
  local errorFound = false
  if dir then --if path has a directory in it
    if not io.exists(dir) then
      errorFound = "directory: "..dir.." does not exist."
    end --if not io.exists(dir)
  else --windows directory not found in path
    local dir = path:match("(.*/)") --check for mac and linux
    if not dir then --no directory in path
      errorFound = "no directory passed in argument 2."
    end --if not dir
  end --if dir
	if errorFound then --if an error was found in the path
    if displayToScreen then
      tecErrorNotification("function parthiaTableSave, saving table to "..path.." failed. With error: "..tostring(errorFound))
    else --do not show error to main console
      tecErrorNotification("function parthiaTableSave, saving table to "..path.." failed. With error: "..tostring(errorFound), false)
    end --if displayToScreen
    tbl = nil
    return errorFound
  else --no errors with path found run the function
    table.save(path, tbl)
    tbl = nil
    if displayToScreen then pecho("Table saved to "..path.." successfully.\n") end
  end --if errorFound
end --saveTableToJSON(tbl, path, displayToScreen)

function parthiaTableSave(tbl, path, jsonFormat, displayToScreen)

  --make certain variables are good
  if not type(tbl) == "table" then
    tecErrorNotification("function parthiaTableSave, argument 1 needs to be a table to save. Received a "..type(tbl).." as argument 1.")
    return
  end --if not type(tbl) == "table"
  if not type(path) == "string" then
    tecErrorNotification("function parthiaTableSave, argument 2 needs to be a full path and file name as string variable. Received a "..type(path).." as argument 1.")
    return
  end --if not type(path) == "string"
  jsonFormat = fuzzyBoolean(jsonFormat)
  displayToScreen = fuzzyBoolean(displayToScreen)
  
  local copiedTable = table.deepcopy(tbl) --copy the table, incase the origional changes while a coroutine thread is saving the table

  if jsonFormat then
    local errorFound = parthiaStringToFile(yajl.to_string(copiedTable),path,false)
    if errorFound then
      if displayToScreen then
        tecErrorNotification("function parthiaTableSave, function parthiaStringToFile returned: "..errorFound)
      else --do not show error to main console
        tecErrorNotification("function parthiaTableSave, function parthiaStringToFile returned: "..errorFound, false)
      end --if displayToScreen
      return errorFound
    else
      if displayToScreen then pecho("Table saved in json format to "..path.." successfully.\n") end
    end --if errorFound
  else --not saving to json format
    --to avoid locking main thread write table to second thread
    saveThread = coroutine.create(saveLUATableThread)
    local threadRan = coroutine.resume(saveThread, copiedTable, path, displayToScreen)
    if not threadRan then --if the coroutine failed to run
      local errorFound = "table.save thread failed."
      if displayToScreen then
        tecErrorNotification("function parthiaTableSave, saving table to "..path.." failed. With error: "..tostring(errorFound))
      else --do not show error to main console
        tecErrorNotification("function parthiaTableSave, saving table to "..path.." failed. With error: "..tostring(errorFound), false)
      end --if displayToScreen
      return errorFound
    end --if not threadRan
  end -- if jsonFormat

end --function parthiaTableSave(tbl, path, jsonFormat, displayToScreen)</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Misc</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>dontForgetToSave()</name>
					<packageName></packageName>
					<script>function dontForgetToSave()
  pecho("Don't forget to save your changes:\n")
  pecho("Save all settings with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save all\n", 
  [[tecClientSaveAll(true)]],
  "Save all settings", true)
  cecho("") --cechoLink will not \n on its own.
end --function dontForgetToSave</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ReplaceStringMagicChar(tmpString)</name>
					<packageName></packageName>
					<script>--used to replace magic characters in a string with the proper escape character 
--sequence. Useful for replacing file names on sysDownload events.
function ReplaceStringMagicChar(tmpString)
  tmpString = tmpString:gsub("%%", "%%%")
  tmpString = tmpString:gsub("%(", "%%(")
  tmpString = tmpString:gsub("%)", "%%)")
  tmpString = tmpString:gsub("%.", "%%.")
  tmpString = tmpString:gsub("%+", "%%+")
  tmpString = tmpString:gsub("%[", "%%[")
  tmpString = tmpString:gsub("%^", "%%^")
  tmpString = tmpString:gsub("%$", "%%$")
  tmpString = tmpString:gsub("%-", "%%-")
  tmpString = tmpString:gsub("%*", "%%*")
  tmpString = tmpString:gsub("%?", "%%?")
return tmpString
end --function ReplaceStringMagicChar(tmpString)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>hex2rgb(hex)</name>
					<packageName></packageName>
					<script>--convert hex to RGB
function hex2rgb(hex)
    hex = hex:gsub("#","")
    return tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6))
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GetConsoleColumnCount(localConsole)</name>
					<packageName></packageName>
					<script>function GetConsoleColumnCount(localConsole)

  --get average pilxelwidth of font
  local fontWidth, _ = calcFontSize(getFontSize())
  --Get size of the entire window.
  local localConsoleWidth = localConsole:get_width()
  
  --Calculate how many characters can fit into consoles
  localConsoleColumnCount = math.floor((localConsoleWidth / fontWidth) - 1)
  
  displayDebug("function parthiaRoomCharactersWrap, Font Width: "..tostring(fontWidth)
    .." localConsoleWidth: "..tostring(localConsoleWidth)
    .." localConsoleColumnCount: "..tostring(localConsoleColumnCount))
  
  return localConsoleColumnCount
end --function parthiaRoomCharactersWrap()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>replaceDoubleSpaces(message)</name>
					<packageName></packageName>
					<script>--replace double spaces in message with a single space.
function replaceDoubleSpaces(message)
  if not type(message) == "string" then --if message is not a string variable
    tecWarningNotification("function replaceDoubleSpaces, sent not string variable as message. Message = "..tostring(message))
  end --if not type(message) == "string"
  return message:gsub("%s%s", " ") --remove all double spaces and return it.
end --removeDoubleSpaces(message)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>removeEndSpace(message)</name>
					<packageName></packageName>
					<script>--if message ends with a space character, remove it.
function removeEndSpace(message)
  if not type(message) == "string" then --if message is not a string variable
    tecWarningNotification("function removeEndSpace, sent not string variable as message. Message = "..tostring(message))
  end --if not type(message) == "string"
  return message:gsub("%s$", "") --remove all double spaces and return it.
end --removeDoubleSpaces(message)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaFileList(path)</name>
					<packageName></packageName>
					<script>--returns a table containing files in a directory
--returns false if no files found.
--Will NOT return directories 
--usage example: local fileTable = parthiaFileList(getMudletHomeDir()..[[/imgs/tabs]])

function parthiaFileList(path)
  if type(path) ~= "string" then tecErrorNotification("function parthiaFileList, argument 1 non string variable.") end
  local localFileTable = {} --table to hold file names

  for file in lfs.dir(path) do --look through directory
      if file ~= "." and file ~= ".." then --skip . and .. folders
          local f = path..'/'..file --get full path and file name
          local attr = lfs.attributes (f) --collect attributes on file
          if type(attr) == "table" then --make certain data collected
            if attr.mode == "file" then --look for files only
              table.insert(localFileTable, file)
            end --if attr.mode == "file"
          else --attribute collection filed
            tecWarningMessage("function parthiaFileList, failed to collect attributes on "..f)
          end --if type(attr) == "table"
      end --if file ~= "." and file ~= ".."
  end --for lfs.dir(path)
  if table.is_empty(localFileTable) then --the table is empty, no files found
    return false
  else --table has some files in it
    return localFileTable
  end
end --function parthiaFileList(path)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>addLinksToDirections()</name>
					<packageName></packageName>
					<script>--[[
Finds room types and directions in the global line. They are between color codes.
Using the directions and room types to turn that text into clickable links that sends a command to go to that description or direction.
If player help developers is enabled these room descriptions are saved into table HelpDevsData.RoomTypes
]]--

function addLinksToDirections()
  local previousRoomType = ""
  for _,exitPattern in ipairs({"0020ff\"&gt;(%P+%-?%P*)&lt;\/", "00cd20\"&gt;(%P+%-?%P*)&lt;\/" }) do --loop through exit patterns
    --for tmpRoomType in string.gmatch( line, "0020ff\"&gt;(%P+%-?%P*)&lt;\/" ) do --detect surrounding room types that do not match players current room type
    for tmpRoomType in string.gmatch( line, exitPattern ) do --detect surrounding room types that do not match players current room type
      
      --collect roomType into HelpDevs if the player has it enabled
      if getHelpDevs() then --if player has help devs set collect room types
        if not table.contains(parthiaDirectionsTable, tmpRoomType) then --if tmpRoomType is not a direction
          HelpDevsData.RoomTypes[tmpRoomType] = "" --collect name to table.
        end --if not table.contains(parthiaDirectionsTable, tmpRoomType)
      end --if getHelpDevs()

      --create links in the main window.
      local iterator = 1 --create iterator to use in loop below
      while selectString(tmpRoomType, iterator ) &gt; -1 do --select iterator detected room type
        if tmpRoomType:lower() == "upwards" then tmpRoomType = "up" end --if upwards is room type detected, turn it to up
        if tmpRoomType:lower() == "downwards" then tmpRoomType = "down" end --if downwards is room type detected, turn it to down
        setLink( [[send("go ]]..tmpRoomType..[[")]], "walk here") --make the selected room type clickable by the player, so they can walk to that room
        deselect() --dont forget your deselects
        iterator = iterator + 1 --increase loop's iterator
      end --if selectString(tmpRoomType, 1 ) &gt; -1
    end --for string.gmatch( line, "0020ff\"&gt;(%P+)&lt;\/" )
  end --for ipairs({"0020ff\"&gt;(%P+%-?%P*)&lt;\/", "00cd20\"&gt;(%P+%-?%P*)&lt;\/" })

  --collect current room type
  local tmpCurrentRoomType = line:match("^You arrive at (%P+)%p")
  if tmpCurrentRoomType then --if something was found above.
    if getHelpDevs() then --if player has help devs enabled
      if not table.contains(parthiaDirectionsTable, tmpCurrentRoomType) then --if tmpRoomType is not a direction
        HelpDevsData.RoomTypes[tmpCurrentRoomType] = "" --collect name to table.
      end --if not table.contains(parthiaDirectionsTable, tmpRoomType)
      HelpDevsData.RoomTypes.currentRoom = tmpCurrentRoomType
    end --if getHelpDevs()
  end --if tmpCurrentRoomType
  
end --function addLinksToDirections()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>addLinksToCharacters(checkType)</name>
					<packageName></packageName>
					<script>--[[
add clickable links to NPCs and PCs as player walks into a room or looks.
Collect NPC and PC names to help the developers database.
]]--

function addLinksToCharacters(checkType)
  local characterLinkTypes = {"look", "walk"} --used to make certain argument is correct
  local characterLinkTypesString = "" --holds a list of arguments for this function to show in error.
  for _, v in ipairs(characterLinkTypes) do characterLinkTypesString = characterLinkTypesString..v..", " end --put good argument types in a single string
  
  if type(checkType) ~= "string" then --make certain argument is a string
    tecErrorNotification("function addLinksToCharacters, was passed a non string variabe. Recieved: "..tostring(checkType)..", expected "..characterLinkTypesString..".")
  end --if type(checkType) ~= "string"
  if not table.contains(characterLinkTypes, checkType) then --make certain argument is of acceptable type
    tecErrorNotification("function addLinksToCharacters, does not match a supported check type, supported check types are: "..characterLinkTypesString)
  end --if not table.contains(characterLinkTypes, checkType)
  
  checkType = checkType:lower() --make certain argument is all lower case

  if checkType == "look" then --if argument was "look" run selection for look command
    local checkedCharactersTable = {} --table to save checked character types. To avoid checking the same character names multiple times.
    for tmpCharacterType in string.gmatch( line, "0020ff\"&gt;(%P+%-?%P*)&lt;\/" ) do --detect characters as the player looks
        tmpCharacterType = tmpCharacterType:gsub("^an ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^An ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^A ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^a ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("%(unconscious%)","") --Removed the unconscious state from tmpCharacterType

      if not table.contains(checkedCharactersTable, tmpCharacterType) then --if the character type has NOT been processed
        debugToDisplay("function addLinksToCharacters, look passed, setting links for "..tmpCharacterType)
        checkedCharactersTable[tmpCharacterType] = "" --add character type to the checkedCharactersTable
        if getHelpDevs() then --if player has help devs set collect room types
          if not table.contains(parthiaDirectionsTable, tmpCharacterType) then --if tmpCharacterType is not a direction
            debugToDisplay("function addLinksToCharacters, look passed, adding "..tmpCharacterType.." to HelpDevsData.NPCTypes table.")
            HelpDevsData.NPCTypes[tmpCharacterType] = "" --collect name to table.
          end --if not table.contains(parthiaDirectionsTable, tmpCharacterType)
        end --if getHelpDevs()
        local iterator = 1 --create iterator to use in loop below
        while selectString(tmpCharacterType, iterator ) &gt; -1 do --select iterator detected room type
          local popupCmds, popupHelp = createCharacterCmdTable(tostring(iterator).." "..tmpCharacterType)
          setPopup("main", popupCmds, popupHelp)
          deselect() --dont forget your deselects
          iterator = iterator + 1 --increase loop's iterator
        end --if selectString(tmpCharacterType, 1 ) &gt; -1
      end --if not table.contains(checkedCharactersTable, tmpCharacterType)
    end --for string.gmatch( line, "0020ff\"&gt;(%P+)&lt;\/" )
  elseif checkType == "walk" then --if addLinksToCharacters was called with "walk"
    local charactersInRoomList = string.match( line, "You arrive at [^%.]-%.([^%.]-%.)" ) --get list of characters in room after walking in
    if charactersInRoomList:match("You are facing ") then charactersInRoomList = false end --There are no characters in this room, skip the next steps.
    if charactersInRoomList then --there are characters in this room
      charactersInRoomList = charactersInRoomList:gsub(" is here.","") --remove from list
      charactersInRoomList = charactersInRoomList:gsub(" are here.","") --remove from list
      charactersInRoomList = charactersInRoomList:gsub(" and ",", ") --replace and with a
      charactersInRoomList = charactersInRoomList:gsub("%,%,",",") --the line above sometimes creats ,, if it did fix it.
      debugToDisplay("function addLinksToCharacters, walk passed, temp Character list: "..charactersInRoomList)
      local tmpCharacterTable = {} --will hold character types
      for tmpCharacterType in string.gmatch( charactersInRoomList, " ([^,]+),?" ) do --detect characters as the player enters a room
        tmpCharacterType = tmpCharacterType:gsub("^an ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^An ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^A ","") --remove from the begining of the string
        tmpCharacterType = tmpCharacterType:gsub("^a ","") --remove from the begining of the string
        if not table.contains(tmpCharacterTable, tmpCharacterType) then --if tmpCharacterType does not exist in tmpCharacterTable add it
          debugToDisplay("function addLinksToCharacters, walk passed, adding "..tmpCharacterType.." to the tmpCharacterTable.")
          tmpCharacterTable[tmpCharacterType] = "" --add character to tmpCharacterTable
        end --if not table.contains(tmpCharacterTable, tmpCharacterType)
      end --for tmpCharacterType
      for k, v in pairs(tmpCharacterTable) do --loop through the tmpCharacterTable
        debugToDisplay("function addLinksToCharacters, walk passed, adding links in main for "..k)
        if getHelpDevs() then --if player has help devs set collect room types
          if not table.contains(HelpDevsData.NPCTypes, k) then --if the NPCType is not already in the NPCType table
            debugToDisplay("function addLinksToCharacters, walked passed, adding "..k.." to HelpDevsData.NPCTypes table.")
            HelpDevsData.NPCTypes[k] = "" --collect NPC Type to table.
          end --if not table.contains(HelpDevsData.NPCTypes, k then)
        end --if getHelpDevs()
        local iterator = 1 --create iterator to use in loop below
        while selectString(k, iterator ) &gt; -1 do --select iterator detected room type
          --localCmdList = createCharacterCmdTable(tostring(iterator).." "..k) --create a table of commands to send to setPopup
          --setPopup("main", localCmdList, tecSettings.commandHelp) --make name clickable with a full list of optionspe clickable by the player, so they can walk to that room
          local popupCmds, popupHelp = createCharacterCmdTable(tostring(iterator).." "..k)
          setPopup("main", popupCmds, popupHelp)
          deselect() --dont forget your deselects
          iterator = iterator + 1 --increase loop's iterator
        end --if selectString(tmpCharacterType, 1 ) &gt; -1
      end --for pairs(tmpCharacterTable)
    end --if charactersInRoomList
  end --if checkType == series
  
end --function addLinksToCharacters()

--[[HelpDevsData.NPCTypes
walk into a room. NPCs and one PC
You arrive at a large square. An Iridine soldier, an Iridine soldier, an Iridine soldier, and Constable Zout are here.

look with multiple statuses
   &lt;/font&gt;&lt;font color="#000000"&gt;&lt;/font&gt;&lt;font color="#0020ff"&gt;An Iridine soldier&lt;/font&gt;&lt;font color="#000000"&gt;, &lt;/font&gt;&lt;font
color="#0020ff"&gt;an Iridine soldier&lt;/font&gt;&lt;font color="#000000"&gt;, and &lt;/font&gt;&lt;font color="#0020ff"&gt;an Iridine soldier&lt;/font&gt;&lt;font 
color="#000000"&gt; are standing here. &lt;/font&gt;&lt;font color="#0020ff"&gt;Constable Zout&lt;/font&gt;&lt;font color="#000000"&gt; is asleep here.
]]--</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>commandSuccessful(stringToCheck)</name>
					<packageName></packageName>
					<script>function commandSuccessful(stringToCheck)
  stringToCheck = stringTocheck or line --if user did not pass a string, check global line
  if type(stringToCheck) ~= "string" then --make certain a string was passed
    tecErrorNotification("function commandSuccessful, passed a non string variable. Received: "..tostring(stringToCheck).." expected a string.")
  end --if type(stringToCheck) ~= "string"
  
  local successChance, rolled = stringToCheck:match("Success: (%d+), Roll: (%d+)") --collect success rate and number rolled
  successChance = tonumber(successChance) --convert to a number
  rolled = tonumber(rolled) ----convert to a number
  debugToDisplay("function commandSuccessful, success chance: "..successChance.." Rolled: "..rolled)
  if rolled &gt; successChance then --if rolled is greated than the success chance
    return true --command successful
  else
    return false --comand failed
  end --if rolled &gt; successChance
end --function commandSuccessful()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>addLinksToObjects(checkType)</name>
					<packageName></packageName>
					<script>function addLinksToObjects(stringTocheck)
  stringToCheck = stringTocheck or line --if user did not pass a string, check global line
  if type(stringToCheck) ~= "string" then --make certain a string was passed
    tecErrorNotification("function addLinksToObjects, passed a non string variable. Received: "..tostring(stringToCheck).." expected a string.")
  end --if type(stringToCheck) ~= "string"

  if line:match("0020ff\"") then return end --this is a character line. Do not add object links to it.
  if objectLinksAdded then return end --if objects links were already added, do not add them.

  local checkedObjectsTable = {} --table to hold object names that have had links added
  local objectLine = line --create a copy of line to work with
  objectLine = objectLine:gsub(" and "," , ") --replace the word and with a comma to support rooms with only two objects
  for tmpObjectType in string.gmatch(objectLine, "(%P+%-?%P*)") do --look through line for anything between punctuation
    if not table.contains(checkedObjectsTable, tmpObjectType) then --if the object type has NOT been processed
      tmpObjectType = tmpObjectType:gsub("^%s","") --remove blank space from the begining of the string
      if not (tmpObjectType:match("^font$") or
              tmpObjectType:match("^font color$") or 
              tmpObjectType:match("^%x+$") or 
              tmpObjectType:match("^%s+$") or
              tmpObjectType:match("^$")) then --if the object type is one of these exactly it is junk data, so skip it.
        tmpObjectType = tmpObjectType:gsub("^an ","") --remove from the begining of the string
        tmpObjectType = tmpObjectType:gsub("^An ","") --remove from the begining of the string
        tmpObjectType = tmpObjectType:gsub("^A ","") --remove from the begining of the string
        tmpObjectType = tmpObjectType:gsub("^a ","") --remove from the begining of the string
        tmpObjectType = tmpObjectType:gsub(" is .*$","") --remove everything after " is ", this text is objects location description
        tmpObjectType = tmpObjectType:gsub(" are .*$","") --remove everything after " are ", this text is objects location description
        debugToDisplay("function addLinksToObjects setting links for "..tmpObjectType)
        checkedObjectsTable[tmpObjectType] = "" --add character type to the checkedObjectsTable
        if getHelpDevs() then --if player has help devs set collect room types
          if not table.contains(HelpDevsData.ObjectTypes, tmpObjectType) then --if tmpObjectType is not already in the HelpDevsData.ObjectTypes table
            debugToDisplay("function addLinksToObjects, adding "..tmpObjectType.." to HelpDevsData.ObjectTypes table.")
            HelpDevsData.ObjectTypes[tmpObjectType] = "" --collect name to table.
          end --if not table.contains(HelpDevsData.ObjectTypes, tmpObjectType)
        end --if getHelpDevs()
        local iterator = 1 --create iterator to use in loop below
        while selectString(tmpObjectType, iterator ) &gt; -1 do --select iterator detected room type
          setPopup("main", {
            [[send("look ]]..tostring(iterator).." "..tmpObjectType..[[")]],
            [[send("take ]]..tostring(iterator).." "..tmpObjectType..[[")]] },
            {"look at","take"})
          deselect() --dont forget your deselects
          iterator = iterator + 1 --increase loop's iterator
        end --if selectString(tmpObjectType, 1 ) &gt; -1
      end --if not (tmpObjectType:match("^font$") or tmpObjectType:match("^font color$") or tmpObjectType:match("^%x+$"))
    end --if not table.contains(checkedObjectsTable, tmpObjectType)
  end --for tmpObjectType in string.gmatch( line, "(%P+%-?%P*)" )

  objectLinksAdded = true --tell function that objectsLinks where added to this look command run

end --function addLinksToObjects()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI</name>
				<packageName></packageName>
				<script>--[[
for funtions that directly affect the clients GUI.

GUI

each window is added to tecGeyserWindows table via tecUIManagerRegisterWindow at startup.
Than in script "post initilization" they are loaded with UIManagerShowWindow("all", true)
to the UI manager being used.
Need to be able to not send UI manager windows that the user has removed.
Make table saveUIManagerSettings
saveUIManagerSettings[windowName].enabled saves if the window should be added to the UI manager is use.
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setMainWindowAutoWrap()</name>
					<packageName></packageName>
					<script>--set main window word wrap size.
--It is currently in the guiChange event function to be called when gui changes occur
function setMainWindowAutoWrap()

  local wrapAt = 0
  local leftSideWidth = 0
  local rightSideWidth = 0
    
  if tecSettings.showScrollBars then --if tecSettings.showScrollBars is true

    --get how many characters should appear on a line before word wrapping.
  	wrapAt = getColumnCount()
    
    displayDebug("setMainWindowAutoWrap: Wrap at: "..tostring(wrapAt) )

  else --if tecSettings.showScrollBar is false 
  
    --get average pilxelwidth of font used on main console.
    local fontWidth, fontHeight = calcFontSize(getFontSize())
  	--Get size of the entire window.
    local mainWidth, mainHeight = getMainWindowSize()
    
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
      --Get the width of left and right gui bars.
      leftSideWidth = GUIframe.topLeftContainer:get_width()
      rightSideWidth = GUIframe.topRightContainer:get_width()
    else
      tecWarningNotification("function, setMainWindowAutoWrap, leftSideWidth and "
        .."rightSideWidth are not properly initialized. UI Manager unknown.")
    end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    
    --Calculate how many characters can fit into main on average taking left and 
    --right GUI objects into consideration. Rounding down with math.floor
    wrapAt = math.floor(((mainWidth - leftSideWidth - rightSideWidth) / fontWidth) - 1)
    
  	--displays actual sizes to screen.
  	--display with setTECDebugMode(true)
  	--or command line debug on
  	displayDebug("setMainWindowAutoWrap: Font Width: "..tostring(fontWidth)
      .." Left side width: "..tostring(leftSideWidth).." Right side width: "..tostring(leftSideWidth)
      .." Main screen width: "..tostring(mainWidth)
      .." line wrap: "..tostring(wrapAt)
      .." Mains font sie: "..tostring(getFontSize())..".")
  
  end --if not tecSettings.showScrollBars
  
  --Set updated word wrap for main.
  setWindowWrap("main", tonumber(wrapAt))
  
end --end function setMainWindowAutowrap</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setInventoryFormater(setFormater)</name>
					<packageName></packageName>
					<script>function setInventoryFormater(setFormater)
  setFormater = setFormater or false
  tecFormatInventory = setFormater
end --function setInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getInventoryFormater()</name>
					<packageName></packageName>
					<script>function getInventoryFormater()
  return tecFormatInventory
end --function getInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser.Container:objectQuery()</name>
					<packageName></packageName>
					<script>function Geyser.Container:objectQuery(objectTable)
  --We are addding data to this table each loop.
  --We assume first run if a table is not passed. So we created the table.
  objectTable = objectTable or
    {name={}, type={}, parentName={}, xPos={}, yPos={}
    ,width={}, height={}, styleSheet={}}
  
  --windowList reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  --Loop through all children of this container.
  for k,v in pairs(self.windowList) do
      if k ~= self then --if the key is not this geyser object
    		  objectTable = v:objectQuery(objectTable) --query that object.
      end --end if k not = self check
  end --end for loop pair(self.windowlist)
  
--[[this.object logic can SEEM confusing. It's not.
At this point we have reach the 'bottom' of ourcontainer query.
So the last child with the last alphabetical name.
We insert our object data. Than return it. Meaning this now occurs for the second to
the last geyser object, and so on until we reach the parent that called the query.]]--
  
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#debugc
  --debugc("Geyser.Container:objectQuery: Inserting Object data for: "..self.name)
  
  --Collect this object data.
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html
  table.insert(objectTable.name, tostring(self.name))
  table.insert(objectTable.type, tostring(self.type))
  table.insert(objectTable.parentName, tostring(self.parent))
  table.insert(objectTable.xPos, tostring(self:get_x()))
  table.insert(objectTable.yPos, tostring(self:get_y()))
  table.insert(objectTable.width, tostring(self:get_width()))
  table.insert(objectTable.height, tostring(self:get_height()))
  --if there is a custom style sheet. Record it.
  if self.styleSheet then
    table.insert(objectTable.styleSheet, tostring(self.styleSheet)) 
  else
    table.insert(objectTable.styleSheet, false)
  end

  return objectTable --return the table to the object that called this object
  
end --Geyser.Container:objectQuery(objectTable)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRedrawLabels()</name>
					<packageName></packageName>
					<script>--Tracks down the labels in this project, and reapplies the default stylesheet
function tecRedrawLabels()

  debugToDisplay("Labels redraw started.")

  tecConfigThemes() --redo themes data. something likely changed

  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
    --Create table to store all geyser objects within GUIframe
    ContainerDataTable = { 
      GUIframe.bottomRightContainer:objectQuery(),
      GUIframe.topLeftContainer:objectQuery(),
      GUIframe.bottomLeftContainer:objectQuery(),
      GUIframe.bottomContainer:objectQuery(),
      GUIframe.topRightContainer:objectQuery(),
      GUIframe.topContainer:objectQuery(),
      GUIframe.topLeftTabs:objectQuery(),
      GUIframe.topRightTabs:objectQuery(),
      GUIframe.bottomLeftTabs:objectQuery(),
      GUIframe.bottomRightTabs:objectQuery() }
  else --no UI manager specified.
    tecWarningNotification("function tecRedrawLabels, UI manager not specified. "
      .."Making containerDataTable a blank table.")
    ContainerDataTable = {}
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    
  --Go through all the table we created above
  for key,cdt in pairs(ContainerDataTable) do
    for k,v in ipairs(cdt.type) do --Check the types of containers
      if v == "label" then --To see if it is a label
      --display(ContainerDataTable[key])
        if cdt.styleSheet[k] then --if the label has a default styleSheet use it
          setLabelStyleSheet(cdt.name[k], cdt.styleSheet[k]) --set this label to its custom styleSheet
          debugToDisplay(cdt.name[k].." custom styleSheet used.\n\t"..cdt.styleSheet[k])
        elseif "map" == cdt.name[k]:match("map") then --if map label is found, skip
          --debugToDisplay("\t"..cdt.name[k].." is a map label no redraw logic in this client release.")
        elseif "Compass." == cdt.name[k]:match("Compass.") then
--          debugToDisplay("\t"..cdt.name[k].." is a Compass label no redraw logic in this client release.")
--          if cdt.name[k] == "tecCompass.back" then --if the label is the background of the compass
--            setLabelStyleSheet(cdt.name[k], labelsStyle)
--            debugToDisplay("\t"..cdt.name[k].." back of Compass applying standard label.")
--          end --if cdt.name[k] is tecCompass.back
        --if label has the word tab in it, we treat it as a tab  
        elseif "tab" == cdt.name[k]:match("tab") or "Tab" == cdt.name[k]:match("Tab") then
          local tabNameFound = false
          --loop though table containing tab names
          for iterator, tabName in ipairs(tecTabNames) do
            --if the tab name was found record that it was
            if tabName == cdt.name[k] then tabNameFound = true end 
          end --for ipairs(tecTabNames)
          --if the tab name was not found inthe tabname table, insert it.
          if not tabNameFound then table.insert(tecTabNames, cdt.name[k]) end
          setLabelStyleSheet(cdt.name[k],tabsStyle)
          local tmpTabName= cdt.name[k]:gsub("Tab", "") --remove Tab from name
          local tmpTabName= tmpTabName:gsub("tab", "") --remove tab from name
          local tmpTabName= tmpTabName:gsub("tecComWindows.", "") --remove tecComWindows from name
          echo(cdt.name[k], tabsFontStyle..tmpTabName) --echo name onto the tab
          --debugc("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." is a tab or Tab label. Setting tabsStyle style sheet.")
          
        else --Reapply default style sheets to all other labels.
          setLabelStyleSheet(cdt.name[k], labelsStyle)
          --debugc("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          debugToDisplay("\t"..cdt.name[k].." standard label, setting labelsStyle style sheet.")
          
        end --if check label types.
        --debugc("\tTable type: "..v.." key: "..k)
      end --if cdt.type is label
    end --for cdt
  end --for ContainerDataTable
  
  debugToDisplay("Labels redraw completed.")
  
end --function tecRedrawLabels()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecSetScrollBars(mode)</name>
					<packageName></packageName>
					<script>--Enables or disables scrollbars throughout the project.
--Providing an option to save so scroll bars will not appear automatically
function tecSetScrollBars(mode, displayToScreen)
  mode = fuzzyBoolean(mode) --verifies mode.
  displayToScreen = fuzzyBoolean(displayToScreen)
  mode = mode == nil and true or mode
  displayToScreen = displayToScreen == nil and true or displayToScreen
  tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
  
  debugToDisplay("Setting Scrollbars: ")
  
  if mode then
    --if enabling, com windows only. Settings &amp; Room Character use tecScrollBarCheck
    for index, windowName in ipairs(tecComWindows.tabs) do
      enableScrollBar(windowName)
      debugToDisplay("\tEnabling scroll bar for: "..windowName)
      --debugc("Enabling scroll bar for: "..windowName)
    end --for tecTextWindowNames
    tecSettings.showScrollBars = true --tell further gui changes to show scrollbars
    --if using GUIframe manager and it is initialized
    if GetUIManager() == "GUIframe" and GUIframe.initialized then
      setBorderRight(GUIframe.topRightContainer:get_width())
    else --no UI manager specified.
      tecWarningNotification("function tecSetScrollBars, UI manager no specified. "
        .."Right border set set.")
    end --if GetUIManager() == "GUIframe" and GUIframe.initialized
    if displayToScreen then
      pecho("Enabled scrollbars. "
        .."Some windows will not show their scrollbars until there is enough text "
        .."to need to scroll the window.\n")
    end --if displayToScreen
  else
      --disable scrollbars for all windows.
      for index, windowName in ipairs(tecTextWindowNames) do
        disableScrollBar(windowName)
        debugToDisplay("\tDisabling scroll bar for: "..windowName)
        --debugc("Disabling scroll bar for: "..windowName)
      end --for tecTextWindowNames
      tecSettings.showScrollBars = false --tell further gui changes to hide scrollbars
      setBorderRight(-16) --hide the scroll bar off the screen
      setMainWindowAutoWrap() --Adjust mains autowrap now that main has changed.
      if displayToScreen then
        pecho("Disabled scrollbars. "
          .."You will need to scroll with your mouse wheel or page up page down keys. "
          .."Main console scrollbar will reappear while moving windows.\n")
      end --if displayToScreen

  end --if mode
  
  debugToDisplay("Completed setting scroll bars.")
  
  if displayToScrenn then dontForgetToSave() end --If player ran command remind them to save.
  
end --tecSetScrollBar</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecScrollBarCheck(tecConsoleName)</name>
					<packageName></packageName>
					<script>--automatically enable a console scroll bar if it can not fit the text in it
--This works best if it is in a "sysWindowResizeEvent" function to controll the 
--drawing of a gui object.
function tecScrollBarCheck(tecConsoleName)
  tecConsoleName = tecConsoleName or "main"
  local tecSettingsRowCount = getRowCount(tecConsoleName)
  --if the window can not contain the rows of text.
  if tecSettingsRowCount &lt; getLastLineNumber(tecConsoleName) then
    --if user is allowing scroll bars, enable the scroll bar.
    if tecSettings.showScrollBars then enableScrollBar(tecConsoleName) end
  else --The window can contain the text.
    disableScrollBar(tecConsoleName)
  end --if tecSettingsRowCount less than text rows in that window.
end --function tecScrollBarCheck</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser Tooltip</name>
					<packageName></packageName>
					<script>--References for this script
--label echo| https://www.mudlet.org/geyser/files/geyser/GeyserLabel.html
--calculate window width| https://wiki.mudlet.org/w/Manual:Lua_Functions#string.len.2C_utf8.len
--Timers https://wiki.mudlet.org/w/Manual:Timer_Engine

function configTooltips()
  if not tooltips then --if tooltips table has not been created
    tooltips = {}
    tooltips.fontSize = 10 --size of the font that will appear in the Tooltip
    tooltips.timeout = 2 --how long tip stays active after mouse leaves label
    tooltips.name = "Tooltip" --name of the label
    tooltips.fontfamily = "Arial"
    tooltips.styleSheet = [[
     background-color: "#aadddd99";
     border: 2px solid #555533;
     font-family: ]]..tooltips.fontfamily..[[;
     ]]
    local _, ttTextHeight = calcFontSize(tooltips.fontSize, tooltips.fontfamily) --get width of a single font character
    tooltips.height = ttTextHeight + 8 --Height of the tool tip.
  end --if not tooltips
end --function configTooltips()
if tooltips then
  tooltips[tooltips.name] = nil
  tooltips = nil
end --Reset project data on save, so changes above are reflected after saving.

--Apply message and resize label
local function resizeToolTiplabel(TooltipText)
  --Write message on tooltip label
  tooltips[tooltips.name]:echo(TooltipText,"black","c"..tostring(tooltips.fontSize))
  local ttTextWidth, ttTextHeight = calcFontSize(tooltips.fontSize, tooltips.fontfamily) --get width of a single font character
  local toolTextLabelWidth = ttTextWidth * (utf8.len(TooltipText) + 2) --calc width of the Tooltip label
  tooltips[tooltips.name]:resize(toolTextLabelWidth, tooltips.height) --Resize tool tip to fit TooltipText
  
  if getTECDisplayDebugMode then --if display debug is enabled.
    local Pos_X, Pos_Y = getMousePosition()
    local tmpMainWidth, tmpMainHeight = getMainWindowSize()
    displayDebug("function moveTooltip, Right side of tool tip label: "
      ..(Pos_X + tooltips[tooltips.name]:get_width())
      .." main window width: "..tmpMainWidth
      .." Pos_X: "..Pos_X.." tooltip label width: "..tooltips[tooltips.name]:get_width()
      .." Width the tooltip label should be: "..toolTextLabelWidth
      .."\n\tHeight of the tooltip should be: "..tooltips.height.." Height of the tooltip is: "..tooltips[tooltips.name]:get_height())
  end --if getTECDisplayDebugMode
end --function resizeToolTipLabel

local function moveTooltip(Pos_X, Pos_Y, TooltipText)
  if not Pos_X or not Pos_Y or not TooltipText then --if data collection error occured
    debugc("function, moveTooltip: data collection error.")
    return --end call function will have unwanted outcome.
  end --if not Pos_X or not Pos_Y or not TooltipText
  local tmpMainWidth, tmpMainHeight = getMainWindowSize()
  
  resizeToolTiplabel(TooltipText) --Apply message and resize label
 
  --move tooltip label. Preventing it from scrolling out of the mudlet window where it can not be drawn
  if Pos_Y &gt; tooltips.height then --If the mouse is NOT at the top of the window
    --if the tooltip would go off the screen
    if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth then
      --if the tooltip would go off the right side of the screen
      Pos_X = Pos_X - tooltips[tooltips.name]:get_width()
    end --if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth
    tooltips[tooltips.name]:move(Pos_X+5, (Pos_Y-tooltips.height-5)) --position tooltip just above mouse
  else --if the mouse is at the top of the screen
    --if the tooltip would go off the right side of the screen
    if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth then
      --Draw tooltip label to the left of the cursor
      Pos_X = Pos_X - tooltips[tooltips.name]:get_width()
    end --if Pos_X + tooltips[tooltips.name]:get_width() &gt; tmpMainWidth
    tooltips[tooltips.name]:move(Pos_X+5, (Pos_Y+tooltips.height+5)) --position tooltip just below the mouse
  end --if Pos_Y &gt; tooltips.height else

  raiseWindow(tooltips.name) -- make certain Tooltip stays on top of other labels.
  showWindow(tooltips.name) --show tool tip
end --function moveTooltip

function trackTooltip(TooltipText)
  configTooltips() --configures tooltip table if it is not already
  local Pos_X, Pos_Y = getMousePosition()
  if tooltips.timer then --if the timer exists.
    killTimer(tooltips.timer) --delete the timer to reset it at end of this function
    tooltips.timer = nil
  end--if tooltips.timer
  
  if tooltips[tooltips.name] then --if the tool tip has previously been created
    moveTooltip(Pos_X, Pos_Y, TooltipText)
  else --if the tool window has not been created.
    --create tooltip label, we will reuse this same label by moving it and hiding it.
    tooltips[tooltips.name] = Geyser.Label:new({
      name = tooltips.name,
      x = Pos_X + 5,
      y = Pos_Y - tooltips.height,
      height = tooltips.height,
      fgColor = "#000000",
      })
    resizeToolTiplabel(TooltipText) --Apply message and resize label
    setLabelStyleSheet(tooltips.name, tooltips.styleSheet)
    enableClickthrough(tooltips.name) --Do not allow label to be clicked.
    raiseWindow(tooltips.name) -- make certain Tooltip stays on top of other labels.
  end --if Tooltip
tooltips.timer = tempTimer(tooltips.timeout, [[deleteTooltip()]]) --delete tip after x+1 seconds.
end --function createTooltip(TooltipText)

function deleteTooltip()
  hideWindow(tooltips.name) --hide the tooltip label.
  killTimer(tooltips.timer) --delete the completed timer.
  tooltips.timer = nil --remove the timer ID
end

--easy method to create tool tip timer.
function SetTooltip(labelNeedingToolTip, TooltipText)
  --labelNeedingToolTip is the name of the geyser label that needs a tooltip
  --TooltipText is text to put on the tooltip label

  --occurs when mouse hovers over geyser object that needs a tool tip.
  setLabelOnEnter(labelNeedingToolTip, "trackTooltip", TooltipText)
  --hide tooltip immediately after the mouse leaves label the tool tip is for.
  --setLabelOnLeave(geyserObjectNeedingToolTip, "DeleteTooltip")
  --track mouse movement when cursor is over label.
  setLabelMoveCallback(labelNeedingToolTip, "trackTooltip", TooltipText)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getPercentOfMainWindow(percent)</name>
					<packageName></packageName>
					<script>--Returns the percent of width and height of the main window
local function getPercentOfMainWindow(percent)
	local mainWidth,mainHeight = getMainWindowSize()
	--turn number into a percent
	percent = tonumber(percent) * .01
	--return window size in %
	return (mainWidth * percent), (mainHeight * percent)
end --function getPercentOfMainWindow</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaSetImages()</name>
					<packageName></packageName>
					<script>--displays message that helps players easily find the image types that can be set with parthiaSetImages
local function localImageTypeHelp()
  pecho("Supported commands to change images in Parthia are:\n")
  for _, imageTypeValue in pairs(tecSettings.images) do
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display images "..imageTypeValue.name.." list", 
      [[parthiaSetImages("]]..imageTypeValue.name..[[","list", true)]],
      "List images for "..imageTypeValue.name, true)
    pecho(" list images available for "..imageTypeValue.name..".\n")
  end --for pairs(tecSettings.images)
end --function localImageTypeHelp()

--allows player to change or add images throughout the client.
--imageType is compassBackground compassOverlay and other windows with images 
--fileName is the name of the file in the directory that is affiliated to the imageType
--displayToScreen controls if the player sees a message when this is run
function parthiaSetImages(imageType, fileName, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --make certain data type is correct.
  if imageType then --if a first argument was received
    if type(imageType) ~= "string" then --if argument one is not a string
      tecErrorNotification("function parthiaSetImages, imageType argument one is a non string variable.")
    end --if type(imageType) ~= "string"
  else --not sent an imageType
    if displayToScreen then localImageTypeHelp() end --show help message if displayToScreen is true
  end --if imageType
  if fileName then --if a second argument was received
    if type(fileName) ~= "string" then --if argument two is not a string
      tecErrorNotification("function parthiaSetImages, fileName argument two is a non string variable.")
    end --if type(fileName) ~= "string"
  else --was not sent a fileName
    fileName = "list" --set it to anything really so it displays a help message
  end --if fileName
  
  imageType = imageType:lower() --make certain imageType is lower case.
  local imageFolder = "" --will contain file path to images for the imageType
  local imageTypeCorrect = false --used to verify that a useable imageType was passed
  local imageTableKey = "" --used to record the key for the tecSettings.images for the imageType needed

  --now create a table to hold references to windows we want to work with.
  --We do this so we can call functions like :setStyleSheet with ease.
  --If we store 
  local imageWindowsReferenceTable = {} --table to hold references to windows that this function may need to work with.
  for imageTableName, imageTable in pairs(tecSettings.images) do --create sub tables to organize the windows
    imageWindowsReferenceTable[imageTableName] = {}
    imageWindowsReferenceTable[imageTableName].windows = {}
  end
    
  --add references to windows if the windows exist.
  if tecCompass.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.compassBackground.windows, tecCompass.back) 
  end --if tecCompass.back then
  if MultiWindow.Compass.back then
    table.insert(imageWindowsReferenceTable.compassBackground.windows, MultiWindow.Compass.back)
  end --if tecCompass.back then
   
  if tecCompass.overlay then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.compassOverlay.windows, tecCompass.overlay)
  end --if tecCompass.back then
  if MultiWindow.Compass.overlay then
    table.insert(imageWindowsReferenceTable.compassOverlay.windows, MultiWindow.Compass.overlay)
  end --if tecCompass.back then
  
  if tecMap_back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.mapBackground.windows, tecMap_back)
  end --if tecMap_back then
  
  if MultiWindow.macroMenu.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.macroBackground.windows, MultiWindow.macroMenu.back)
  end --if MultiWindow.macroMenu.back then

  if hpbar.front then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.healthBar.windows, hpbar.front)
  end --if hpbar.front then
  if MultiWindow.hpbar.front then
    table.insert(imageWindowsReferenceTable.healthBar.windows, MultiWindow.hpbar.front)
  end --if MultiWindow.hpbar.front then  
  if hpbar.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.healthBackground.windows, hpbar.back)
  end --if hpbar.back then
  if MultiWindow.hpbar.back then
    table.insert(imageWindowsReferenceTable.healthBackground.windows, MultiWindow.hpbar.back)
  end --if MultiWindow.hpbar.back then
  
  if fatiguebar.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.fatigueBackground.windows, fatiguebar.back)
  end --if fatiguebar.back then
  if MultiWindow.fatiguebar.back then
      table.insert(imageWindowsReferenceTable.fatigueBackground, MultiWindow.fatiguebar.back)
  end --if MultiWindow.fatiguebar.back then
  
  if fatiguebar.front then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.fatigueBar.windows, fatiguebar.front)
  end --if fatiguebar.front then
  if MultiWindow.fatiguebar.front then
    table.insert(imageWindowsReferenceTable.fatigueBar.windows, MultiWindow.fatiguebar.front)
  end --if MultiWindow.fatiguebar.front then
  
  if hungerbar.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.hungerBackground.windows, hungerbar.back)
  end --if hungerbar.back then
  if MultiWindow.hungerbar.back then
    table.insert(imageWindowsReferenceTable.hungerBackground.windows, MultiWindow.hungerbar.back)
  end --if MultiWindow.hungerbar.back then
  
  if hungerbar.front then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.hungerBar.windows, hungerbar.front)
  end --if hungerbar.front then
  if MultiWindow.hungerbar.front then
    table.insert(imageWindowsReferenceTable.hungerBar.windows, MultiWindow.hungerbar.front)
  end --if MultiWindow.hungerbar.front then
  
  if encumbrancebar.back then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.encumbranceBackground.windows, encumbrancebar.back)
  end --if encumbrancebar.back then
  if MultiWindow.encumbrancebar.back then
    table.insert(imageWindowsReferenceTable.encumbranceBackground.windows, MultiWindow.encumbrancebar.back)
  end --if MultiWindow.encumbrancebar.back then
  
  if encumbrancebar.front then --if the label exists add a reference to it to the windows table
    table.insert(imageWindowsReferenceTable.encumbranceBar.windows, encumbrancebar.front)
  end --if encumbrancebar.front then
  if MultiWindow.encumbrancebar.front then
    table.insert(imageWindowsReferenceTable.encumbranceBar.windows, MultiWindow.encumbrancebar.front)
  end --if MultiWindow.encumbrancebar.front then

  --check if imageType is correct
  --tecSettings.images is in the variables script, stores default settings and directories for imageTypes
  for imageTableName, imageTable in pairs(tecSettings.images) do
    --if the image type is correct make an ifelse series, to set imageFolder variable
    debugToDisplay("function parthiaSetImages, checking imageTypeKey.name: "..imageTable.name.." against imageType: "..imageType)
    if imageTable.name == imageType then --found a match for imageTType in tecSettings.images table
      debugToDisplay("function parthiaSetImages, image type match found.")
      imageFolder = imageTable.folder
      imageTypeCorrect = true --used to tell function the correct imageType was found
      imageTableKey = imageTableName --keep track of the key to use when checking what window to update the styleSheet for
      break --found what we are looping for break loop and move on.
    end --if imageTypeKey.name == imageType
  end --for pairs(tecSettings.images)
  
  --if the image type is incorrect we can not continue. Show message to screen if player sent command.
  if not imageTypeCorrect then --imageType argument one is incorrect
    if displayToScreen then localImageTypeHelp() end --show help message if displayToScreen is true
    return --stop function a correct imageType is required
  end --if not imageTypeCorrect
  
  local localFilesFound = parthiaFileList(imageFolder) --collect list of files in the directory
  
  if localFilesFound then --if files are found in imageType's directory
    if table.contains(localFilesFound, fileName) then --check if fileName is in the imageType's directory
      debugToDisplay("function parthiaSetImages, setting tecSettings.images."..imageTableKey..".image to "..imageFolder..fileName)
      
      if tecSettings.images[imageTableKey] then --if the images type exists in the images table
        tecSettings.images[imageTableKey].image = imageFolder..fileName --allows settings to be saved to file.
        
        if imageTableKey == "tabs" then --no method to manually assemble tabs label references, letting tecRedrawLabels do tabs.
          tecRedrawLabels() --redraw all labels in project.
        else --for all other labels we can track them, so adjust for them specifically.
          if not imageWindowsReferenceTable[imageTableKey] then tecErrorNotification("function parthiaSetImages, "..imageTableKey" missing from  imageWindowsReferenceTable.") end
          for _, imageLabel in pairs(imageWindowsReferenceTable[imageTableKey].windows) do
            if imageLabel.styleSheet then --if this label has an existing styleSheet
              imageLabel.styleSheet = imageLabel.styleSheet:gsub("[^;]-;",[[border-image: url("]]..tecSettings.images[imageTableKey].image..[[");]],1) --repace the first line of the style sheet with border image for this label
            else --this label lacks an existing styleSheet
              imageLabel.styleSheet = [[border-image: url("]]..tecSettings.images[imageTableKey].image..[[");]]
            end --if imageLabel.styleSheet
            imageLabel:setStyleSheet(imageLabel.styleSheet) --set the new styleSheet for this label
          end --for pairs(tecSettings.images[imageTableKey].windows)
        end --if imageTableKey == "tabs"
      else --image label is not in the tecSettings.images table
        tecErrorNotification("function parthiaSetImages, table tecSettings.images missing imageType after initial error checking.")
      end --tecSettings.images[imageTableKey]
      dontForgetToSave()
    else --fileName is not in tabs directory, check for commands that are not image names or display help message
      if fileName:lower() == "add" then --player sent add as argument
        pecho("If your image looks poor, try lowering the compression level of the image.\n"
          .."To open svg files use ")
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;inkscape.", 
          [[openUrl("https://inkscape.org/")]], --runs on click.
          "Open inkscape website. ", true)
        pecho("\nFor all other image types use ")
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;GIMP.", 
          [[openUrl("https://www.gimp.org/")]], --runs on click.
          "Open GIMP website. ", true)
        pecho("\nChanges you make to existing images will be removed with each Parthia update. If you would like to update an existing image, create a copy and make changes on the copy.")
        tecOpenDirectory(imageFolder) --opens folder of the image type the player is tring to add to
      else --unsupported argument sent. Display list of supported commands for this imageType
        pecho("Supported commands to change "..imageType.." image are:\n")
        for i,file in ipairs(localFilesFound) do --loop through files found in imageType's folder
          --make command for cechoLink
          local cmdToSend = [[parthiaSetImages("]]..imageType..[[","]]..file..[[")]] --command to send when player clicks echoLink
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display images "..imageType.." "..file, 
            cmdToSend, --runs on click.
            "Set "..imageType.." image to "..file, true)
          pecho("\n\t^Set "..imageType.." image to "..file.."\n")
        end --for ipairs(localFilesFound)
        
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display images "..imageType.." add", 
          [[parthiaSetImages("]]..imageType..[[","add")]],
          "Open "..imageType.." images folder", true)
        pecho(" open the folder for "..imageType.." to add your custom images to.\n")
        pecho("Click a command above or type it into the command line.\n")
      end --if fileName:lower() == "add"
    end --table.contains(localFilesFound, fileName)
  else --not files found in the imageType's folder, provide an option to repair
    pecho("No files found in the "..imageType.." directory.\n"
      .."This can likely be resolved by running ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia repair", 
      [[expandAlias("parthia repair")]],
      "Repair Parthia", true)
    pecho("\nIf the issue continues please report it with ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug report issue", 
  	 [[tecReportIssues()]], 
  	 "Report client issues", true)
     echo("\n")
  end --if localFilesFound
end --parthiaSetImages()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>findLabelMaxFontSize(labelToCheck)</name>
					<packageName></packageName>
					<script>--[[
Retreives the max font size that will fit into a label. According to height.

Usage pass a label and it returns a itiger
fontsize = findLabelMaxFontSize(labelGeyserContainer)
]]--
function findLabelMaxFontSize(labelToCheck)
  if type(labelToCheck) ~= "table" then
    tecErrorNotification("function findLabelMaxFontSize, expected a label receive a "..type(labelToCheck))
  end --if type(labelToCheck) ~= "table"
  
  local labelHeight = labelToCheck:get_height() --collect height of label
  local textFontSize = 4 --set a starting font size
  local _, textHeight = calcFontSize(textFontSize, "Arial") --get height of font in pexels
  
  while textHeight &lt; labelHeight do --loop until the text height is larger than the label height
    debugToDisplay("function findLabelMaxFontSize, checking font size "..textFontSize
      ..", text height: "..textHeight..", label height: "..labelHeight)
    textFontSize = textFontSize + 1
    _, textHeight = calcFontSize(textFontSize, "Arial") --get height of font in pexels
    if textFontSize &gt; 40 then --stop checking if we reach font 40
      tecWarningNotification("function findLabelMaxFontSize, reached max font size of 40. Loop stopped.") 
      break --stop this loop
    end --if textFontSize &gt; 40
  end --while textHeight &lt; labelHeight
  
  debugToDisplay("function findLabelMaxFontSize, returning font size "..textFontSize)
  return textFontSize --return the max font size function found
end --function findLabelMaxFontSize(lableName)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>resizeLabelText(labelToCheck, maxFontSize, textColor, textFormat)</name>
					<packageName></packageName>
					<script>--[[
Resizes text on a label according to the label's height
intended for labels with text that are being resized.

required argument labelToCheck, a reference of the getMapLabels
optional argument maxFontSize is maximum font size 20 is used if none is present
optional argument textColor, the color of the text. If non is specified black is used
optional argument text format a label echo compatible text format reference at: https://www.mudlet.org/geyser/files/geyser/GeyserLabel.html#Geyser.Label:echo

Usage example
resizeLabelText(encumbrancebar, 14, "black", "cb")
]]--
function resizeLabelText(labelToCheck, maxFontSize, textColor, textFormat)
  --make certain the arguments passed are good.
  if type(labelToCheck) ~= "table" then
    tecErrorNotification("function resizeLabelText, argument 1 expected a label receive a "..type(labelToCheck))
  end --if type(labelToCheck) ~= "table"
  maxFontSize = maxFontSize or 20
  if type(maxFontSize) ~= "number" then
    tecErrorNotification("function resizeLabelText, argument 2 expected a number receive a "..type(maxFontSize))
  end --if type(maxFontSize) ~= "number"
  textColor = textColor or "black"
  if type(textColor) ~= "string" then
    tecErrorNotification("function resizeLabelText, argument 3 expected a string receive a "..type(textColor))
  end --if type(textColor) ~= "string"
  textFormat = textFormat or ""
  if type(textFormat) ~= "string" then
    tecErrorNotification("function resizeLabelText, argument 4 expected a string receive a "..type(textFormat))
  end --if type(textColor) ~= "string"
  if labelToCheck.text then labelToCheck = labelToCheck.text end --if this is a guage 
  if not labelToCheck.message then
    tecErrorNotification("function resizeLabelText, label requires the label have a message none was found.")
  end --if not labelToCheck
  
  local labelFontSize = findLabelMaxFontSize(labelToCheck) --get the max font size that can fit the height of this label
  if labelFontSize &gt; maxFontSize then labelFontSize = maxFontSize end --if the font size would be larger than the desired max, set it to max size
  labelToCheck:echo(labelToCheck.message,textColor,textFormat..labelFontSize) --write name on the label
  
end --function resizeStatusText(statusBars)</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>UIManager</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>SetUIManager(UIManagerName, displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
Set UI manager mode.
Usage:
SetUIManager(UIManagerName, displayToScreen)
UIManagerName a string, the name of the UI manager you would like to set. IE: "GUIframe". Not case sensetive.
displayToScreen, true displays progress to screen, false does not.
]]--
function SetUIManager(UIManagerName, displayToScreen)
  --add UI managers in UIManagers table in the variables script.
  
  --Varify arguments are good.
  mode = fuzzyBoolean(mode) --true enables GUIFrame usage false disables it
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  local UIManagerNameCorrect = false --used later to verify correct argument sent.
  local UIManagerNameList = "" --used later to list good names in event of an error.
  if type(UIManagerName) ~= "string" then --if objectName is not a string
    tecErrorNotification("function SetUIManager, first argument is a: "
    ..type(UIManagerName).." string was expected. Use UI manager name IE: GUIframe") 
  end --if type(objectName) ~= "string"
  
  --verify correct UI manager name sent.
  for iterator, UIManager in ipairs(UIManagers) do
    if UIManager:lower() == UIManagerName:lower() then --if names match
      debugToDisplay("\tFound objectName match "..UIManagerName:lower())
      UIManagerNameCorrect = true --notify error catch, correct name sent
      UIManagerName = UIManager --Correct case sensitivity.
    end --if UIManager:lower() == UIManagerName:lower()
    UIManagerNameList = UIManager..", " --collect list of UI managers to display on error.
  end --for pairs(UIManagers)
  
  --manager name is incorrect send supported commands to player
  if not UIManagerNameCorrect then --if the wrong name was sent.
    if displayToScreen then
      pecho("User Interface managers or display manager commands are: ")
      for iterator, UIManager in ipairs(UIManagers) do --get UI manager names to click.
        local cmdToSend = [[SetUIManager( "]]..UIManager..[[",true)]] --make commandfor cechoLink
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display manager "..UIManager, 
          cmdToSend, --runs on click.
          "Set UI manager.", true)
        --add proper punctuation.
        if iterator &lt; (#UIManagers - 1) then cecho(", ") elseif iterator == (#UIManagers - 1) then pecho(" and ") end
      end --for ipairs(UIManagers)
      cecho(".\n")
      return --stop process error found
    else --if this is not being displayed to screen
      tecErrorNotification("function SetUIManager, incorrect name sent. Please use "
        .."supported names: "..UIManagerNameList)
      return --stop process error found
    end --if displayToScreen
  end --if not UIManagerNameCorrect
  
  debugToDisplay("function SetUIManager, started. UIManagerName is: "..UIManagerName
    .." displayToScreen is: "..tostring(displayToScreen))

  if UIManagerName == "GUIframe" then --if true is sent enable GUIframe
    tecSettings.useGUIframe = true
    pecho("UI manager set to GUIframe. Please restart.\n")
    tecFileSaveSettings(displayToScreen) --force a save
  elseif UIManagerName == "none" then
    tecSettings.useGUIframe = false
    setBorderSizes(0,0,0,0)
    pecho("disabled all UI managers. Please restart.\n")
    tecFileSaveSettings(displayToScreen) --force a save.
  else --if it was false disable GUIframe
    tecErrorNotification("function SetUIManager, incorrect UI Manager name after "
      .."error checking.")
    return --stop process error found
  end -- UIManagerName == series.
end --function tecSetGUIFrameMode(mode)
--SetUIManager("farts", true)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>GetUIManager()</name>
						<packageName></packageName>
						<script>--[[
Returns string name of UI manager in use or "none" if no UI manager is being used.
]]--
function GetUIManager()
  if tecSettings.useGUIframe then --using GUIframe UI manager
      return "GUIframe" --using GUIframe manager
  else 
    return "none"
  end --no UI manager found.
end --function GetUIManager
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerClearMainWindow()</name>
						<packageName></packageName>
						<script>--There is either a bug or clear working as intended.
--If we clear main. geyser objects that adopt it's background color via getBgColor
--it will error out.

function UIManagerClearMainWindow()

  --backup background color
	local br,bg,bb = getBgColor()
	
  --clear main
  clearWindow()

  --set mains background to eat it was.
	setBgColor(br,bg,bb)
	echo(" \n") --We need a line of text on the screen for getBgColor to copy from.
	
end --end function UIManagerClearMainWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerTestWindow(objectName, displayToScreen)</name>
						<packageName></packageName>
						<script>--tests if objectName is correct. If it is it returns a correctly
--capitalized objectName. If it is bad, it returns false.
function UIManagerTestWindow(objectName, displayToScreen)

  local tecWindowExists = false --used to see if objectName matches a window name.

  --Varify arguments are good.
  if type(objectName) ~= "string" then --if objectName is not a string
    tecErrorNotification("\tfunction UIManagerTestWindow, first argument is a : "
    ..type(objectName).." string was expected. Use object name IE \"Compass\"") 
    return false --end process it can not continue.
  end --if type(objectName) ~= "string"
  
  --if there are no geyser containers in tecGeyserWindows table.
  if next(tecGeyserWindows) == nil then
    tecWarningNotification("\tfunction UIManagerTestWindow, no geyser "
      .."containers in the tecGeyserWindows table. No geyser containers managed "
      .." by UI manager.")
    return false --stop to function there are no geyser containers to add to UI manager
  end --if #tecGeyserWindows == 0
  
  local tecWindowNameList = "" --will be used to list window names
  for windowName, window in pairs(tecGeyserWindows) do--loop through containers
    --if name was not specified, use the windowName in its place.
    if not window.name then 
      tecWarningNotification("function UIManagerTestWindow, name was not "
        .."specified for "..windowName.." using it's window name instead.")
      tecGeyserWindows[windowName].name = windowName 
    end --if not window.name
    if objectName:lower() == window.name:lower() then --if names match
      debugToDisplay("\tfunction tecTestUIManager, Found objectName match "..window.name:lower())
      tecWindowExists = true --notify error catch, correct name sent
      objectName = window.name --Correct case sensitivity.
    end --if objectName:lower() == window.name:lower()
    tecWindowNameList = tecWindowNameList..window.name..", " --List windows in 1 string
  end --while ipairs(tecWindowNames)tecWindowNames
  
  --check if argument passed is "all" for all windows.
  if objectName:lower() == "all" then
    debugToDisplay("\tfunction UIManagerTestWindow, Found objectName match \"all\"")
    tecWindowExists = true --notify error catch, correct name sent
    objectName = "all" --Correct case sensitivity.
  end --if objectName:lower() == "all"
  
  if not tecWindowExists then --window name does not exist.
    if displayToScreen then
    else
      tecErrorNotification("\tfunction UIManagerTestWindow, "
        .."window name: "..objectName.." not found in tecWindowNames table. "
        .."Please send a supported name. Supported names are: "..tecWindowNameList
        .."and all.")
    end --if displayToScreen
    debugToDisplay("\tfunction UIManagerTestWindow, failed to find GUIframe name matching: "..objectName)
    return  false
  end --if not tecWindowExists

  return objectName --no errors found
end --function UIManagerTestWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerShowWindow(objectName, mode, displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
control what geyesr objects show in the current UI manager.
You must first add a geyser object to tecGeyserWindows table 
To add a geyser object to the tecGeyserWindows table refer to: tecConfigGeyserWindows(clear)
objectName is the name of the geyser object.
Mode is true if you would like to add the geyser object the current UI manager
mode is false if you would like to remove the geyser object from the current UT manager
displayToScreen is true if you would like the player to see these additions or removals
]]--
function UIManagerShowWindow(objectName, mode, displayToScreen)
  
  mode = fuzzyBoolean(mode) --true enables name specified, false disables it
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  
  debugToDisplay("function UIManagerShowWindow, started. ObjectName is: "..tostring(objectName)
    .." mode is: "..tostring(mode).." displayToScreen is: "..tostring(displayToScreen))
  
  --Returns correctly capitolized window name on success or false on input failure.
  objectName = UIManagerTestWindow(objectName, displayToScreen)
  if not objectName then --objectName passed was incorrect
    if displayToScreen then
      pecho("Incorrect window name sent. Supported commands are:\n")
      for windowName, window in pairs(tecGeyserWindows) do--loop through containers
        if mode then 
          --make commandfor cechoLink
          local cmdToSend = [[UIManagerShowWindow("]]..windowName..[[",true,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display add "..windowName, 
            cmdToSend, --runs on click.
            "Add window to display", true)
          pecho(", ")
        else
          local cmdToSend = [[UIManagerShowWindow("]]..windowName..[[",false,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display remove "..windowName, 
            cmdToSend, --runs on click.
            "Remove window from display", true)
          pecho(", ")
        end --if mode
      end --for pairs(tecGeyserWindows)
      pecho("and ")
      if mode then
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display add all",
            [[UIManagerShowWindow("all",true,true)]], --runs on click.
            "Add all windows from display", true)
      else --if mode
        pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display remove all",
            [[UIManagerShowWindow("all",false,true)]], --runs on click.
            "remove all windows from display", true)
      end --if mode
    end --if displayToScreen
    return --error found
   end --if error found with UIManagerTestWindow
  
  if mode then --enable GUIframe object
    for windowName, window in pairs(tecGeyserWindows) do--loop through containers
        --check if objectName matches window name in loop
        --objectName == "all"| run on all windowNames
        --window.name == objectName| remove specific window sent as objectName argument
        if objectName == "all" or window.name == objectName then
          --Check if window is disabled.
          if UIManagerSettings[window.name] then 
            if UIManagerSettings[window.name].disabled then --if the window is disabled.
              if displayToScreen then
                --display a clickable command to screen
                pecho("Window "..window.name.." is currently disabled. Enable window with: ")
                local cmdToSend = [[tecEnableUIManagerWindow("]]..window.name..[[",true)]]
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display enable "..window.name, 
                  cmdToSend, --runs on click.
                  "Enable window in UI Manager", true)
              end --displayToScreen
              debugToDisplay("function UIManagerShowWindow, window: "..window.name.." is currently disable."
                ..[[enable with tecEnableUIManagerWindow("windowname",displayToScreen) or "display enable windowname"]])
              return -- do not continue window is disabled.
            end --if UIManagerSettings[window.name].disabled
          end --if UIManagerSettings[window.name]
          
          --if the UI manager is GUIframe
          if GetUIManager() == "GUIframe" then --if using GUIframe manager
            debugToDisplay("Adding "..window.name.." to "..window.GUIframeLocation..".\n")
            if displayToScreen then
              pecho("Adding "..window.name.." to "..window.GUIframeLocation..".\n")
            end --if displayToScreen
            --Add the window to GUIframe manager
            GUIframe.addWindow(tecGeyserWindows[windowName], window.name, window.GUIframeLocation)
            GUIframe.activate(windowName) --Activating the window will hide windows behind it.
          end --if GetUIManager() == "GUIframe"
          
        end --if objectName == "all" or window.name == objectName 
    end --for pairs(tecGeyserWindows)
  else --disable GUIframe object
    --loop though windows being managed.
    for windowName, window in pairs(tecGeyserWindows) do
        --objectName == "all"| run on all windowNames
        --window.name == objectName| remove specific window sent as objectName argument
        if objectName == "all" or window.name == objectName then
          if displayToScreen then echo("Removing "..objectName..".\n") end
          --if using GUIframe manager and it is initialized
          if GetUIManager() == "GUIframe" and GUIframe.initialized then 
            debugToDisplay("function UIManagerShowWindow, Removing window: "..window.name.." from GUIframe.")
            GUIframe.removeWindow(window.name) --stop displaying window in GUIframe
          end --if GetUIManager() == "GUIframe" and GUIframe.initialized
        end --if windowName == "all" or windowName == objectName
    end --for ipairs(tecWindowNames)
  end --if mode
  if guiChange then --if the guiChange function has been created
    if displayToScreen then --displayToScreen is only true when ShowWindow is run by alias, if it is false it is run by SetTheme().
      guiChange() --resize windows.
      --tecRedrawLabels() --apply style sheets to all labels
    end --if displayToScreen
  end--end if guiChange
end --function setGUIframeObject</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerRegisterWindow(geyserContainer, displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerRegisterWindow(geyserContainer, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  if not tecGeyserWindows then tecGeyserWindows = {} end --if windows table is not configured.
  local windowIsAlreadyTracked = false
  local guiFrameWindowLocations = "top topleft topright bottom bottomleft bottomright"

  if type(geyserContainer) ~= "table" then
    local errorFound = "function UIManagerRegisterWindow, was not passed a geyser container. "
      .."Stopping function, UIManagerRegisterWindow only supports geyser containers."
    tecErrorNotification(errorFound)
    error(errorFound)
  end --type(geyserContainer) ~= "table"

  if not geyserContainer.name then --if there is no name for the container.
    local errorFound = "function UIManagerRegisterWindow, geyser container passed does not have a name. "
      .." Name is required. To give it a name.\n"
      ..[[At container creation with: yourContainer = Geyser.Container:new({ name = "Name You Want"})]]
      .."\n"..[[Post creation with: yourContainer.name = "Name You Want"]]
    tecErrorNotification(errorFound)
    error(errorFound)
    return --stop function
  end -- if not geyserContainer.name
  
  --make certain GUIframeLocation is present if the framework is in use.
  if tecSettings.useGUIframe then --if using GUIframe.
    if not geyserContainer.GUIframeLocation then --if location for container in GUIframe not declared.
      local errorFound = "function UIManagerRegisterWindow, geyser container passed does not have a GUIframe location. "
        .." Not required chooses where windows starts in GUIframe layout.\n"
        ..[[After creating your geyser container add a .GUIframeLocation to the container table. ]]
        ..[[with: yourContainer.GUIframeLocation = "location"\n Supported locations are: ]]
        ..guiFrameWindowLocations
        .."\nUsing default location topleft"
      tecWarningNotification(errorFound)
      geyserContainer.GUIframeLocation ="topleft"
    end --if not geyserContainer.GUIframeLocation
    --make it lower case so we can easily check it
    geyserContainer.GUIframeLocation = geyserContainer.GUIframeLocation:lower()
    --if wrong GUIframe window location sent.
    if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation) then
      local errorFound = "function UIManagerRegisterWindow, geyser contains a bad GUIframeLocation. "
        .."Supported locations are: "..guiFrameWindowLocations
        ..". Using default location topleft."
        tecErrorNotification(errorFound)
        geyserContainer.GUIframeLocation = "topleft"
    end --if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation)
  end --if tecSettings.useGUIframe
  
  debugToDisplay("function UIManagerRegisterWindow, tecGeyserWindows table contains: ")
  --loop throgh geyser table
  for key, window in pairs(tecGeyserWindows) do
    debugToDisplay("\tWindow name: "..window.name)
    --if window passed already in table
    if window.name:lower() == geyserContainer.name:lower() then
      debugToDisplay("\tFound "..geyserContainer.name:lower()
        .." in tecGeyserWindows table. It is already being manged by UI manager.")
--      windowIsAlreadyTracked = true --notify function container already in table.
    end --if window.name:lower() == geyserContainer:lower()
  end --for pairs(tecGeyserWindows)
  
  if windowIsAlreadyTracked then --container already exists in table.
    if displayToScreen then --Display to player.
      echo(geyserContainer.name.." is already being managed by UI manager.\n")
    else --if we do not show user.
      tecWarningNotification("function UIManagerRegisterWindow, container "..geyserContainer.name
        .." already in tecGeyserWindows table. Already tracked by UI Manager.")
    end --if displayToScreen
  else --container not already in tecGeyserWindows table.

    debugToDisplay("function UIManagerRegisterWindow, adding "..geyserContainer.name.." to tecGeyserWindows table.")
--    if tecGeyserWindows[geyserContainer.name] then --container name is already in table.
--      tecErrorNotification("function UIManagerRegisterWindow, tecGeyserWindows has a table named "
--        ..geyserContainer.name)
--      return --end function
--    else -- tecGeyserWindows[geyserContainer.name] does not exist
      tecGeyserWindows[geyserContainer.name] = geyserContainer
      if not tecGeyserWindows[geyserContainer.name].name then --container did not add
        local errorFound = "function UIManagerRegisterWindow, "..geyserContainer.name
          .." was not correctly added to tecGeyserWindows table. It is not being managed "
          .." by UI manager."
        tecErrorNotification(errorFound)
        error(errorFound)
      end 
--    end --if tecGeyserWindows[geyserContainer.name]
    if displayToScreen then --Display to player.
      pecho("Adding "..geyserContainer.name.." to interface manager "..GetUIManager()..".\n")
    end --if displayToSreen
    tecGeyserWindows[geyserContainer.name]:hide() --hide the window it is not in a UI yet
    --UIManagerShowWindow(geyserContainer.name, true, displayToScreen)
  end --if windowIsAlreadyTracked
end --function UIManagerRegisterWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerEnableWindow(objectName, mode, displayToScreen)</name>
						<packageName></packageName>
						<script>--enables a window after it has been disabled.
function UIManagerEnableWindow(objectName, mode, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  local unchangedObjectName = objectName

  debugToDisplay("function UIManagerEnableWindow, started. ObjectName is: "..tostring(objectName)
    .." mode is "..tostring(mode).." displayToScreen is: "..tostring(displayToScreen))

  --Returns correctly capitolized window name on success or false on input failure.
  objectName = UIManagerTestWindow(objectName, displayToScreen)
  if not objectName then --objectName passed was incorrect
    if (unchangedObjectName:lower()):match("list") then --if the we receive a list request
      pecho("Supported ")
      if mode then pecho("enable ") 
      else pecho("disable ") end
      pecho("commands are: ")
    else 
      pecho(unchangedObjectName.." is not a managed window. Supported commands are: ")
    end
    if mode then--if enable was wanted
      if displayToScreen then
        for windowName, window in pairs(tecGeyserWindows) do--loop through containers
            --make commandfor cechoLink
            local cmdToSend = [[UIManagerEnableWindow("]]..windowName..[[",true,true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window enable "..windowName, 
              cmdToSend, --runs on click.
              "Enable "..windowName.." window", true)
            pecho(", ")
        end --for pairs(tecGeyserWindows)
        pecho("and ")
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window enable all",
              [[UIManagerEnableWindow("all",true,true)]], --runs on click.
              "Enable all windows", true)
      end --if displayToScreen
    else --disable windows sent
      if displayToScreen then
        for windowName, window in pairs(tecGeyserWindows) do--loop through containers
            --make commandfor cechoLink
            local cmdToSend = [[UIManagerEnableWindow("]]..windowName..[[",false,true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window disable "..windowName, 
              cmdToSend, --runs on click.
              "Disable "..windowName.." window", true)
            pecho(", ")
        end --for pairs(tecGeyserWindows)
        pecho("and ")
          pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display window disable all",
              [[UIManagerEnableWindow("all",false,true)]], --runs on click.
              "Disable all windows", true)
      end --if displayToScreen
    end --if mode
    pecho("\n")
    return --error found
   end --if error found with UIManagerTestWindow

  --make certain the window is going to an enabled side.
  --if it is not, send it to a good side.
  --If neither left or right side is enabled show a message.
  for windowName, window in pairs(tecGeyserWindows) do --loop through managed containers
    if objectName == "all" or window.name == objectName then --if matches the argument passed
      if mode then --if request is to enable.
        local windowLocationGood = true --tell function if the GUIFrameLocation is good
        if GetUIManager() == "GUIframe" then --if using GUIframe
          local tmpSidesTable = {"left", "right", "top", "bottom"} --used to test sides
          local tmpWindowLocation = window.GUIframeLocation:lower() --
          local tmpEnabledSideFound = false --used to tell function that an enabled side was found
          --if this window is about to  go to a side that is disabled, change the side.
          for _, tmpSide in ipairs(tmpSidesTable) do --loop through sides
            if not UIManagerSettings.PlayersTheme.borders[tmpSide] then --if the side is disabled
              local localGUIframeLocatioDisabled = false
              --check if the side the window is going to is disabled
              if table.contains({"top","bottom"}, tmpSide) then --if the disabled side is the top or bottom
                if tmpWindowLocation == tmpSide then --if the window is going to a disabled side
                  localGUIframeLocatioDisabled = true
                end --if tmpWindowLocation == tmpSide
              end --if table.contains({"top","bottom"}, tmpSide)
              if table.contains({"right","left"}, tmpSide) then--if the disabled side is the left or right
                if tmpWindowLocation:match(tmpSide) then --if the window is going to a disabled side
                  localGUIframeLocatioDisabled = true
                end --if tmpWindowLocation:match("left") or tmpWindowLocation:match("right")
              end --table.contains({"right","left"}, tmpSide)
              
              if localGUIframeLocatioDisabled then --if the side the window is going to is disabled
                for _, tmpSideModeCheck in ipairs({"left", "right"}) do --loop through sides
                  --check the left and right sides, windows added to those can be moved.
                  --Because of lack of layering support we do not want to place a window 
                  --on the top or bottom. Because it will cover windows already there.
                  if UIManagerSettings.PlayersTheme.borders[tmpSideModeCheck] then --if side is enabled
                    local errorFound = "Window "..window.name.. " is set to go to the "
                      ..window.GUIframeLocation.." of the screen. The "..tmpSide
                      .." side of the screen is disabled. Sending the window to the "
                      .."top"..tmpSideModeCheck.." of the screen."
                    window.GUIframeLocation = "top"..tmpSideModeCheck
                    tmpEnabledSideFound = true --tell function an enabled side was found
                    debugToDisplay("function UIManagerEnableWindow, "..errorFound)
                    if displayToScreen then cecho(errorFound.."\n") end
                  end --if UIManagerSettings.PlayersTheme.borders[tmpSide]
                end --for _, tmpSideModeCheck in ipairs(tmpSidesTable)
                if not tmpEnabledSideFound then --if both left and right sides are disabled.
                  local errorFound = "Both left and right sides of display are disabled. "
                    .."window "..window.name.." is set to go to the "..window.GUIframeLocation
                    .." of the screen. Left or right side of the screen must be enabled for this "
                    .."window to be added to display."
                  tecWarningNotification("function UIManagerEnableWindow, "..errorFound)
                  if displayToScreen then pecho(errorFound.."\n") end
                  windowLocationGood = false --stop this window from being enabled.
                  --tell the UI manager not to load window
                  UIManagerSettings[window.name].disabled = true 
                end --if not tmpEnabledSideFound
              end --if window.GUIframelocation:match(tmpSide)
            end --if not UIManagerSettings.PlayersTheme.borders[tmpSide]
          end --ipairs(tmpSidesTable)
        end --if GetUIManager() == "GUIframe"
      
        if windowLocationGood then --the GUIframeLocation checked good above.
          debugToDisplay("function UIManagerEnableWindow, Enabling window: "..window.name)
          if displayToScreen then pecho("Enabling window: "..window.name..".\n") end --if displayToScreen
          if not UIManagerSettings[window.name] then UIManagerSettings[window.name] = {} end --if the table does not exist, create it.
          UIManagerSettings[window.name].disabled = false --enable the window.
          UIManagerShowWindow(window.name,mode,displayToScreen) --display the window again.
        end --if windowLocationGood
      else --mode is false, we are disabling the window.
        --if window name is not in UIManagerSettings table, create a table for the window.
        if not UIManagerSettings[window.name] then UIManagerSettings[window.name] = {} end 
        UIManagerSettings[window.name].disabled = true --tell the UI manager not to load window

        --if using GUIframe
        if GetUIManager() == "GUIframe" and GUIframe.initialized then --if using GUIframe
          if GUIframe.windows[window.name] then --if the window exists.
            debugToDisplay("function UIManagerEnableWindow, removing: "..window.name
              .." from GUIframe.windows table.")
            UIManagerShowWindow(window.name,mode,displayToScreen) --hide the window
            GUIframe.windows[window.name] = nil --remove window from GUIframe so it does not get saved
          else --if the window does not exist in GUIframe already.
            debugToDisplay("function UIManagerEnableWindow, window "..window.name
              .." does not exist in GUIframe.windows table, nothing to remove.")
          end --if GUIframe.windows[window.name]
          if getTECDisplayDebugMode then --if display debug is enabled.
            displayDebug("function UIManagerEnableWindow, GUIframe.windows now looks like: ")
            for tmpWindowName, tmpWindow in pairs(GUIframe.windows) do
              displayDebug("\tWindow name: "..tmpWindowName)
            end --for pairs(GUIframe.windows)
          end --if getTECDisplayDebugMode
        end --if GetUIManager() == "GUIframe" and GUIframe.initialized
        --display message to player. Window disabled.
        if displayToScreen then pecho(window.name.." disabled.\n") end --if displayToScreen
      end --if mode
    end --if objectName == "all" or window.name == objectName
  end --for pairs(tecGeyserWindows)
  
  --if guiChange then guiChange() end--redraw windows since the display has changed
end --function tecUIManagerEnableWindow(objectName, displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerGUIframeThemes(displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
To create a UI Layout theme copy the text in the area labeled COPY BELOW
There will be another line labeled COPY ABOVE stop there.
In the function there is an area labeled PASTE ABOVE and PASTE BELOW
This will create a table within the UIThemes table.
That table will be used to place windows where you would like them.
Once completed if you run the `display layout name` command 
it will load the layout or list supported layouts.

COPY BELOW
  --Start theme namehere----------------------------------------
  uiThemes.namehere = {} --create theme table
  
  uiThemes.namehere.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }

  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `tecclient add list`
  uiThemes.namehere.windows = { }

  uiThemes.namehere.windows["TEC Map"] = "bottomright"
  uiThemes.namehere.windows["Settings"] = "bottomleft"
  uiThemes.namehere.windows["Macros"] = "bottomleft"
  uiThemes.namehere.windows["Status"] = "bottom"
  uiThemes.namehere.windows["Compass"] = "topleft"
  uiThemes.namehere.windows["Communications"] = "top"
  uiThemes.namehere.windows["Room Characters"] = "topright"
  
  --add windowsnames to table clickWindows and they will be clicked after layout has completed
  uiThemes.orchil.clickWindows = {}
  uiThemes.orchil.clickWindows["TEC Map"] = true
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.namehere.borders = {
    left = true,
    right = true,
    top = true,
    bottom = true,
  }
  --End theme namehere----------------------------------------
COPY ABOVE
]]--

--configure layout themes
function UIManagerGUIframeThemes(displayToScreen)

  --use these for sizing
  local mainW, mainH = getMainWindowSize()
  --half the width and height of main window.
  local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
  --a quarter of the window of main window.
  local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
  --an eighth the width and hieght of main window.
  local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)
  --one third of main window
  local thirdW, thirdH = math.floor(mainW * .33), math.floor(mainH * .33)
  
  uiThemes = {} --create table to hold themes
  
  --Start theme NiceHat----------------------------------------
  uiThemes.NiceHat = {} --create theme table
  
  uiThemes.NiceHat.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }

  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `display add list`
  uiThemes.NiceHat.windows = { }

  uiThemes.NiceHat.windows["TEC Map"] = "bottomright"
  uiThemes.NiceHat.windows["Settings"] = "bottomleft"
  uiThemes.NiceHat.windows["Macros"] = "bottomleft"
  uiThemes.NiceHat.windows["Status"] = "bottom"
  uiThemes.NiceHat.windows["Compass"] = "topleft"
  uiThemes.NiceHat.windows["Communications"] = "top"
  uiThemes.NiceHat.windows["Room Characters"] = "topright"
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.NiceHat.borders = {
    left = true,
    right = true,
    top = true,
    bottom = true,
  }
  --End theme NiceHat----------------------------------------
  
  --Start theme orchil----------------------------------------
  uiThemes.orchil = {} --create theme table
  
  uiThemes.orchil.GUIframe = {
      tabHeight = tabsHeight, --tabs height
      tabStyle = tabsStyle, --Tabs stylesheet
      tabEchoStyle = tabsFontStyle, --text appearence in tabs
      leftStartWidth = eighthW, --left border width
      leftStartHeight = halfH, --Where top and bottom windows meet
      rightStartWidth = quarterW, --Right border window
      rightStartHeight = halfH, --Where top and bottom windows meet
      topStartHeight = eighthH, --width of top
      bottomStartHeight = 50, --width of bottom
      resizeHeight = 30, --resize icon height
      resizeWidth = 30, --resize icon width
      --resizeHoverImage = "/imgs/resize/blue_arrows.png", currently non functional
      --resizeRestImage = "/imgs/resize/blue_arrows_20t.png", currently non functional
      borderOffset = 0, --I think width between windows.
  }
  
  --The windows you would like to add to your UI theme.
  --Goes in the square brackets and quotes ["name"]
  --The location of the window in GUIframe goes in the quotes after the equal symbol.
  --GUIframe location goes = "GUIframeLocation"
  --an easy method to list window names is `display add list`
  uiThemes.orchil.windows = { }
  uiThemes.orchil.windows["Settings"] = "bottomright"
  uiThemes.orchil.windows["Communications"] = "top"
  uiThemes.orchil.windows["Multi Window"] = "topright"
  uiThemes.orchil.windows["TEC Map"] = "bottomright"
  
  --add windowsnames to table clickWindows and they will be clicked after layout has completed
  uiThemes.orchil.clickWindows = {}
  uiThemes.orchil.clickWindows["TEC Map"] = true
  
  --control what sides are displayed.
  --true means the side will be displayed.
  --False means it will not be displayed.
  --If a window is on a disabled side it will not appear.
  uiThemes.orchil.borders = {
    left = false,
    right = true,
    top = true,
    bottom = false,
  }
  --End theme orchil----------------------------------------
  
--PASTE BELOW----------------------------------------

--PASTE ABOVE----------------------------------------

  --Set the default theme here
  uiThemesDefaultLayout = uiThemes.orchil --set default theme here

  --Load theme from save, or load a default theme if ther was no saved theme
  if UIManagerSettings.PlayersTheme then --if there is a PlayerTheme loaded from file.
    uiThemes.PlayersTheme = UIManagerSettings.PlayersTheme --load the saved theme into the themes table
  else --if there is no PlayersTheme loaded from file.
    --set the PlayersTheme to the an existing theme.
    uiThemes.PlayersTheme = uiThemesDefaultLayout
  end --if UIManagerSettings.PlayersTheme

end --function tecUILayoutManagerConfig</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerSetTheme(themeName, displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerSetTheme(themeName, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --if true display actions to screen
  UIManagerGUIframeThemes(displayToScreen) --configure GUIframe layout themes
  --list of acceptable GUIframe window locations
  local guiFrameWindowLocations = [["top" "topleft" "topright" "bottom" "bottomleft" "bottomright"]]

  local tecThemeExists = false --used to see if objectName matches a window name.
  local tecThemeNameList = "" --will be used to list window names

  debugToDisplay("function UIManagerSetTheme, themeName sent is "..tostring(themeName)
    .." displayToScreen is: "..tostring(displayToScreen))

  --Varify arguments are good.
  if type(themeName) ~= "string" then --if objectName is not a string
    tecErrorNotification("function UIManagerSetTheme, first argument is a : "
    ..type(themeName).." string was expected. Use object name IE \"niceHat\"") 
    return --end process it can not continue.
  end --if type(themeName) ~= "string"
  
  --if there are no geyser containers in tecGeyserWindows table.
  if next(uiThemes) == nil then
    tecWarningNotification("function UIManagerSetTheme, no themes in the uiLayoutThemes table.")
    return --stop to function there are no geyser containers to add to UI manager
  end --if #tecGeyserWindows == 0
  
  --Verify themeName is a correct name. Make certain themes have good data.
  for uiThemeName, uiTheme in pairs(uiThemes) do--loop through themes
    --if name was not specified, use the windowName in its place.
    if not uiThemeName then 
      tecWarningNotification("function UIManagerSetTheme, theme does not have a name.")
    end --if not uiThemeName
    --make certain UIManagerSetTheme was sent a correct name.
    if themeName:lower() == uiThemeName:lower() then --if names match
      tecThemeExists = true --notify error catch, correct name sent
      themeName = uiThemeName --Correct case sensitivity.
      debugToDisplay("function tecTestUIManager, Found objectName match "..themeName)
    end --if themeName:lower() == uiThemeName:lower()
    tecThemeNameList = tecThemeNameList..uiThemeName..", " --List windows in 1 string
  end --while pairs(uiThemes)
  
  --incorrect themeName sent. Show player correct themes.
  if not tecThemeExists then --Theme sent to function did not match any saved themes
    if displayToScreen then --display message to screen.
        if (themeName:lower()):match("list") then --if the we receive a list request
          pecho("Supported window layout themes are: ")
        else --if themeName is not "list"
          pecho(themeName.." is not a layout theme. Supported window layout themes are: ")
        end
        for uiThemeName, uiTheme in pairs(uiThemes) do--loop through containers
            --make command for cechoLink
            local cmdToSend = [[UIManagerSetTheme("]]..uiThemeName..[[",true)]]
            pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display layout "..uiThemeName, 
              cmdToSend, --runs on click.
              "Change display layout.", true)
            if (uiThemeName:lower()):match("playerstheme") then --if it is the playertheme
              pecho("-your saved theme-") --notify the player.
            end --if (uiThemeName:lower()):match("playerstheme")
            pecho(" ")
        end --for pairs(tecGeyserWindows)
    else
      tecErrorNotification("function UIManagerSetTheme, Incorrect theme name. Supported themes are "
        ..tecWindowNameList)
    end --if displayToScreen
    debugToDisplay("function UIManagerSetTheme, failed to find theme name matching: "..themeName)
    echo("\n")
    return
  end --if not tecWindowExists
  
  --load desired windows back into UI
  if GetUIManager() == "GUIframe" then --is GUIframe being used
    debugToDisplay("\tUIManagerSetTheme, starting GUIframe config")
    
    if displayToScreen then pecho("Removing windows, please wait.\n") end
    
    if GUIframe.initialized then 
      --remove all windows from UI manager and display.
      UIManagerEnableWindow("all", false, false)
    end
    --load settings from desired theme to GUIframe.
    GUIframe.configs = table.update(GUIframe.defaults, uiThemes[themeName].GUIframe)

    --Reset GUI frame
    GUIframe.reinitialize()
    
    --disable all sides
    GUIframe.disable("top", true)
    GUIframe.disable("bottom", true)
    GUIframe.disable("left", true)
    GUIframe.disable("right", true)

    if displayToScreen then pecho("Adding windows, please wait.\n") end

    --enable or disable sides.
    for tmpWinowSide,_ in pairs(uiThemes[themeName].borders) do
      --make certain the theme has a good border setting. Should be true or false, but lets be sure.
      uiThemes[themeName].borders[tmpWinowSide] = fuzzyBoolean(uiThemes[themeName].borders[tmpWinowSide])
      debugToDisplay("function UIManagerSetTheme, border "..tmpWinowSide
        .." set to "..tostring(uiThemes[themeName].borders[tmpWinowSide]))
      --enable window if theme calls for it
      if uiThemes[themeName].borders[tmpWinowSide] then GUIframe.enable(tmpWinowSide) end 
    end --for tmpWinowSide,_ in pairs(uiThemes[themeName].borders)
    
    --loop through theme windows to be added for theme make certain they are correct.
    --if they are send them to the UI manager.
    for tmpWindowName, tmpWindowGUIframeLocation in pairs(uiThemes[themeName].windows) do
      debugToDisplay("function UIManagerSetTheme, testing window name: "..tmpWindowName
        .." going to GUIframe location "..tmpWindowGUIframeLocation)
        
      --Window name error checking.
      local incorrectWindowName = tmpWindowName --used later if themeName sent is correct
      --verify the window name exists.
      tmpWindowName = UIManagerTestWindow(tmpWindowName, displayToScreen)
      if not tmpWindowName then --if the window name was bad.
        --create a smart error message
        local errorFound = incorrectWindowName.." is not a window name. Supported names are: "
        for fullListWindowName, tmpWindowTable in pairs(tecGeyserWindows) do
            errorFound = errorFound.."\""..fullListWindowName.."\" "
        end --for fullListWindowName,_ in pairs(tecGeyserWindows) do
        errorFound = errorFound.."\nTheme config code needing correction looks like: "
          ..[[uiThemes.]]..themeName..[[.windows["]]..incorrectWindowName..[["] = "]]..tmpWindowGUIframeLocation..[["]]
          .."\n\""..incorrectWindowName.."\" needs to be replaced with a supported window name, listed above.\n"
          .."Please correct and attempt again.\n"
        if displayToScreen then --if we want to display to player screen
          pecho(errorFound) --display error direct to player
        end --if displayToScreen
        debugToDisplay("function UIManagerSetTheme, "..errorFound) --display error to debug
        return --stop function bad window name sent.
      end --if not tmpWindowName
      
      --error check GUIframeLocation    
      if not guiFrameWindowLocations:match(tmpWindowGUIframeLocation) then
        --find an enabled border and set the location to that border.
        if uiThemes[themeName].borders["right"] then --if right side is enabled.
          tmpWindowGUIframeLocation = "topright" --put the window at the top right.
        elseif uiThemes[themeName].borders["left"] then --if left side is enabled.
          tmpWindowGUIframeLocation = "topleft" --put the window at the top left.
        end --if uiThemes[themeName].borders[tmpWinowSide]
        errorFound = "GUIframe location for window: "..incorrectWindowName.." incorrect.\n"
          .."A default location of "..tmpWindowGUIframeLocation.." has been chosen for window "..incorrectWindowName
          .."\nTo correct this, theme config code needing correction looks like: "
          ..[[uiThemes.]]..themeName..[[.windows["]]..incorrectWindowName..[["] = "]]..tmpWindowGUIframeLocation..[["]]
          .."\n\""..tmpWindowGUIframeLocation.."\" needs to be a supported GUIframe location, "
          ..guiFrameWindowLocations
        --display to player if displayToScreen is true.
        if displayToScreen then echo(errorFound) end --Show message to player
        tecWarningNotification(errorFound) --display to debug system.
      end --if not guiFrameWindowLocations:match(geyserContainer.GUIframeLocation)

      --Window name and location tested good, we will add it to the display.
      --if the window exists in the tecGeyserWindows table, set its GUIframeLocation
      if tecGeyserWindows[tmpWindowName] then 
        debugToDisplay("function UIManagerSetTheme, enabeling window "..tmpWindowName
          .." to GUIframe location "..tmpWindowGUIframeLocation)
        tecGeyserWindows[tmpWindowName].GUIframeLocation = tmpWindowGUIframeLocation
      else --the window name does not exist. and error occured.
        errorFound = "function UIManagerSetTheme, "..tmpWindowName
          .." does not exist in tecGeyserWindows table after UIManagerSetTheme error "
          .."checking. Please contact a developer and supply your UILayout config."
        tecErrorNotification(errorFound)
        return
      end --if tecGeyserWindows[tmpWindowName]
      debugToDisplay("\tUIManagerSetTheme, error checking passed for window "
        ..tmpWindowName.."enabeling it and adding it to display")
      --make the players theme a duplicate of the desired theme
      UIManagerSettings.PlayersTheme = table.deepcopy(uiThemes[themeName])
      --enable and display the window.
      --Do not display to screen as it will run dontforgettosave() for each window.
      UIManagerEnableWindow(tmpWindowName, true)
    end --for tmpWinowSide, tmpEnableSide in pairs(uiThemes[themeName].windows)

    --Loop through windows to click after enabeling windows, check if the names are good
    --if they are send them to the UI manager.
    if uiThemes[themeName].clickWindows then -- If there is a window to click
      for tmpWindowName, clickWindow in pairs(uiThemes[themeName].clickWindows) do
        debugToDisplay("function UIManagerSetTheme, testing clickWindows name: "..tmpWindowName
          ..", clickWindow is "..tostring(clickWindow))
        --Window name error checking.
        local incorrectWindowName = tmpWindowName --used later if themeName sent is correct
        --verify the window name exists.
        tmpWindowName = UIManagerTestWindow(tmpWindowName, displayToScreen)
        if not tmpWindowName then --if the window name was bad.
          --create a smart error message
          local errorFound = "clickWindows test of window "..incorrectWindowName.." is not a window name. Supported names are: "
          for tmpThemeWindowNames, _ in pairs(uiThemes[themeName].windows) do
              errorFound = errorFound.."\""..tmpThemeWindowNames.."\" "
          end --for fullListWindowName,_ in pairs(tecGeyserWindows) do
          errorFound = errorFound.."\nTheme config code needing correction looks like: "
            ..[[uiThemes.]]..themeName..[[.clickWindows["]]..incorrectWindowName..[["] = ]]..tostring(clickWindow)
            .."\n\""..incorrectWindowName.."\" needs to be replaced with a supported window name, listed above.\n"
            .."Please correct and attempt again.\n"
          if displayToScreen then --if we want to display to player screen
            pecho(errorFound) --display error direct to player
          end --if displayToScreen
          debugToDisplay("function UIManagerSetTheme, "..errorFound) --display error to debug
          return --stop function bad window name sent.
        else --the window name was good. click it.
          debugToDisplay("function UIManagerSetTheme, clicking window "..tmpWindowName)
          GUIframe.activate(tmpWindowName) --click the window. Hiding other windows in that space.
        end --if not tmpWindowName
      end --for pairs(uiThemes[themeName].clickWindows)
    end --if uiThemes[themeName].clickWindows
    
    --redraw GUIframe with new layout.
    --GUIframe.eventHandler("sysWindowResizeEvent")
    if guiChange then
      guiChange() --resize windows
      tecRedrawLabels() --reapply labels
    end --Size windows to theme setting.
    
    if displayToScreen then
      pecho("Layout changed to theme, "..themeName.."\n")
      dontForgetToSave() --remind player to save changes
    end --if displayToScreeen
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized

end --function UIManagerSetTheme(themeName, displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerEnableSide(sideName,mode,displayToScreen)</name>
						<packageName></packageName>
						<script>--Enable or disable sides in UI managers
function UIManagerEnableSide(sideName,mode,displayToScreen)
  mode = fuzzyBoolean(mode) --Verify good boolean sent
  displayToScreen = fuzzyBoolean(displayToScreen) --Verify good boolean sent
  local tmpSidesTable = {"left", "right", "top", "bottom"} --used to test input
  
  if not type(sideName) == "string" then --make certain first argument is a string
    local errorFound = "first argument needs to be a string."
    tecErrorNotification("function UIManagerEnableSide, "..errorFound)
    if displayToScreen then cecho("UIManagerEnableSide "..errorFound) end
    return --stop function error found
  end
  --Make certain argument passed is a correct side name
  if not table.contains (tmpSidesTable, sideName:lower()) then
    --if displayToScreen is true, show a list of acceptable commands
    if displayToScreen then 
      if (sideName:lower()):match("list") then --if the we receive a list request
        pecho("Supported side ")
        if mode then pecho("enable ") 
        else pecho("disable ") end
        pecho("commands are: ")
      else 
        pecho(sideName.." is not side. Supported commands are: ")
      end
      if mode then --show a list of enable commands if mode is true
        --loop through side names inserting them into command examples
        for iterator, tmpSideName in ipairs(tmpSidesTable) do
          --loading a command into a variable to put into a cecholink
          local cmdToSend = [[UIManagerEnableSide("]]..tmpSideName..[[",true,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor
            .."&gt;display side enable "..tmpSideName, 
            cmdToSend, --runs cmdToSend string on click.
            "Enable side "..tmpSideName, true)
          cecho(" ")
        end --for pairs("left", "right", "top", "bottom")
      else --mode false so send disable examples.
        --loop through side names inserting them into command examples
        for iterator, tmpSideName in ipairs(tmpSidesTable) do
          --loading a command into a variable to put into a cecholink
          local cmdToSend = [[UIManagerEnableSide("]]..tmpSideName..[[",false,true)]]
          pechoLink("&lt;:"..tecSettings.helpHighlightColor
            .."&gt;display side disable "..tmpSideName, 
            cmdToSend, --runs cmdToSend string on click.
            "Disable side "..tmpSideName, true)
          cecho(" ")
        end --for pairs(tmpSidesTable)                                                                            
      end --if mode
      cecho("\n") --put a new line at the end of the command examples
    end --if displayToScreen
    debugToDisplay("function UIManagerEnableSide, incorrect side name sent")
    return --stop function error found
  end --if tmpCorrectSides:match(sideName:lower())
  
  --Use GetUIManager create an ifelse for each UI manager that supports sides
  --is GUIframe being used
  if GetUIManager() == "GUIframe" and GUIframe.initialized then 
    sideName = sideName:lower() --now that we know it is a string, make it lower case
    debugToDisplay("function UIManagerEnableSide, setting border "
      ..sideName.." to "..tostring(mode))
    --Change settings in playerstheme table.
    --Now if they save display settings these changes will load on startup.
    UIManagerSettings.PlayersTheme.borders[sideName] = mode
    if mode then --if mode is true, enable side.
      GUIframe.enable(sideName)
    else --mode is false disable side
      GUIframe.disable(sideName, true)
    end --if mode
  else --UI manager does not support sides
    local errorFound = "The User Interface manager "
      .."in use does not support sides."
    if displayToScreen then cecho(errorFound.."\n") end
    tecWarningNotification("function UIManagerEnableSide, "..errorFound)
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized

  if guiChange then --if the guiChange function has been created
    if displayToScreen then --displayToScreen is only true when ShowWindow is run by alias, if it is false it is run by SetTheme().
      guiChange() --resize windows.
    end --if displayToScreen
  end--end if guiChange

  if displayToScreen then dontForgetToSave() end
end --function UIManagerEnableSide</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerFileSave(displayToScreen)</name>
						<packageName></packageName>
						<script>function UIManagerFileSave(displayToScreen)
  if tecSettings.useGUIframe then --if using GUIframe manager
    GUIframe.saveSettings() --While we do not use it presently still save GUIframe settings
    --if UIManagerSettings table does not exist make it.
    if not UIManagerSettings then 
      UIManagerSettings = {}
      UIManagerSettings.PlayersTheme = uiThemes.PlayersTheme
    end --if not UIManagerSettings
    
    --save GUIframe sizes to UIManagerSettings table, so they will load on startup
    UIManagerSettings.PlayersTheme.GUIframe.leftStartWidth = getBorderLeft() --left border width
    UIManagerSettings.PlayersTheme.GUIframe.leftStartHeight = GUIframe.topLeftContainer:get_height() --Where top and bottom windows meet
    UIManagerSettings.PlayersTheme.GUIframe.rightStartWidth = getBorderRight() --Right border window
    UIManagerSettings.PlayersTheme.GUIframe.rightStartHeight = GUIframe.topRightContainer:get_height() --Where top and bottom windows meet
    UIManagerSettings.PlayersTheme.GUIframe.topStartHeight = getBorderTop() --width of top
    UIManagerSettings.PlayersTheme.GUIframe.bottomStartHeight = getBorderBottom() --width of bottom
    
    --save enabled windows locations
    for windowName, window in pairs(tecGeyserWindows) do --loop through manged windows
      if UIManagerSettings[window.name] then --if the window exists in the settings area
        if UIManagerSettings[window.name].disabled then --check if the window is disabled
          if UIManagerSettings.PlayersTheme.windows[window.name] --if the window exists in the saved playerstheme
            --erase the settings for the window. If we do not the window will load on startup and when display layout is run.
            then UIManagerSettings.PlayersTheme.windows[window.name] = nil
          end --if UIManagerSettings[window.name].disabled
        else --if the window is enabled
          --get the location of the window from the name of its container
          local tmpGUIframeLocation = (window.container.name:gsub("Container","")):lower()
          debugToDisplay("function UIManagerFileSave, Window "..window.name
            .." saving to GUIframe location "..tmpGUIframeLocation.."\n")
          UIManagerSettings.PlayersTheme.windows[window.name] = tmpGUIframeLocation --save the windows location
        end --if UIManagerSettings[window.name].disabled
      end --if UIManagerSettings[window.name]
    end --for pairs(tecGeyserWindows)
    
  else --UI manager not in use.
    tecWarningNotification("function UIManagerFileSave, UI manager not specified.")
    if displayToScreen then echo("No User Iterface manager present.") end
  end --if tecSettings.useGUIframe then --if using GUIframe manager
  
  --Save UI Manager settings if any are present.
  if UIManagerSettings then
    --save UI Manager settings
    table.save(tecSettingsFolder.."TECUIManagerData.lua", UIManagerSettings)
  else --UIManagerSettings does not exist for some reason.
    tecErrorNotification("function UIManagerFileSave, UIManagerSettings table not present.")
  end --if UIManagerSettings
  
  if displayToScreen then pecho("\nDisplay settings saved.\n") end
end --function UIManagerFileSave</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerFileLoad(displayToScreen)</name>
						<packageName></packageName>
						<script>--load display settings.
function UIManagerFileLoad(displayToScreen)
  local tecTMPDisplayTable = {}
  
  local path = tecSettingsFolder.."TECUIManagerData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		debugToDisplay("tecFileLoadSettings: "..path.." file doesn't exist.") --TEC debug screen
    pecho("[ Info ]  - No display settings file. Parthia using default settings.\n")
		--debugc("tecFileLoadSettings: "..path.." file doesn't exist.") --mudlets debug screen
	return --kill the function before real errors occur
	else
    table.load(path, tecTMPDisplayTable) --Load the settings in from file
    --if UIManagerSettings table does not exist make it.
    if not UIManagerSettings then UIManagerSettings = {} end
    --load settings into UIManagerSettings table.
    UIManagerSettings = table.update(UIManagerSettings, tecTMPDisplayTable)
    if displayToScreen then 
      pecho("[  OK  ]  - Parthia UI Manager settings successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
	
end --function UIManagerFileLoad</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerReset(displayToScreen)</name>
						<packageName></packageName>
						<script>--reset window layout to default theme
function UIManagerReset(displayToScreen)

  --make certain display to screen is good
  displayToScreen = fuzzyBoolean(displayToScreen)

  if GetUIManager() == "GUIframe" then --if using GUIframe manager
    UIManagerGUIframeThemes(displayToScreen) --create default UI layout
    if uiThemesDefaultLayout then --if uiThemesDefaultLayout exists
      if uiThemes then --if the uiThemes table exists
        debugToDisplay("function UIManagerReset, setting PlayersTheme table to defaultUILayout table.")
        UIManagerSettings = {}
        UIManagerSettings.PlayersTheme = uiThemesDefaultLayout --replace players UI layout with default
      else --the uiThemes table somehow does not exist.
        tecErrorNotification("function UIManagerReset, uiThemes table missing.")
      end --if uiThemes
      if displayToScreen then echo("Please wait while windows reload.\n") end
      UIManagerSetTheme("PlayersTheme", false) --load windows into display
      if displayToScreen then echo("Display settings set to default.\n") end --if displayToScreen
    else --the uiThemesDefaultLayout table does not exist.
      tecErrorNotification("function UIManagerReset, uiThemesDefaultLayout table missing.")
    end --if uiThemesDefaultLayout
  else --No UI manager found
    tecWarningNotification("function UIManagerReset, no UI Mananger specified.")
    if displayToScreen then echo("No UI Manager specified.\n") end
  end --if tecSettings.useGUIframe

  if displayToScreen then dontForgetToSave() end --remind player to save.

end --function UIManagerReset</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerHelp()</name>
						<packageName></packageName>
						<script>--Returns list of commands UI Manager is capable of
--Intended to be used within a help system you make.
function UIManagerHelp()

  --display parthia at the start of display help commands
  local displayParthia
  if parthiaDisplayHelp then
    displayParthia = "parthia "
  else
    displayParthia = ""
  end --if parthiaDisplayHelp
  parthiaDisplayHelp = false

  pecho("Developer display commands:\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display add window name", 
    [[printCmdLine("display add ");
    pecho("Now enter a window name, all to add all windows or list to list supported window names.")]], 
    "Add graphical object", true)
	pecho(", show a registered window.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display remove window name", 
  [[printCmdLine("display remove ");
    pecho("Now enter a window name, all to remove all windows or list to list supported window names.")]], 
  "Remove graphical object", true)
	pecho(", hide a registered window.\n")
  
  pecho("\nPlayer display commands:\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display clear", 
  [[UIManagerClearMainWindow()]], 
  "Remove text from main screen", true)
	pecho(", clear text from main text console.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display scrollbars enable", 
  [[tecSetScrollBars(true)]], 
  "Enable scroll bars", true)
	pecho(", enable scrollbars in Parthia.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display scrollbars disable", 
  [[tecSetScrollBars(false)]], 
  "Hide scroll bars", true)
	echo(", hide scrollbars in Parthia.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display side list", 
  [[UIManagerEnableSide("list",true,true);
    UIManagerEnableSide("list",false,true);
    pecho("Click a command above to enable or disable a side of the screen.\n")]], 
  "Control what sides are displayed", true)
	pecho(", enable or disable sides of the screen that hold windows.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display window list", 
  [[UIManagerEnableWindow("list",true,true);
    UIManagerEnableWindow("list",false,true);
    pecho("Click a command above to enable or disable a window.\n")]], 
  "List all window commands", true)
	pecho(", show all windows that can be enabled or disabled.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display images list", 
  [[parthiaSetImages("list", "list", true);]],
  "List commands change images", true)
	pecho(", change images in Parthia.\n")  
  
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display layout list", 
  [[UIManagerSetTheme("list",true);
    pecho("Click a command above to switch to a different layout theme.\n")]], 
  "Change windows layout", true)
	pecho(", change window's layout to a preset theme.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display manager name", 
  [[SetUIManager("list", true)]], 
  "Change display manager", true)
	pecho(", change display manager.\n")
	
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display save", 
  [[UIManagerFileSave(true)]], 
  "Save window positions", true)
	pecho(", save window positions.\n")
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display load", 
  [[UIManagerFileLoad(true)]], 
  "Load window positions", true)
	pecho(", reset window positions to last save.\n")
	
	pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;"..displayParthia.."display reset", 
  [[UIManagerReset()]], 
  "Reset window positions", true)
	pecho(", reset window positions to default.\n")
			
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Resize Windows tutorial", 
  [[UIManagerResizeHelp()]], 
  "Resize windows tutorial", true)
	pecho(", expand or shrink windows.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Move Windows tutorial", 
  [[UIManagerMoveWindowHelp()]], 
  "Move windows tutorial", true)
	pecho(", move windows in display.\n")
  
  pecho("Click a command above or type it into the command line.\n")

end --function UIManagerHelp</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerResizeHelp()</name>
						<packageName></packageName>
						<script>function UIManagerResizeHelp() --explains how to resize display
	if GetUIManager() == "GUIframe" and GUIframe.initialized then
    pecho("You are currently using the GUIframe display manager. "
    .."To reize windows right "
		.."click one of the four very faint blue arrows and drag it. "
		.."These arrows are on the top, bottom, left and right outer edges "
		.."of the main text window that this text appears in. "
		.."When you move your mouse over the arrows they will "
		.."become bold blue arrows and show a resize tip in a small gray box.\n"
    .."Don't forget to save changes with ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
      [[UIManagerFileSave(true)]],
      "Save display settings", true)
    pecho("\n")
  else
    tecErrorNotification("You are not using a display manager. "
      .."No windows should show on screen to resize.")
  end --if GetUIManager == "GUIframe" and GUIframe.initialized
end --function UIManagerResizeHelp</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>UIManagerMoveWindowHelp()</name>
						<packageName></packageName>
						<script>function UIManagerMoveWindowHelp() --explains how to move tabs on display
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
	 pecho("You are currently using the GUIframe display manager.\n"
		.."To move a window you can right click its name tab at the top of the window. "
    .."Than drag it to the tab of another window. "
    .."When it is ready to be release a black space will open in the tabs bar to fit the name tab of the window being moved.\n"
    .."It may take a few tries because it requires the tip of the mouse's cursor to be directly over another tab. "
    .."After releasing the mouse the window and its name tab will stay where you moved it.\n"
    .."Don't forget to save changes with ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
      [[UIManagerFileSave(true)]],
      "Save display settings", true)
    cecho("\n")
  else
    tecErrorNotification("You are not using a display manager. "
      .."No windows should show on screen to move.")
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
end --function tecResizeDisplayHelp</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>status gauges</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaSetHPGauges(health, maxHealth)</name>
						<packageName></packageName>
						<script>--set all of the hp gauges
function parthiaSetHPGauges(health, maxHealth)
  hpbar:setValue(tonumber(health),tonumber(maxHealth)) --set bar on screen
  MultiWindow.hpbar:setValue(tonumber(health),tonumber(maxHealth)) --set bar in the MultiWindow
end --function parthiaSetHPBars(health, maxHealth)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaSetFatigueGauges(fatigue)</name>
						<packageName></packageName>
						<script>--[[
set all of the fatigue gauges 
usage: parthiaSetFatigueGauges(number)
where number is less than 101 and more than 0
]]--
function parthiaSetFatigueGauges(fatigue)
  fatigue = tonumber(fatigue)
  --make certain fatigue is good
  if fatigue == nil then tecWarningNotification("parthiaSetFatigueGauges, non number variable received.")
  elseif fatigue &gt; 100 then tecWarningNotification("parthiaSetFatigueGauges, fatigue higher than 100")
  elseif fatigue &lt; 0 then tecWarningNotification("parthiaSetFatigueGauges, fatigue less than 0")
  else --fatigue looks good
    fatiguebar:setValue(fatigue,100) --set bar on screen
    MultiWindow.fatiguebar:setValue(fatigue,100) --set bar in the MultiWindow
  end --if fatigue
end --function parthiaSetHPBars(health, maxHealth)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaStatusClick()</name>
						<packageName></packageName>
						<script>--[[
control a click on the status bar
usage parthiaStatusClick("health") displays health only to screen on click or run
clickType can be {"health", "fatigue", "encumbrance", "hunger", "load"}
--references
https://wiki.mudlet.org/w/Manual:Table_Functions#table.update table.contains
]]--
function parthiaStatusClick(clickType)
  --make certain clickType is good
  local clickTypeTable = {"health", "fatigue", "encumbrance", "hunger", "load"}
  local errorFound = "function parthiaStatusClick, incorrect clickType sent "
      ..tostring(clickType).." should match a string variable in table: "--..display(clickTypeTable)
  if type(clickType) == "string" then
    clickType = clickType:lower() --make certain case is all lower
    if not table.contains(clickTypeTable, clickType:lower()) then
      tecWarningNotification(errorFound)
      clickType = false --we received an incorrect clickType, do not display to screen
    end --if table.contains(clickTypeTable, clickType.lower())
  else --if clickType is not a string
    tecWarningNotification(errorFound)
    clickType = false --we received an incorrect type, do not display to screen
  end --if type(clickType) == "string"
  
  --check if checkType is within the stats command.
  local stasTypeTable = {"health", "fatigue", "encumbrance", "load"}
  if table.contains(stasTypeTable, clickType:lower()) then
    runStatsCollection(false) --collect stats data, do not show stats command to screen
    --update health
    if parthiaPlayer.CurrentCharacter.health and 
       parthiaPlayer.CurrentCharacter.maxHealth then --if health collected correctly
      local health = parthiaPlayer.CurrentCharacter.health
      local maxHealth = parthiaPlayer.CurrentCharacter.maxHealth
      parthiaSetHPGauges(health, maxHealth) --update heath gauges
      if clickType == "health" then --if health is the argument
        pecho("Health: "..health.."\\"..maxHealth.."\n")
      end --if clickType == "health"
    end --if parthiaPlayer.CurrentCharacter.health
    --update fatigue
    if parthiaPlayer.CurrentCharacter.fatigue then --if fatigue collected correctly
      local fatigue = parthiaPlayer.CurrentCharacter.fatigue
      parthiaSetFatigueGauges(fatigue) --update fatigue gauges
      if clickType == "fatigue" then
        pecho("Fatigue: "..tostring(fatigue).."\%\n")
      end --if clickType == "fatigue"
    end --if parthiaPlayer.CurrentCharacter.fatigue
    --show load
    if parthiaPlayer.CurrentCharacter.load then --if load collected correctly
      local load = parthiaPlayer.CurrentCharacter.load
      if clickType == "load" or clickType == "encumbrance" then --if load or encumbrance was passed to function
        pecho("Carrying: "..tostring(load).." pounds\n")
      end --if clickType == "load" or clickType == "encumberance"
    end --if parthiaPlayer.CurrentCharacter.load
  end --if table.contains(stasTypeTable, clickType:lower())
  
  if clickType == "hunger" then --if hunger was passed to function
    runConditionCollection(false) --collect data from condition command do not show command to screen
    if parthiaPlayer.CurrentCharacter.hunger then
      local hunger = parthiaPlayer.CurrentCharacter.hunger
      pecho("Hunger: "..tostring(hunger).."\n")
    end --if parthiaPlayer.CurrentCharacter.hunger
  end --if clickType == "hunger"
end --function parthiaStatusClick(clickType)
--parthiaStatusClick("load")</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>help</name>
				<packageName></packageName>
				<script>--[[
functions to display help messages to screen
like the parthia command or parthia talk command
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientFullHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>function tecClientFullHelp(tecBrief, tecWindow)
  
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false
  local parthiaCmdHelp = " change many client settings."
  local displayCmdHelp = " Save or load window positions, "
		.."reset display to defaults, "
  	.."and clear text off the display."
  local debugCmdHelp = " Use to get information to report issues."
  
  if not tecBrief then --if we do not want to be brief
    pecho("There are a number of commands to adjust the game client. "
  		.."They are:\n")	
  end --end if not tecBrief
  
  if getParthiaTalk() then --if parthia talk is enabled
    pecho("parthia."..parthiaCmdHelp.." display."..displayCmdHelp
      .." debug."..debugCmdHelp, true) --send to pecho talkOnly true
  end --if getParthiaTalk()
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia", 
  [[tecClientHelp()]], 
  "Save or load client settings.", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, parthiaCmdHelp.."\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;display", 
  [[UIManagerHelp()]], 
  "Change display settings.", true)
  if not tecBrief then --if we do not want to be brief
    echo(tecWindow, displayCmdHelp.."\n") 
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug", 
  [[tecDebugHelp()]], 
  "Create debug messages", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, debugCmdHelp.."\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  echo(tecWindow, "\n")
end --end function tecClientFullHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDebugHelp()</name>
					<packageName></packageName>
					<script>function tecDebugHelp()
  pecho("\n&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on", 
  [[setTECDebugMode(true)]],
  "Send debug text to debug window", true)
  pecho(", Create debug window and send basic info to it.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off", 
  [[setTECDisplayDebugMode(false) setTECMapDebugMode(false) setTECDebugMode(false)]],
  "Stop all debug messages", true)
  pecho(", Stops sending all debug messages.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on", 
  [[setTECDisplayDebugMode(true)]],
  "Show display messages to debug window", true)
  pecho(", Send display information to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display off", 
  [[setTECDisplayDebugMode(false)]],
  "Stop showing display messages to debug window", true)
  pecho(", Disables display debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on", 
  [[setTECMapDebugMode(true)]],
  "Show map messages to debug window", true)
  pecho(", Send map debug messages to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map off", 
  [[setTECMapDebugMode(false)]],
  "Stop showing map messages to debug window", true)
  pecho(", Disables map debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers on", 
  [[setTECTimerDebugMode(true)]],
  "Start showing timmer messages to debug window", true)
  pecho(", Send timer debug messages to debug.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers off", 
  [[setTECTimerDebugMode(false)]],
  "Stop showing timmer messages to debug window", true)
  pecho(", Disables timmer debug messages only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug test colors", 
  [[tecColorTest()]],
  "Send basic colors to screen", true)
  pecho(", Sends colored text to screen.\n")
	
	tecReportIssuesHelp(false)
  
  pecho("&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
    
  pecho("Click a command above or type it into the command line.\n")

end --end function tecDebugHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientHelp()</name>
					<packageName></packageName>
					<script>function tecClientHelp()  
  pecho("\nparthia command:\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia developer", 
  [[parthiaDeveloperHelp()]],
  "developer commands help", true)
  echo(", developer commands help.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map", 
  [[parthiaMap.help()]],
  "List parthia map commands", true)
  pecho(", commands for parthia's mapper.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk", 
  [[parthiaTalkHelp()]],
  "parthia talk help", true)
  pecho(", list parthia's text to speech commands.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia update check", 
  [[DownloadGitReleaseJSON()]],
  "Check for updates", true)
  pecho(", check if Parthia updates are available.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia version", 
  [[expandAlias("parthia version")]],
  "Display version of Parthia", true)
  pecho(", check installed Parthia version.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia beta test", 
  [[tecSetBetaTester()]],
  "Receive beta updates", true)
  pecho(", Toggle if you received beta updates or not.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia help developers", 
  [[expandAlias("parthia help developers")]],
  "Toggle help developers data collection", true)
  pecho(", Toggle if you are collecting data to help developers.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia help developers save", 
  [[saveHelpDevs(true)]],
  "Save Help Developer data", true)
  pecho(", Save data collected by Help Developers to file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment", 
  [[parthiaPlayerDevelopmentHelp()]],
  "Tools to help player developers", true)
  pecho(", list commands to assist player developers.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save all", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
  pecho(", Save client and display settings to file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  pecho(", Save basic client settings to file.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia load", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from file", true)
  pecho(", Loads client settings from file. \n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia reset", 
  [[tecClientReset(true);dontForgetToSave(true)]],
  "Reset client to default", true)
  pecho(", Reset non display client settings to default.\n")
  	
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia reset all", 
  [[tecClientResetAll()]],
  "Reset all client settings to default", true)
  pecho(", Reset client and display to default settings.\n")
    
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia repair", 
  [[expandAlias("parthia repair")]],
  "Repair Parthia", true)
  pecho(", repairs Parthia. By replacing all developer created code.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia report", 
  [[tecReportIssues()]],
  "Report Parthia issues", true)
  pecho(", receive instruction on reporting issues.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia numpad navigation", 
  [[expandAlias("parthia numpad navigation")]],
  "Toggle numpad navigation", true)
  echo(", turn navigation using the numberpad on or off.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia tab font size fontsize", 
  [[printCmdLine("parthia tab font size ");
    pecho("Now enter the font size at the end of the command and press enter.\n")]],
  "Change font size of tabs", true)
  pecho(", Change font size for window tabs.\n") 
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia change colors", 
  [[tecClientChangeColors()]],
  "Change client colors", true)
  pecho(", Change color scheme for client.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia font size fontsize", 
  [[printCmdLine("parthia font size ");
    pecho("Now enter the font size at the end of the command and press enter.\n")]],
  "Change client font size", true)
  pecho(", Change font size for all text consoles.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia commands", 
  [[parthiaCommandsHelp()]],
  "List custom parthia commands", true)
  pecho(", game commands that exist in parthia only.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia display", 
  [[expandAlias("parthia display")]],
  "List Parthia's display commands", true)
  pecho(", list commands to customize display layout, images and scrollbars in Parthia.\n")
 
  pecho("Click a command above or type it into the command line.\n")

end --function tecClientHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaDeveloperHelp()</name>
					<packageName></packageName>
					<script>function parthiaDeveloperHelp()

  echo("\nparthia developer commands:\n")

  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdata", 
  [[expandAlias("parthia playerdata")]],
  "View parthiaPlayer table", true)
  echo(", View parthiaPlayer table.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia help developers clear", 
  [[expandAlias("parthia help developers clear")]],
  "Clear data collected Help Developers data", true)
  echo(", Clear data collected by Help Developers.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia room data", 
  [[expandAlias("parthia room data")]],
  "Display Help Developers room data", true)
  echo(", Display Help Developers collected room data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia room data clear", 
  [[expandAlias("parthia room data clear")]],
  "Clear Help Developers room data", true)
  echo(", Clear Help Developers collected room data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia object data", 
  [[expandAlias("parthia object data")]],
  "Display Help Developers object data", true)
  echo(", Display Help Developers collected object data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia object data clear", 
  [[expandAlias("parthia object data clear")]],
  "Clear Help Developers object data", true)
  echo(", Clear Help Developers collected object data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia character data", 
  [[expandAlias("parthia character data")]],
  "Display Help Developers character data", true)
  echo(", Display Help Developers collected character data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia character data clear", 
  [[expandAlias("parthia character data clear")]],
  "Clear Help Developers character data", true)
  echo(", Clear Help Developers collected character data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player combat data", 
  [[expandAlias("parthia player combat data")]],
  "Display Help Developers player combat data", true)
  echo(", Display Help Developers collected player combat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player combat data clear", 
  [[expandAlias("parthia player combat data clear")]],
  "Clear Help Developers player combat data", true)
  echo(", Clear Help Developers collected player combat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player noncombat data", 
  [[expandAlias("parthia player noncombat data")]],
  "Display Help Developers player noncombat data", true)
  echo(", Display Help Developers collected player noncombat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player noncombat data clear", 
  [[expandAlias("parthia player noncombat data clear")]],
  "Clear Help Developers player noncombat data", true)
  echo(", Clear Help Developers collected player noncombat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia prepare release", 
  [[expandAlias("parthia prepare release")]],
  "Prepare code for release", true)
  echo(", prepare mudlet profile for a new github release.\n")

end --function parthiaDeveloperHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientChangeColors()</name>
					<packageName></packageName>
					<script>--lists commands that directly change colors
function tecClientChangeColorsList()
  pecho("Change background color of windows that do not have text with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia windows background color colorname\n", 
  [[printCmdLine("parthia windows background color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color nontext windows", true)

  pecho("Change background color of windows that have text in them with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia background colorname ", 
  [[printCmdLine("parthia background ");
    pecho("You will need to restart mudlet for text background to change")]],
  "Change background color of text windows", true)
  pecho("-Mudlet restart required on Windows OS.\n\tText background color saved in mudlet not Parthia.\n")
  pecho("Command echo background must be changed in Options -&gt; Preferences -&gt; Color View -&gt; Command Background.\n")
  
  pecho("Change background color of the client's tabs with: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia tabs background color colorname\n", 
  [[printCmdLine("parthia tabs background color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color clients tabs", true)
  
  pecho("Change the color of windows and tabs as your mouse hovers over them: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia hover color colorname\n", 
  [[printCmdLine("parthia hover color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change mouse hover color", true)
  
  pecho("Change the color approached characters appear in Room Characters window: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia approached character color colorname\n", 
  [[printCmdLine("parthia approached character color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color approached characters in Room Character Window", true)
  
  pecho("Change the color not approached characters appear in Room Characters window: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia not approached character color colorname\n", 
  [[printCmdLine("parthia not approached character color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change color not approached characters in Room Character Window", true)
  
  pecho("Change the color help commands are highlighted in: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia helphighlight color colorname\n", 
  [[printCmdLine("parthia helphighlight color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change help command highlight color", true)

  pecho("Change TEC's gray text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia gray color colorname\n", 
  [[printCmdLine("parthia gray color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  pecho("Change TEC's purple text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia purple color colorname\n", 
  [[printCmdLine("parthia purple color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  pecho("Change the color of TEC's default green: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia greentext color colorname\n", 
  [[printCmdLine("parthia greentext color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's green text color", true)
  
  pecho("Change the color of TEC's default blue: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia bluetext color colorname\n", 
  [[printCmdLine("parthia bluetext color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's blue text color", true)
  
  pecho("Change TEC's primary text color: ")
  pechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia text color colorname\n", 
  [[printCmdLine("parthia text color ");
    pecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)

  pecho("Click a command above or type it into the command line.\n")  

end --function tecClientChnageColorsList

--General help for changing colors.
function tecClientChangeColors()

  pecho("List all commands that change colors with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor
    .."&gt;parthia change colors commands\n", 
  [[tecClientChangeColorsList()]],
  "Save client settings", true)
   
  pecho("Don't forget to save your changes with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  
  pecho("List colornames in main window: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;lua showColors(3)\n", 
  [[showColors(3);
    cecho("Click a color to add it to the end of the command bar")]],
  "List color names", true)
  
  pecho("Open colorname chooser window: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia colors\n", 
  [[tecColorWindow()]],
  "Open color chooser window", true)
  
  pecho("Color names in each command can be a hex color also, IE: #FF0000 is red."
    .." If you would like to use hex colors here is a ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;hex color picker.\n", 
  [[openUrl("https://www.w3schools.com/colors/colors_picker.asp")]],
  "Hex color tool", true)
  
  pecho("Click a command above or type it into the command line.\n")

end --function tecClientChangeColors()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaCommandsHelp()</name>
					<packageName></packageName>
					<script>function parthiaCommandsHelp()
  pecho("\nCustom Parthia commands:\n")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;wait for drover", 
  [[expandAlias("wait for drover")]],
  "Wait for a drover", true)
  pecho(", wait for a wagon drover.\n")
  
  pecho("Click a command above or type it into the command line.\n")
end --function parthiaCommandsHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaTalkHelp()</name>
					<packageName></packageName>
					<script>--help message that appears when `parthia talk` command is run
function parthiaTalkHelp()
  pecho("Parthia talk commands are\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk enable", 
    [[expandAlias("parthia talk enable")]],
    "Enable parthia talk", true)
  pecho(", enable parthia's text to speech system.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk disable", 
    [[expandAlias("parthia talk disable")]],
    "Disable parthia talk", true)
  pecho(", disable parthia's text to speech system.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk queue", 
    [[expandAlias("parthia talk queue")]],
    "Disable parthia talk", true)
  pecho(", toggles the state of the parthia talk queue. Queue is disabled by default.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pause", 
    [[expandAlias("parthia talk pause")]],
    "Pause parthia talk", true)
  pecho(", pause parthia talk, keep messages in queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk resume", 
    [[expandAlias("parthia talk resume")]],
    "Resume parthia talk", true)
  pecho(", resume talk after pausing.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk skip", 
    [[expandAlias("parthia talk skip")]],
    "Skip current message", true)
  pecho(", skip the current message in the talk queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk sk", 
    [[expandAlias("parthia talk sk")]],
    "Skip current message", true)
  pecho(", skip the current message in the talk queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk clear", 
    [[expandAlias("parthia talk clear")]],
    "Clear talk queue", true)
  pecho(", clear parthia talk's message queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk cl", 
    [[expandAlias("parthia talk cl")]],
    "Clear talk queue", true)
  pecho(", clear parthia talk's message queue.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk debug", 
    [[expandAlias("parthia talk debug")]],
    "Collect tts debug data", true)
  pecho(", collect parthia talk debug data for developers.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice list", 
    [[expandAlias("parthia talk voice list")]],
    "Choose talk voice", true)
  pecho(", change voice parthia talk speaks in.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speed list", 
    [[expandAlias("parthia talk speed list")]],
    "List talk speed list", true)
  pecho(", list speeds parthia talk speaks in.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pitch list", 
    [[expandAlias("parthia talk pitch list")]],
    "List talk pitch commands", true)
  pecho(", change the pitch that parthia talk speaks in.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk volume list", 
    [[parthiaTalkSetVolume("list", true)]],
    "List talk volume commands", true)
  pecho(", change the volume that parthia talk speaks in.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk thoughts", 
    [[expandAlias("parthia talk thoughts")]],
    "Speak thoughts always", true)
  pecho(", speak in game thoughts even if parthia talk is disabled.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speech", 
    [[expandAlias("parthia talk speech")]],
    "Speak speech always", true)
  pecho(", speak in game speech even if parthia talk is disabled.\n")
  
  pecho("\nparthia talk has a short hand version of /pt. For example ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/pt enable", 
    [[expandAlias("pt enable")]],
    "Enable parthia talk", true)
  cecho("\n")
  
  pecho("Click a command above or type it into the command line.\n")
end --function parthiaTalkHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaPlayerDevelopmentHelp()</name>
					<packageName></packageName>
					<script>function parthiaPlayerDevelopmentHelp()
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment Install", 
  [[PlayerDev.SetEnabled(true)]],
  "Install player development folders", true)
  pecho(", install player development folders.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment uninstall", 
  [[PlayerDev.SetPackages(false)]],
  "Uninstall player development folders", true)
  pecho(", Uninstall player development folders.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment disable", 
  [[PlayerDev.SetEnabled(false)]],
  "Disable player development updates", true)
  pecho(", stop receiving player development code updates.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia playerdevelopment update", 
  [[PlayerDev.Update(true)]],
  "Check for player development updates", true)
  pecho(", check for updates to player development folders. Occurs automatically with client updates.\n")
end --function parthiaPlayerDevelopmentHelp()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Map</name>
				<packageName></packageName>
				<script>--Functions used for TEC's map system.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecMapPixelToPercent</name>
					<packageName></packageName>
					<script>--used to convert a number into what percent it would be on TECs Map 
function tecMapPixelToPercent(tecNumToConvert)
	--converts a size in pixels in reference to TECs map to a percent.
	--TECs map is 240 by 240 pixels.
	--Than adjusts with zoom.
	--Intended for calculating dimmensions of object on the map.
	return ((tonumber(tecNumToConvert) / 240) * 100) * mapZoom
end --end function tecMapPixelToPercent</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecMapIconAdjustment</name>
					<packageName></packageName>
					<script>--position a static icon on the map "probably an exit icon".
--tecIconDimmension is the height or width of the icon being positioned.
--tecMapDimmension is the height or width of the background label of the map.
--Both should be either height or width. One being a height and the other a width may result
--in incorrect icon positioning. Later map release will offer user to not have a square map, if wanted.
function tecMapIconAdjustment(tecIconDimmension, tecMapDimmension)	
	--Turn half the icons size into a percent of what it is on a tecMap 240x240
	tecIconDimmension = tecMapPixelToPercent(tecIconDimmension / 2)
	--Device the entire dimmension of the map by tecMaps 240 size.
	--Than device the % of the icon size by that resulting number.
	return tecIconDimmension / (tecMapDimmension / 240)
end --end tecMapIconAdjustment</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaDrawMapRooms()</name>
					<packageName></packageName>
					<script>--SKOOT 6 -10,-10,20,#ff0000,17.1111,-10,10,20,#ffffff,25.5555
--This skoot is from a map that I am certain there are two rooms.
--Both the same size. One higher up is red one directly below is white
--They are the same size.
--There are door open and closed lines on them. Those are handled with skoot 10 messages
--SKOOT 6 x, y, size, color, ?
--x horizonal position of top left corner
--y is vertical position of top left corner
--size is the size of the room 
--color is the color of the room 
--[[
last variable notes provided by thric3blinded#0967

var light = 25.4905;
light = light - 25;
var colourArray = [0, 255, 0]; // starts as whatever the 4th variable hex value is, in RGB

colourArray[0] = Math.min(Math.max(Math.round(colourArray[0] * 1 + (light * 8)), 0), 255);
colourArray[1] = Math.min(Math.max(Math.round(colourArray[1] * 1 + (light * 8)), 0), 255);
colourArray[2] = Math.min(Math.max(Math.round(colourArray[2] * 1 + (light * 8)), 0), 255);

// colourArray ends up being: [4, 255, 4] (green with light applied)
]]--

--This is going to be the games largest in drawn pixels and most common skoot message
--SKOOT 6 -40,-40,80,#ff0000,117.624,40,-40,80,#00ff00,117.624,-120,-40,80,#00ff00,117.624,
---40,-120,80,#ffffff,117.624,-40,40,80,#ffffff,117.624,-120,40,80,#ffffff,117.624,
--40,40,80,#ffffff,117.624,40,-120,80,#ffffff,117.624,-120,-120,80,#ffffff,108.576
--Now we need to get room data in %.
--We know that 80 is the max room size for a single room. By observing skoots.
--We know, only because of playing. That these rooms are normally in a 3x3 grid.
--So we know now our draw win is 240x240
--TEC numbers map to a graph, not a window. So their 0 is x120 y120 in our window.
--To get our correct position we have to do xpos + 120. 
--x and y are both -40 / 120. It would be -.33333.
--multiply that by 100 to get the number is a full percent. -33.333
--Now since tec sees x120,y120 as position 0 and the rest of the world sees x0,y0 as zero
--We need to add our number to 50, because 120 is 50% of our total draw size of 240 pixels.
--50 + -33.333 = 16.667. so 16.667% are our x and y positions.
--size is 80 that will be our width and height.
--We need to get what percent 80 is of our overall draw size 240
-- 80 / 240 = .33333. Multiply that by 100, 33.333
--The room is 33.33% of the entire draw window.
--Subtract 1% of that so we have a border between rooms.
--ff0000 is red so the room will be red.
--17.1111 is lighting in the room. To adjust how dark the room is drawn on the map

--Loop through the sckoot message. Looking for a pattern of room data.
--The patterns in () get returned on gmatch. We capture those into variables.
--Those varibles will be used to draw the room.
--Explaining: "(-?%d+),(-?%d+),(%d+),(#%x+),%d+.%d+,?"
--"-?" means there MAY be a -
--"%d+" is a decimal number that CAN be more than one digit long.
--"%x+: is a hexidecimal number that CAN be more than one digit long.
-- ",?" At the very end. There MAY be a , at the end of our pattern or there
--[.%d*]? means there may be a . followed by 0 or more numbers. Like .4555
--may not be. The last number in the skoot message does not have a ,.
--Not looking for that comma in earlier messages might cause future
--pattern searches to fail.
function parthiaDrawMapRooms()
  for xpos, ypos, size, tecMapRoomcolor in string.gmatch( line, "(-?%d+),(-?%d+),(%d+),(#%x+),%d+[.%d*]?,?" ) do
  
    --TEC uses grid logic for their map. xposition is up to 120 +-.
    --240 is the total size of their draw space. What percent is our position in that space.
    -- +.5 just gives us a border.
    xposScaler = ((((tonumber(xpos) + 120) / 240) * 100)) * mapZoom
    yposScaler = ((((tonumber(ypos) + 120) / 240) * 100)) * mapZoom
  
  	--Convert the size of the room to draw into % of its size on the map.
    --size / 240 = decimalNumber like .3333. Multiply decimalNumber by 100, that is your % 
    sizeScaler = tecMapPixelToPercent(size)
--[[ 
  	if getTECMapDebugMode() then --if Display Debug Mod is on.
    	debugToDisplay("Map Room "..tostring(mapRoomsLC).." xpos: "..tostring(tonumber(xpos)+120)
  		.." xposScaler: "..tostring(xposScaler)
      .." ypos: "..tostring(tonumber(ypos)+120).." yposScaler: "..tostring(yposScaler)
      .." size: "..tostring(size).." sizeScaler: "..tostring(sizeScaler)
      .." color: "..tostring(tecMapRoomcolor))
    	cecho(mapRoom[mapRoomsLC].name,tostring(mapRoomsLC),blue,"c") --put room # on label
  	end --end if DisplayDebugMode is true
]]--   	
    mapRoom[mapRoomsLC]:move(tostring(xposScaler).."%", tostring(yposScaler).."%") --Move the room into position.
    mapRoom[mapRoomsLC]:resize(tostring(sizeScaler).."%", tostring(sizeScaler).."%") --Change the rooms size.
  	--using style sheets set the shape and color of the room
  	if tecMapRoomcolor == "#ff0000" then --if we are drawing the room the player is currently in
      mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleRed) --make it red
      if parthiaMap.getEnabled() then --if player is using parthiaMap
        parthiaMap.room.size = tonumber(size/10) --collect the size for parthiaMap
        parthiaMap.room.xpos = tonumber(xpos/10) --used to calculate area of room and where other rooms should be created while mapping
        parthiaMap.room.ypos = tonumber(ypos/10) --used to calculate area of room and where other rooms should be created while mapping
  	  end --if parthiaMap.getEnabled()
    elseif tecMapRoomcolor == "#00ff00" then --room color is green, means rooms of simular type
      mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleGreen) --make room green on tecMap
      if parthiaMap.getEnabled() then --if player is using parthiaMap
        parthiaMap.trackTECMapRooms(size, xpos, ypos) --keep track of where this room is for parthiaMap
  	  end --if parthiaMap.getEnabled()
    else --all other rooms
      mapRoom[mapRoomsLC]:setStyleSheet(mapRoomStyleWhite) --make room white on TEC Map
      if parthiaMap.getEnabled() then --if player is using parthiaMap
        parthiaMap.trackTECMapRooms(size, xpos, ypos) --keep track of where this room is for parthiaMap
      end --if parthiaMap.getEnabled() then --if player is using parthiaMap
    end --if tecMapRoomcolor == "#ff0000"
  	
    mapRoom[mapRoomsLC]:show() --Now show the room.
    mapRoomsLC = mapRoomsLC +1 --Iterate so we can do this again.
  end --end gmatch room data search loop
end --function parthiaDrawMapRooms()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaDrawMapExits()</name>
					<packageName></packageName>
					<script>--[[
Draw exits for map
SKOOT 10 x y, dir, open
x is horizontal position, from center of line
y is vertical position, from center of line.
dir is the direction the Exit is facing, normally it is a line so
	"hor" is horizontal, v is vertical
	"ne" is a 45 degree angle going from left to right, so north east on a map.
	"nw" is a 45 degree andle going from right to left. so north west on a map.
open if the Exit is open. 1 is open 0 is closed.
]]--

function parthiaDrawMapExits()
  --look through line for the data pattern to get exit data. Input them into variables.
  for xpos, ypos, exitDirection, exitOpen in string.gmatch( line, "(-?%d+),(-?%d+),(%w+),(%d+),?" ) do
--[[  
  	if getTECMapDebugMode() then --if Display Debug Mode is on.
    	debugToDisplay("Map Exit "..tostring(mapExitsLC).." xpos: "
  		..tostring(tonumber(xpos)+120).." xposScaler: "..tostring(xposScaler)
      .." ypos: "..tostring(tonumber(ypos)+120).." yposScaler: "..tostring(yposScaler)
      .." Direction: "..exitDirection
      .." open: "..tostring(exitOpen)
  		.."\nExit Icon: Width: "..tecExit[exitDirection].width
  		.." Height: "..tecExit[exitDirection].height
      .." Style sheet: "..tecExit[exitDirection][exitOpen].tecExitStyleSheet)
  	end --end if DisplayDebugMode is true
]]--  
  	--pulling sizes from the tecExit table resize the label for the icon	
    mapExit[mapExitsLC]:resize(tecExit[exitDirection].width, tecExit[exitDirection].height)
  	--Now set the style sheet for the  
  	mapExit[mapExitsLC]:setStyleSheet(tecExit[exitDirection][exitOpen].tecExitStyleSheet)
  
  	--labels start at x0y0 in mudlet, but TEC is providing a center point for our exit icons
  	--convert half the size of the icons for exits into % of the total map window.
  	--Than take the overall size of the map window / that by our standard 240 window size.
  	--The resulting number is used to adjust the icon position as the map is scaled.
  	local iconWidthAdjustment = tecMapIconAdjustment(tecExit[exitDirection].width, tecMap_back:get_width())
  	
    --TEC uses grid logic for their map. xposition is 120 +-.
    --240 is the total size of their draw space. What percent is our position in that space.
  	--halfWidth is used to center
  	local xposScaler = ((((tonumber(xpos) + 120) / 240) * 100) - iconWidthAdjustment) * mapZoom
  	
  	--same logic as aboive
  	local iconHeightAdjustment = tecMapIconAdjustment(tecExit[exitDirection].height, tecMap_back:get_height())
  	local yposScaler = ((((tonumber(ypos) + 120) / 240) * 100) - iconHeightAdjustment) * mapZoom	
  	
  	--Move the Exit into position.
    mapExit[mapExitsLC]:move(tostring(xposScaler).."%", tostring(yposScaler).."%") 
  	mapExit[mapExitsLC]:lower() --Position rooms ontop of exits.
  	mapExit[mapExitsLC]:show() --Now show the exit path.
    
    if parthiaMap.getEnabled() then --if player is using parthiaMap
      parthiaMap.trackTECMapExits(exitDirection, xpos, ypos, exitOpen) --collect the exit's data for parthiaMap
    end --if parthiaMap.getEnabled()
  
    mapExitsLC = mapExitsLC +1 --Iterate so we can do this again on a new exit.
  end --end gmatch room data search loop
end --function parthiaDrawMapExits()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Settings Window</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecRefreshSettingsWindow()</name>
					<packageName></packageName>
					<script>function tecRefreshSettingsWindow()

	clearWindow("tecSettingsConsole")

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Load\n", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from last save", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Update\n", 
  [[DownloadGitReleaseJSON()]],
  "Check for updates", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Font Size\n", 
  [[printCmdLine("parthia font size ")]],
  "Change client font size", true)
	
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Resize Windows\n", 
  [[UIManagerResizeHelp()]],
  "Tutorial on how to resize windows", true)
  
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Move windows\n", 
  [[UIManagerMoveWindowHelp()]],
  "Tutorial on how to move display tabs", true)

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Change Colors\n", 
  [[tecClientChangeColors()]],
  "Change client colors", true)

  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Report Issues\n", 
  [[tecReportIssues()]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Client Help\n", 
  [[tecClientFullHelp(false, "main")]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "\n&lt;:maroon&gt;Reset\n", 
  [[tecClientResetAll()]],
  "Reset all changes to default", true)

end --function tecRefreshSettingsWindow

</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Parthia Commands</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientResetAll()</name>
					<packageName></packageName>
					<script>--Resets all client settings
function tecClientResetAll(displayToScreen)

  displayToScreen = fuzzyBoolean(displayToScreen)
  
  --reset client settings
  tecClientReset(true)
  
  --reset display settings
  UIManagerReset(true)

  if displayToScreen then 
    pecho("All settings at default. ")
    dontForgetToSave()
  end

end --function tecClientResetAll()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Font</name>
					<packageName></packageName>
					<script>--[[
Functions that work with the font.
All windows

font like functions
setMainWindowAutoWrap() sets main windows autowrap character count, is in scripts - GUI

]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECFont</name>
						<packageName></packageName>
						<script>--Currently returns the font size.
--later hope to return font type also.
function getTECFont()
	return tecSettings.tecFontSize
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetFontSize(numbertemp)</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetFontSize(numbertemp)--set font settings with this function

	pecho("\nSetting font to: "..numbertemp.."\n")

	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if numbertemp &lt; 8 then
		numbertemp = 8
		pecho("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
	
	tecSettings.tecFontSize = numbertemp or tecDefaultFontSize --set it to size passed OR default on fail
  
  --Run change for all text windows.
  for index, windowName in ipairs(tecTextWindowNames) do 
    setFontSize(windowName, tecSettings.tecFontSize)
    debugToDisplay("Font Change: Window: "..windowName.." font is now: "
      ..tecSettings.tecFontSize)
  end --for windowName in table tecTextWindowNames
  
  --pecho("Parthia console font is now: "..tecSettings.tecFontSize..".\n")
  
  tecRefreshSettingsWindow() --Redraw text in setttings window.
  tecResetRoomCharacterWindow() --Redraw text in room characters window.
  
  dontForgetToSave() --reminder player to save

end --end tecClientSetFontSize</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetTabFontSize</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetTabFontSize(tecTmpTabFont)--set font settings with this function
  tecTmpTabFont = tecTmpTabFont or tecSettings.tecTabsFontSize
  
	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if tecTmpTabFont &lt; 8 then
		tecTmpTabFont = 8
		pecho("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
  
  pecho("Setting tab font to: "..tecTmpTabFont.."\n")
	
	tecSettings.tecTabsFontSize = tostring(tecTmpTabFont) or tostring(tecDefaultFontSize) --set it to size passed OR default on fail
  
  --Now that the setting changed, reconfig themes
  tecConfigThemes()
  
  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then
    GUIframe.configs.tabEchoStyle = tabsFontStyle --reset GUIframe tabs draw style.
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
  
  --Redraw all tabs, this includes labels.  
  tecRedrawLabels()
  
  dontForgetToSave() --reminder player to save
  cecho("") --cechoLink does not new line itself.

end --end tecClientSetTabFontSize(numbertemp)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSaveWindowText(tecWindow, tecDirectory)</name>
					<packageName></packageName>
					<script>--copy text in a window to clip board
function tecSaveWindowText(tecWindow, tecDirectory)
	
	--if directory not specified default to debug folder.
	tecDirectory = tecDirectory or tecDebugSaveDir
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"

	--get total number of lines in window
	local tecWinLineCount = getLastLineNumber(tecWindow)
	--create a table with windows contents
	local windowDataToCopy = getLines(tecWindow, 1, tecWinLineCount)

	--Create a table to save to file. Has to be a file because a string can not be saved
	--to a file we specify.
	local tecWindowBufferString = "INFO: Text shown from latest line to oldest."
	--Loop through all the lines in the table created from the lines in the window.
	for i = tecWinLineCount, 1, -1 do
		--check if a password or login ID may be in the line
		if string.find(tostring(windowDataToCopy[i]), "LOGIN") 
		or string.find(tostring(windowDataToCopy[i]), "Login")
		or string.find(tostring(windowDataToCopy[i]), "login")
		or string.find(tostring(windowDataToCopy[i]), "PASSWORD")
		or string.find(tostring(windowDataToCopy[i]), "Password")
		or string.find(tostring(windowDataToCopy[i]), "password")
		then --replace them with a notice if they are
			tecWindowBufferString = tecWindowBufferString.."A login event was on this line.\n"
		else
			--Put all the lines into one easy to read string.
			tecWindowBufferString = tecWindowBufferString..tostring(windowDataToCopy[i]).."\n"
		end --if else tecWindowBufferString contains login or password
	end --for tecWinLineCount


	--Checking if folder user requested exists.
	--If it does not, then create the folder.
	--if folder created without error write the buffer string to file.
	--If a folder can not be created, output an error
  local lfs = require( "lfs" ) --load lfs module www.tutorialspoint.com/lua/lua_modules.htm
  --Attempt to change current working directory
  local tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
  if ( tecFolderExists ) then --if folder exists, can be cd into...
  	--Save window contents to file.
    io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
    io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
    io.output():close() --Close the file
		pecho("Window saved\n")
  else --if the folder does not exist.
  	lfs.mkdir( tecDirectory ) --make the directory.
		tecFolderExists = nil --clear the folder check
    tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
    if ( tecFolderExists ) then --if folder exists or can be cd into.
    	--Save window to file.
      io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
      io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
      io.output():close() --Close the file
			pecho("Window saved\n")
		else --the folder could not be created.
			pecho("unable to create folder"..tecDirectory)
			debugToDisplay("unable to create folder"..tecDirectory)
		end --if tecFolderExists
  end --if tecFolderExists else
		
end --function tecSaveWindowText</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecOpenDirectory(tecTMPDir)</name>
					<packageName></packageName>
					<script>--opens a directory in the local browser.
--This will need to have code added to detect linux and mac.

function tecOpenDirectory(tecTMPDir)
	if getOS() == "windows" then
		os.execute("start \"\" \""..tecTMPDir.."\"") --opens explorer to the folder requested
	elseif getOS() == "mac" then
		pecho("Sorry mac is currently not supported. Please open finder and go to: "
			..tecTMPDir)
	elseif getOS() == "linux" then
		pecho("Sorry linux is currently not supported. Please open a file browser and go to: "
			..tecTMPDir)
	end --if os version
end --tecOpenDirectory</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>techreplace</name>
					<packageName></packageName>
					<script>--here purely as a reminder of the first hurdle overcome to start Parthia.
--wound up finding hinsertText would sometimes cause issues with the 
--main text filter trigger. Sometimes it would stop filtering.
--Issue went away when I switched to hecho 
function techreplace(window, text)
    if not text then text, window = window, nil end
    window = window or "main"
    local str, start, stop = getSelection(window)
    if window ~= "main" then
				selectCurrentLine(window)
				replace(window, "")
				hinsertText(window, text)
				deselect()
    else
				selectCurrentLine()
        replace("")
				hinsertText(text)
				deselect()
    end
end</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Colors</name>
					<packageName></packageName>
					<script>--[[
functions for changing colors on the client.
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>tecLabelBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the background for labels that are not tabs.
function tecLabelBackgroundColor(tecColor)
  tecSettings.labelBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecTabsBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color for tab labels
function tecTabsBackgroundColor(tecColor)
  tecSettings.tabsBackgroundColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetMouseHoverColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color a label changes to when a mouse hovers over it.
function tecSetMouseHoverColor(tecColor)
  tecSettings.hoverColor = Geyser.Color.hex(tecColor)
  
  tecRedrawLabels() --redraw labels appling change
  
  dontForgetToSave() --reminder player to save
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetHelpHighlightColor(tecColor)</name>
						<packageName></packageName>
						<script>--sets the color commands are highlighted in help menus.
function tecSetHelpHighlightColor(tecColor)
  tecSettings.helpHighlightColor = tecColor
  tecRefreshSettingsWindow() --refresh settings window text
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGreenTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetGreenTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GreenTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBlueTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default blue text.
function tecSetBlueTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.BlueTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGrayTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default gray text.
function tecSetGrayTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GrayTextColor = Geyser.Color.hex(tecColor)

  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetPurpleTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for default gray text.
function tecSetPurpleTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.PurpleTextColor = Geyser.Color.hex(tecColor)

  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for main text.
function tecSetTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.tecTextColor = Geyser.Color.hex(tecColor)
  
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for console background colors.
function tecSetBackgroundColor(tecColor)
  --reference: https://wiki.mudlet.org/w/Manual:Lua_Functions#setBackgroundColor
  --https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#setBgColor
  for index, windowName in ipairs(tecTextWindowNames) do
    local rb, gb, bb = Geyser.Color.parse(tecColor)
    local hexColor = Geyser.Color.hhex(rb, gb, bb)
    hexColor = hexColor:sub(2,7)
    debugToDisplay("Color Change: "..windowName.." background to "
      ..rb..","..gb..","..bb.." hex value: "..hexColor.."\n")
    setBackgroundColor(windowName, rb, gb, bb) --change background color
    setBgColor(windowName, rb, gb, bb) --change background color for cechos
    setHexBgColor(windowName, hexColor)
  end
  
  runTECRoomObjectCheck(false)
  pecho("Text box background color changes are saved by mudlet immediately.\n"
    .."If using windows you will need to restart for text background "
    .."colors to change")
  
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecNotApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for not approached characters.
function tecSettecNotApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.notApproachedCharacterColor = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSettecApproachedCharacter(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for approached characters.
function tecSettecApproachedCharacter(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.ApproachedCharactersColor = Geyser.Color.hex(tecColor)
  runTECRoomObjectCheck(displayToScreen) --refresh room characters window.
  dontForgetToSave() --reminder player to save
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecColorWindow()</name>
						<packageName></packageName>
						<script>--Creates a window for users to easily select text.

-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs,rhs)
  local lh,ll,lv = unpack(lhs.sort)
  local rh,rl,rv = unpack(rhs.sort)
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end

-- internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a,b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname &lt; bname
end

-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  
  local d = max - min
  if max == 0 then 
    s = 0 
  else 
    s = d / max 
  end
  
  if max == min then
    h = 0 -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then h = h + 6 end
    elseif max == g then 
      h = (b - r) / d + 2
    elseif max == b then 
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  
  return h, s, v
end

-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r,g,b)
  local lum = math.sqrt( .241 * r + .691 * g + .068 * b )
  local reps = 8
  
  local h, s, v = rgbToHsv(r,g,b)
  
  local h2 = math.floor(h * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then 
    v2 = reps - v2
    lum = reps - lum
  end
  return h2, lum, v2
end

local function calc_luminosity(r,g,b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end


--- Prints out a formatted list of all available named colors (EXCEPT FOR
--- the 256 colors with names of form "ansi_###" where ### is 000 to 255),
--- optional args specifies:
--- * (number) number of columns to print in, defaults to 4;
--- * (string) substring required to match to include in output, defaults to
--- showing all if not supplied;
--- * (boolean) whether to sort the output, defaults to false.
--- @usage Print list in 4 columns by default.
---   &lt;pre&gt;
---   showColors()
---   &lt;/pre&gt;
--- @usage Print list in 2 columns.
---   &lt;pre&gt;
---   showColors(2)
---   &lt;/pre&gt;
---
--- @see color_table

function tecShowColors(...)
  local cols, search, sort = 4, "", false
  for _, val in ipairs(arg) do
    if type(val) == "string" then
      search = val:lower()
    elseif type(val) == "number" then
      cols = val
    elseif type(val) == "boolean" then
      sort = val
    end
  end
  
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if not string.find(k, "ansi_%d%d%d") then
      table.insert(colors,color)
    end
  end
  
  if sort then 
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors,sortColorsByHue) 
  end
  local i = 1
  for _, k in ipairs(colors) do
    if k.name:lower():find(search) then
      local v = k.rgb
      local fgc = "white"
      if calc_luminosity(v[1],v[2],v[3]) &gt; 0.5 then
        fgc = "black"
      end
      cechoLink("Color_Selector", string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ',fgc,k.name,k.name), [[appendCmdLine("]] .. k.name .. [[")]], table.concat(v, ", "), true)
      if i == cols then
        echo("Color_Selector","\n")
        i = 1
      else
        i = i + 1
      end
    end
  end
  if i ~= 1 then echo("\n") end
end

function tecColorWindow()
  openUserWindow("Color_Selector")
  clearUserWindow("Color_Selector")
  enableScrollBar("Color_Selector")
  tecShowColors(4)
  cecho("If the color choice window opened in an odd location "
  .."it can be moved by left clicking its title bar and dragging it.\n"
  .."It does not need to be docked at any location, it can free float anywhere "
  .."in your monitor.\nIt is also fully resizable by clicking and dragging "
  .."its outer edges.\n")
  cecho("Color_Selector",
    "\nClick a color to add it to the end of the command bar.")
end --function tecColorWindow()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSetBetaTester(betaTester)</name>
					<packageName></packageName>
					<script>function tecSetBetaTester() 
  if tecSettings.betaTester then
    tecSettings.betaTester = false
    pecho("You will not receive beta updates.\n")
  else
    tecSettings.betaTester = true
    pecho("You will now receive beta updates.\n\tThank you this helps us a GREAT deal!\n")
  end --if betaTester
  
  dontForgetToSave() --remind player to save
end --function tecSetBetaTester(betaTester)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecGetBetaTester()</name>
					<packageName></packageName>
					<script>function tecGetBetaTester()
  return tecSettings.betaTester
end --function tecGetBetaTester</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Player Development Folders</name>
					<packageName></packageName>
					<script>--if the player development table does not exist, create it.
if not PlayerDev then PlayerDev = {} end</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.SetPackages()</name>
						<packageName></packageName>
						<script>--Install or remove player development packages.
 function PlayerDev.SetPackages(mode)
  mode = fuzzyBoolean(mode)
  --table contains information on packages needing installation
  local packageTable = { trigger = { file = "Your_Triggers.xml"},
                         alias   = { file = "Your_Aliases.xml"},
                         script  = {file  = "Your_Scripts.xml"}, 
                         timer   = {file  = "Your_Timmers.xml"},
                         keybind = {file  = "Your_Key_Bindings.xml"},
                       }
  
  --loop through the packageTable. Check if the package needs to be installed.
  for packageType, packageToInstall in pairs(packageTable) do
    --the folder the package makes after it is installed.
    local packageFolder = packageToInstall.file:match("^(%a+_%a+_?%a*)")
    debugToDisplay("function PlayerDevCreateScripts, packageType is "..packageType..", packageToInstall.file is "
      ..packageToInstall.file.." packageFolder is "..packageFolder)
    local localPackageFile = tecSettingsFolder..packageToInstall.file --full folder and file name of package to install
    if mode then --if the function was sent true, install needed packages.
      if exists(packageFolder, packageType) == 0 then --check if the package's folder does not exist
        --check if the file for the package exists, if it does install it.
        if io.exists(localPackageFile) then --package file found
          debugToDisplay("function PlayerDevCreateScripts, "..localPackageFile
            .." found attempting package installation.")
          installPackage(localPackageFile) --install the package.
        else --the file for the package does not exist, show an error.
          errorFound = "player package file "..localPackageFile.." does NOT exits.\n"
          tecErrorNotification("function PlayerDevCreateScripts, "..errorFound)
        end --if io.exists(localPackageFile)
      end --if exists(packageFolder, packageType)
    else --mode is false, remove the player packages
      if exists(packageFolder, packageType) &gt; 0 then --check if the package's folder exist
          uninstallPackage(packageFolder) --remove the package.
          tecSettings.PlayerDevelopmentSpaceEnabled = mode
      else --the package does not exist.
          errorFound = "player package "..packageFolder.." does NOT exits.\n"
          tecErrorNotification("function PlayerDevCreateScripts, "..errorFound)
       end --if exists(packageFolder, packageType) &gt; 0
    end --if mode
  end --for pairs(packageTable)
  if not mode then --if uninstalling packages
    pecho("Packages removed. If changes are not saved, packages will reinstall with next update.\n")
    dontForgetToSave() --tell player to save
  end --if not mode
end --function PlayerDev.SetPackages(mode)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.Triggers()</name>
						<packageName></packageName>
						<script>--create triggers in the player development space.
--reference https://wiki.mudlet.org/w/Manual:Lua_Functions
function PlayerDev.Triggers()

  --[[
  To add a trigger to a player's development space, it needs to be in the triggersTable
  An example of a trigger to add to the triggersTable is:
  COPY BELOW  
    subTableNameMustBeUnique = { 
        name = "Trigger name, must be unique", 
        parent = "Player Game Events",
        triggerType = "substring",
        patterns = {"trigger ", "patterns here"},
        code = "--Should be a commented description.\n" }
  COPY ABOVE
    name, is the name that will show in the triggers section of the editor.
    parent, is the group the trigger needs to go in. Most likely will be "Player Game Evets"
    triggerType, can be "substring" "regex" or "beginofline"
    patterns, is a table. It can contain one or more triggers like "You fall"
      The patterns have to be surrounded by {}, with commas between each trigger.
      for example {"trigger one", "trigger two", "trigger three}
    code, is the lua code that the trigger will run. I recommend making this commented
      code to describe when the trigger will trigger.
  ]]--
  
  local triggerSuffix = " -Do not change this name-" --Will be added to the end of each trigger. To give it a unique name and tell player not to change it.
  local playerTriggersParentGroup = "Player Game Events"..triggerSuffix

  local triggersTable = {

    PlayerApproaches = { 
      name = "Player approaches a character", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"You stop next to "},
      code = "--triggers when the player approaches something.\n" },

    PlayerRetreat = { 
    	name = "Player retreats", 
    	parent = playerTriggersParentGroup,
    	triggerType = "beginofline",
    	patterns = {"You retreat."},
    	code = "--triggers when a player retreats or falls back.\n" },

    PlayerIsApproached = { 
	   name = "Player is approached", 
	   parent = playerTriggersParentGroup,
	   triggerType = "substring",
	   patterns = {"stops next to you."},
	   code = "--triggers when a player's character is approached.\n" },

    CharacterEntersRoom = { 
      name = "Character walks into players room", 
	    parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"walks in", "runs in", "flies in"},
      code = "--triggers when a character enters the players room.\n" },

    CharacterLeavesRoom = { 
      name = "Character leave players room", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"walks away", "runs away", "flies away"},
      code = "--triggers when a character leaves the players room.\n" },
      
    NPCSpawns = { 
      name = "Character Arrives", 
      parent = playerTriggersParentGroup,
      triggerType = "substring",
      patterns = {"arrives."},
      code = "--triggers when an NPC is spawned.\n" },
      
    PlayerRoomChange = { 
      name = "Player enters a room", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"You arrive at "},
      code = "--triggers when the player enters a new room.\n" },
      
    SuccessfulLogin = { 
      name = "Successful login", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"&lt;center&gt;*** Login successful"},
      code = "--triggers after a successful login.\n" },
      
    VisionLoss = { 
      name = "Vision loss", 
      parent = playerTriggersParentGroup,
      triggerType = "beginofline",
      patterns = {"It is too dark to see anything."},
      code = "--Triggers when the player can not see.\n" }
  } --substringTriggers

  --loop through the triggers to install.
  --if they do no already exist. Install them.
  for _, triggerTable in pairs(triggersTable) do
    local createTrigger = nil --Will be used to store a function to create desired trigger type
    if exists(triggerTable.name..triggerSuffix, "trigger") == 0 then --the trigger does NOT exists
      debugToDisplay("function PlayerDev.Triggers, Trigger "..triggerTable.name
        ..triggerSuffix.." does not exist, creating it.\n")
      --Find the type of trigger being created. 
      --Once found make createTrigger a copy of the function needed to create the trigger
      if triggerTable.triggerType:lower() == "substring" then --check the type of trigger needed to be made
        createTrigger = permSubstringTrigger --createTrigger is now permSubstringTrigger, it will create a substring trigger when called
      elseif triggerTable.triggerType:lower() == "beginofline" then --check the type of trigger needed to be made
        createTrigger = permBeginOfLineStringTrigger --createTrigger is now permBeginOfLineStringTrigger, it will create a begin of line or start of line trigger when called
      elseif triggerTable.triggerType:lower() == "regex" then --check the type of trigger needed to be made
        createTrigger = permRegexTrigger --createTrigger is now permRegexTrigger, it will create a perl regex trigger when called
      else --no good trigger type found
        tecErrorNotification("function PlayerDev.Triggers, no good trigger type found. "
          .."Correct trigger types are substring, beginofline and regex.")
      end --if TriggerTable.triggerType.lower() == "substring"
      if exists(triggerTable.parent, "trigger") == 0 then --the parent ground the trigger needs to go to does not exist
        tecWarningNotification("function PlayerDev.Triggers, parent group "..triggerTable.parent.." does not exist.\n") 
      else --the parent group to the trigger exists, so make the trigger.
        createTrigger(triggerTable.name..triggerSuffix, triggerTable.parent, triggerTable.patterns, triggerTable.code)
        disableTrigger(triggerTable.name..triggerSuffix) --disable the trigger, so it is not needlessly checked
      end --if exists(triggerTable.parent, "trigger") == 0
    end --if exists(TriggerName, "trigger") == 0
  end --for pairs(triggersTable)

end --function PlayDevSubstringTriggers()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.GetEnabled()</name>
						<packageName></packageName>
						<script>--returns if the player development mode
function PlayerDev.GetEnabled()
  if tecSettings.PlayerDevelopmentSpaceEnabled then --if the variable exists and is true
    return tecSettings.PlayerDevelopmentSpaceEnabled --return it
  else --if the variable does not exist.
    return false --We know the player has not set the enabled variable, so return false
  end --if tecSettings.PlayerDevelopmentSpaceEnabled
end --function PlayerDev.Get()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.Update()</name>
						<packageName></packageName>
						<script>--Add new code to the players development folders.
function PlayerDev.Update(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  if PlayerDev.GetEnabled() then --if player dev space is enabled
    if displayToScreen then pecho("Checking if player development modules need to be installed.\n") end
    PlayerDev.SetPackages(true) --Install modules if they do not already exist.
    if displayToScreen then pecho("Installing new player development triggers.\n") end
    PlayerDev.Triggers() --create player triggers
    if displayToScreen then pecho("Completed updating player development folders.\n") end
  end --if PlayerDev.GetEnabled()
end --function PlayerDev.runUpdate()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>PlayerDev.SetEnabled(mode)</name>
						<packageName></packageName>
						<script>--set and save if the player wanted their player development space created
function PlayerDev.SetEnabled(mode)
  mode = fuzzyBoolean(mode) --make certain correct boolean sent.
  tecSettings.PlayerDevelopmentSpaceEnabled = mode --make certain this setting can be saved
  if mode then --player wants the player development space created.
    pecho("Creating folders for you in the script editor. Each section will have a folder "
      .."starting with Your_. Save your code to these folders.\nWe will never remove "
      .."code from these folders. With updates we may add code to these folders. "
      .."Only if it will not replace code you have created. In mudlet\'s editor "
      .."folders are called groups.\n")
    PlayerDev.Update() --installed player modules and code, or updates it
    pecho("Player development folders have been created. "
      .."Press alt\+e to open the script editor.\n")
  else --player does not want to contine to receive updates.
    pecho("If you save changes, you will no longer receive updates to the player "
      .."Your_ folders in the editor. This will not remove those folders.\n")
  end --if mode
  dontForgetToSave()
end --function PlayerDev.set(mode)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>Git Updates</name>
					<packageName></packageName>
					<script>--Installs updates from github.
--Intended for projects that do not support downloading over telnet
--To allow error checking package file names must contain package type starting with a capitol
--IE: "My Project Name Scripts.xml" or "MyPackageNameTriggers.xml".

--start of section dedicated for functions used by update process.
--To understand the flow of updates you will need to scroll past these.
--There will be a comment stating when update flow starts.

-- fuzzyBoolean Provided by demonnic
-- Expands boolean definitions to be more flexible.
-- True values are "true", "yes", "0", 0, and true
-- False values are "false", "no", "1", 1, false, and nil
-- @param bool item to test for truthiness
if not fuzzyBoolean then
  function fuzzyBoolean(bool)
    if type(bool) == "boolean" or bool == nil then
      return bool
    elseif tostring(bool) then
      local truth = {
        "yes",
        "true",
        "0"
      }
      local untruth = {
        "no",
        "false",
        "1"
      }
      local boolstr = tostring(bool)
      if table.contains(truth, boolstr) then
        return true
      elseif table.contains(untruth, boolstr) then
        return false
      else
        return nil
      end
    else
      return nil
    end
  end
end --if not fuzzyBoolean

function GitUpdateconfig() --Create variables used for updates

  if GitUpdate then 
    --if events were previously created, kill them.
    if GitUpdate.downloadDoneID then
      killAnonymousEventHandler(GitUpdate.downloadDoneID)
    end --if GitUpdate.downloadDoneID
    if GitUpdate.downloadErrorID then
      killAnonymousEventHandler(GitUpdate.downloadErrorID)
    end --if GitUpdate.downloadErrorID
    if GitUpdate.installPackageID then
      killAnonymousEventHandler(GitUpdate.installPackageID)
    end --if GitUpdate.installPackageID
    if GitUpdate.uninstallPackageID then
      killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
    end --if GitUpdate.downloadDoneID
  end --if GitUpdate

  GitUpdate = GitUpdate or {} --table to hold project variables

  --API URL for git hub for project
  GitUpdate.gitReleaseURL = [[https://api.github.com/repos/TheEternalCitizens/mudlet-integration/releases]]
  GitUpdate.localRespitory = getMudletHomeDir().."/settings/" --local directory for source files
  if not io.exists(GitUpdate.localRespitory) then --if folder does not exists
    lfs.mkdir(GitUpdate.localRespitory) --create the folder
    debugToDisplay("Update: ERROR localRespitory was not present. Has been created.")
  end --if GitUpdate.localRespitory not exist
  GitUpdate.gitReleaseURLJSONFile = "ParthiaLatest.json" --local file name REST API latest JSON
  GitUpdate.localVersion = "0.1.47" --Must match the tag in your github release
  GitUpdate.aliasName = "parthia update" --Name of alias user runs to process update
  --Name of the alias to check if an update is available.
  GitUpdate.updateCheckAlias = "parthia update check" 
  --The full name or a word in the file that this update script is in.
  GitUpdate.updateFileNameReference = "Scripts"
  --notify update engine if player is a beta tester. If the player is a beta
  --tester they will receive update notices for pre-releases for your project
  GitUpdate.betaTester = tecSettings.betaTester 
  --packages that are no longer used in the project and should be removed.
  --They can not share a name with a package that you need. Otherwise this will uninstall it.
  GitUpdate.removePackages = {"TECClientScripts", "TECClientTriggers",
    "TECClientAliases", "TECClientKeyBindings", "Courses_Alias", "Courses_Triggers"}
  GitUpdate.removeModules = {} --modules that are no longer used in the project and should be removed.
  --Used to tell player correct installation method if they installed scripts as modules
  GitUpdate.installationURL = "https://github.com/TheEternalCitizens/mudlet-integration/wiki/Installation"
  --use in a repair aliase, set this variable to true if a repair install is needed.
  GitUpdate.repairInstall = fuzzyBoolean(GitUpdate.repairInstall)
  --cecho compatible color, it will hightlight cecholinks in the update process
  GitUpdate.cmdHighlight = "blue"
  --Copy a function you would like to have run when an update is completed.
  --Make false if you do not want it to run after the update has completed.
  GitUpdate.postUpdateFunction = PlayerDev.Update

  --No need to change variables below
  GitUpdate.filePattern = ".*%/(.*%..*)$" --string pattern to detect file name at end of url or file path string
  GitUpdate.downloadError = false --Sets to true if there is a download error.
  GitUpdate.installationError = false --sets to true if there is a package installation error.
  GitUpdate.installationInProgress = false --notifies update engine if update is running.
  GitUpdate.releaseIndex = 0 --Position on proper update in gitHub JSON table
  GitUpdate.trackedURLs = {} --will be URLs that need to have downloads tracked
  --create event handlers.
  GitUpdate.downloadDoneID = registerAnonymousEventHandler("sysDownloadDone", "GitUpdateEventHandler")
  GitUpdate.downloadErrorID = registerAnonymousEventHandler("sysDownloadError", "GitUpdateEventHandler")
  GitUpdate.installPackageID = registerAnonymousEventHandler("sysInstallPackage", "GitUpdateEventHandler")
  GitUpdate.uninstallPackageID = registerAnonymousEventHandler("sysUninstallPackage", "GitUpdateEventHandler")
  trackedDownloads = {} --leave blank, needed for events. Is initialized in function trackDownloads
  trackedDownloads.fileList = "" --leave blank, needed for events. Initialized in function trackDownloads
  trackedDownloads.urlList = "" --leave blank, used to check for download errors.
  
  debugToDisplay("function GitUpdate.config: Initialized update engine.\n\tgitReleaseURL: "..GitUpdate.gitReleaseURL
    .."\n\tScriptFileNameReference: "..GitUpdate.updateFileNameReference
    .."\n\tlocalRespitory: "..GitUpdate.localRespitory
    .."\n\tgitReleaseURLJSONFile: "..GitUpdate.gitReleaseURLJSONFile
    .."\n\tLocal Parthia version: "..GitUpdate.localVersion)
end --function GitUpdateconfig()

--displays messages to debugc.
--can be changed to send to what ever console you would like with cecho
if not debugToDisplay then 
  function debugToDisplay(textMessage)
  		debugc(textMessage) -- print message to screen
  end --end displayToDebug function
end --if not debugToDisplay

if not pecho then
  pecho = cecho
end

if not pechoLink then
  pechoLink = cechoLink
end

--Displays a yellow notice to debug console
if not tecWarningNotification then
  --fully notifies user when an error is found.
  function tecWarningNotification(errorFound)
    debugc("Warning: "..errorFound)
  end --function tecErrorNotification
end --if not tecWarningNotification then

if not ReplaceStringMagicChar then
  --used to replace magic characters in a string with the proper escape character 
  --sequence. Useful for replacing file names on sysDownload events.
  function ReplaceStringMagicChar(tmpString)
    tmpString = tmpString:gsub("%%", "%%%")
    tmpString = tmpString:gsub("%(", "%%(")
    tmpString = tmpString:gsub("%)", "%%)")
    tmpString = tmpString:gsub("%.", "%%.")
    tmpString = tmpString:gsub("%+", "%%+")
    tmpString = tmpString:gsub("%[", "%%[")
    tmpString = tmpString:gsub("%^", "%%^")
    tmpString = tmpString:gsub("%$", "%%$")
    tmpString = tmpString:gsub("%-", "%%-")
    tmpString = tmpString:gsub("%*", "%%*")
    tmpString = tmpString:gsub("%?", "%%?")
  return tmpString
  end --function ReplaceStringMagicChar(tmpString)
end --if not ReplaceStringMagicChar

--displays a message to player that an error was found, and to contact a developer
if not tecErrorNotification then 
  function tecErrorNotification(errorFound)
    debugc("Error: "..errorFound)
    cecho("&lt;red:&gt;Error: "..errorFound.."\n\tPlease contact a developer.")
  end --function tecErrorNotification
end --if not tecErrorNotification

--Used to easily change update notification. There are multiple instances where
--Parthia notifies player an update is available.
local function updateAvailable(updateBody)
  --if this is a repair install. Download and install without prompting player.
  if GitUpdate.repairInstall then 
    --Start downloading scripts as a temptimer so the function that called
    --updateAvailable can complete.
    tempTimer(1, "DownloadGitScripts()")
    GitUpdate.repairInstall = false --reset so it will not run if player checks for updates
  else --this is not a repair install prompt the user if they would like to update.
    enableAlias(GitUpdate.aliasName) --enable alias so user can run update with command
    if pecho then --if parthia echo exists
      pecho("An update is available. The new features it offers are: \n\t")
      pecho(updateBody)
      pecho("\n&lt;:maroon&gt;To update now, run command ")
      pechoLink("&lt;:blue&gt;"..GitUpdate.aliasName, --link text to display
        [[expandAlias(GitUpdate.aliasName)]], --link command to run
        "Update game client", true) --link tool tip for mouse hover
      echo("\n") --cechoLinks don't cause the window to autoscroll.
    else --parthia echo does not exist
      cecho("An update is available. The new features it offers are: \n\t")
      cecho(updateBody)
      cecho("\n&lt;:maroon&gt;To update now, please run: ")
      cechoLink("&lt;:blue&gt;"..GitUpdate.aliasName, --link text to display
        [[expandAlias(GitUpdate.aliasName)]], --link command to run
        "Update game client", true) --link tool tip for mouse hover
      echo("\n") --cechoLinks don't cause the window to autoscroll.
    end --if pecho
  end --if GitUpdate.repairInstall
end --function updateAvailable

--gather urls from github release that player needs to update to
local function collectURLs()
  if GitUpdate.releaseIndex == 0 then --make certain releaseIndex has been initialized
    debugc("function: collectURL, url collection releaseIndex was not initialized.")
    return "function: compareVersions, url collection releaseIndex was not initialized."
  elseif GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets.browser_download_url then
    debugc("function: collectURL, url collection JSONTable lacks assets.")
    return "function: compareVersions, url collection JSONTable lacks assets."
  else
    for index, gitAsset in --loop through git release assets.
      ipairs(GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets) do
        --save URL needing download to a new table.
        --debugc("function: compareVersions tracking URL: "..gitAsset.browser_download_url)
        GitUpdate.trackedURLs[index] = gitAsset.browser_download_url
    end --for GitUpdate.gitJSONTable[GitUpdate.releaseIndex].assets
    debugToDisplay("function collectURLs(): GitUpdate.trackedURLs initialized.") 
  end --if releaseIndex == 0
end --collectURLS

--Search for latest nonbeta release or release that is NOT a prerelease
--function is here to reduce complexity of function that calls it.
local function releaseSearch()
  if GitUpdate.gitJSONTable[1].name then --if the table exists
    --debugc("gitUpdate release search, JSON table exists.")
    for index, releaseData in ipairs(GitUpdate.gitJSONTable) do --loop through the JSON table
      --debugc("gitUpdate release search, searching index: "..tostring(index))
      debugToDisplay("function releaseSearch, searching index: "..tostring(index))
      --Find the latest release that is NOT a prerelease.
      if not releaseData.prerelease then --if the release is not a prerelease
        --debugc("gitUpdate release search, found latest release at: "..tostring(index))
        debugToDisplay("function releaseSearch, found latest release at: "..tostring(index)
          .."\n\tRelease tab_name: "..releaseData.tag_name
          .." Local release: "..GitUpdate.localVersion)
        --If the installed Parthia is different that latest release
        if releaseData.tag_name ~= GitUpdate.localVersion then
          GitUpdate.releaseIndex = index --collect the release index
          local errorFound collectURLs() --gather URLs into trackedURLs table
          if errorFound then --collectURLs returns a string if error occured.
            return errorFound
          else
            updateAvailable(releaseData.body) --notify player an update is available
            return
          end --if errorFound else
        else --if releaseData.tag_name ~= GitUpdate.localVersion, Parthia up to date.
          --if this is a repair install. Run the update even if the versions match 
          if GitUpdate.repairInstall then
            GitUpdate.releaseIndex = index --collect the release index
            local errorFound collectURLs() --gather URLs into trackedURLs table
            if errorFound then --collectURLs returns a string if error occured.
              return errorFound
            else
              updateAvailable(releaseData.body) --notify player an update is available
              return --end releaseSearch
            end --if errorFound
          else --this is not a repair install. So let the player know no update is available.
            if pecho then pecho("Parthia is up to date.\n")
            else cecho("Parthia is up to date.\n") end
            return --end releaseSearch()
          end 
        end --if releaseData.prerelease.tag_name ~= GitUpdate.localVersion
      end --if releaseData.prerelease == "false"
    end --for
  else --if the JSON table does NOT exist.
    errorFound = "function releaseSearch, Error, JSON table not found during release search."
    return errorFound--error found stop update.
  end --if GitUpdate.gitJSONTable[1].name exists
end --function releaseSearch

--Tracks downloads so updates do not start until all downloads have completed.
--This has been created to allow it to be module.
--downloadURL is a table containing a urls that need to be downloaded.
--!!!trackDownloads(downloadURLs) HAS to be ran BEFORE the downloads are initiated!!!
function trackDownloads(downloadURLs)  
  if downloadURLs[1] then --if downloadURLs is a table
    debugToDisplay("function trackDownloads, table passed.")
    --move the URL containing the script name to the end of the table.
    for index, urlToTrack in ipairs(downloadURLs) do
      if urlToTrack:match(GitUpdate.updateFileNameReference) then
        debugToDisplay("function trackDownloads, URL containing update script was found at\n\t"
          ..urlToTrack.." moving it to end of table.")
        table.remove(downloadURLs, index) --remove the URL from the table
        table.insert(downloadURLs, urlToTrack) --insert it on the end of the table
        break --Update script can only be in one file.
      end --urlToTrack:match(GitUpdate.updateFileNameReference)
    end --for downloadURLs
    --Make a global table to store URLs that require tracking.
    trackedDownloads = {files = {}, URLs = {}, downloaded = {}, fileList = "", tmpFiles = {}
                        , urlList = ""}
    for index, urlToTrack in ipairs(downloadURLs) do --initialize trackedDownloads table
      --Get the name of the file you need to download.
      local TmpPackageFileName = urlToTrack:match(GitUpdate.filePattern)
      --debugc("TmpPackageFileName "..TmpPackageFileName)
      --Collect package name removing any .s periods that are in it.
      --in git releases spaces in filenames are replaced with .s mudlets install package process
      --is sometimes not compatible with this.
      local PackageNameNoExtension = string.gsub(TmpPackageFileName:match("(.*)%..*$"), "%.", " ") 
      --debugc("PackageNameNoExtension: "..PackageNameNoExtension)
      local PackageNameExtensionOnly = TmpPackageFileName:match(".*(%..*)$")
      --debugc("PackageNameExtensionOnly: "..PackageNameExtensionOnly)
      --Combine the package name with file extension.
      trackedDownloads.files[index] = PackageNameNoExtension..PackageNameExtensionOnly
      debugToDisplay("function: trackDownloads tracking file: "..trackedDownloads.files[index])
      --Boolean to notify client when download has completed.
      trackedDownloads.downloaded[index] = false
      --Get the name of the file you need to download.
      trackedDownloads.URLs[index] = urlToTrack
      --create a string that contains a list of files needing download.
      --This list will be used during sysDownloadDone event to veirfy the correct download
      trackedDownloads.fileList = trackedDownloads.fileList..trackedDownloads.files[index].." "
      --Used to catch download errors.
      trackedDownloads.urlList = trackedDownloads.urlList..urlToTrack.." "
    end --for downloadURLs

  elseif type(downloadURLs) == "string" then --if the variable passed is a string
    debugToDisplay("function: trackDownloads string passed.")
    debugToDisplay("function trackedDownloads: URL passed: "..downloadURLs)  
    if trackedDownloads.files[1] then --make certain the trackedDownloads table exists
      --Look through trackedDownloads table to see if this is one of the tracked URLs
      for index, trackedDownload in ipairs(trackedDownloads.files) do      
        --if the string passed matches a file name in trackedDownloads
        if trackedDownload:match(downloadURLs) then
          debugToDisplay("function trackedDownload: download completed and recorded for: "
            ..trackedDownload)
          trackedDownloads.downloaded[index] = true --record that this URL downloaded successfully.
            --check if all downloads have completed.
            for index, urlDownloaded in ipairs(trackedDownloads.downloaded) do
              if urlDownloaded then --has the current URL affiliaed with the bool been downloaded.
                --debugc("function trackedDownloads: Verifing download completed for index "..index)
                --If all downloaded booleans in table are true.
                if index == #trackedDownloads.downloaded then
                  debugToDisplay("function trackedDownloads: downloads completed.")
                  return true --tells parthia all downloads are complete.
                end --if index == #trackedDownloads.downloaded
              else --Some file in the set has not been downloaded.
                return false --tells parthia all downloads are not complete
              end --if urlDownloaded
            end --for trackedDownloads.downloaded
          break --break the for loop.
        end --if trackedDownload == downloadURLs
      end --for trackedDownloads
    else
      --display error to debug, and return error message to called function
      errorc("function trackDownloads: was not initialized with a table of URLs.")
      return "function trackDownloads: was not initialized with a table of URLs."
    end --if downloadURLs
  else --argument was not a table or string.
    local errorFound = "function trackDownloads: does not accept "..type(downloadURLs)
      .." as an argument.\n\tOnly supports tables for initilization and strings for tracking."
    errorc(errorFound)
    return errorFound
  end --if downloadURLs type check
end --function trackDownloads

--Here moving forward if you would like to understand the flow of updates
--it starts here.

--downloads the github JSON REST API JSON file
function DownloadGitReleaseJSON()
  --check if an installation is in progress.
  if GitUpdate then if GitUpdate.installationInProgress then
    echo("An update is currently processing. Only one update can run at a time.\n")
    return --stop updates one is processing.
  end end
  GitUpdateconfig() --initialize update engine.
  GitUpdate.installationInProgress = true --notify Parthia an update is in progress
  debugToDisplay("Update: Downloading "..GitUpdate.gitReleaseURL
    .."\n\tTo: "..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
  downloadFile(GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile,
    GitUpdate.gitReleaseURL) --download the projects latest release JSON info file.
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
end --function DownloadGitReleaseJSON

--after the JSON files is downloaded GitUpdateEventHandler will run compareVersions

--check if version in use is the latest released
--If player is beta test we compare the latest release both prerelease and release 
--If standard player we look for latest release not prerelease
local function compareVersions()
  debugToDisplay("function compareVersions, opening &amp; reading file:\n\t"
    ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
  --open the local github latest release JSON file in read only mode
  local gitJSONFile, errorFound = 
    io.open(GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile, "r")
  if not gitJSONFile then --file was not created error occured.
    tecErrorNotification("function compareVersions: "..errorFound)
    gitJSONFile:close() --incase of partial failure, close file.
    gitJSONFile = nil
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return  --error found stop update.
  end --if not gitJSONFile
  local gitJSONString = gitJSONFile:read("*a") --read the entire file to a string
  gitJSONFile:close() --close the file
  gitJSONFile = nil
  if not gitJSONString then --the file did not read correctly.
    tecErrorNotification("function compareVersions, file read failure.\n\t"
      ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile)
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --error found stop update.
  end --if not gitJSONString
  --Convert github release JSON into a table
  GitUpdate.gitJSONTable = yajl.to_value(gitJSONString)
  if GitUpdate.gitJSONTable[1].name then --if the table was made.
    debugToDisplay("function compareVersions, file read successful.")
  else --if the table was not successfully made we can not continue. Notify player.
    errorFound = "Update: Error, JSON to table conversion unsuccessfull.\n\tOpened file: "
      ..GitUpdate.localRespitory..GitUpdate.gitReleaseURLJSONFile
      .."\n\tIt contained: "..gitJSONString
    tecErrorNotification(errorFound) --Notify player provide method to report error
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --error found stop update.
  end --GitUpdate.gitJSONTable exists
  
  --Look the table for the latest non beta release.
  if GitUpdate.betaTester then --if player is a beta tester install latest release   
    --if latest release tag_name does not match local version number.
    debugToDisplay("Update: Release installed: "..GitUpdate.localVersion
      .."\n\tLatest release: "..GitUpdate.gitJSONTable[1].tag_name)
    if GitUpdate.gitJSONTable[1].tag_name ~= GitUpdate.localVersion then
      GitUpdate.releaseIndex = 1 --notify update engine which version to use
      updateAvailable(GitUpdate.gitJSONTable[1].body) --notify player update is available
      local errorFound collectURLs() --gather URLs into trackedURLs table
      if errorFound then
        tecErrorNotification(errorFound)
        GitUpdate.installationInProgress = false --notify Parthia installation not running.
        return --error found stop update.
      end --if error found
    else
      --if this is a repair install. Run the update even if the versions match 
      if GitUpdate.repairInstall then
        GitUpdate.releaseIndex = 1 --collect the release index
        local errorFound collectURLs() --gather URLs into trackedURLs table
        if errorFound then --collectURLs returns a string if error occured.
          tecErrorNotification(errorFound)
          GitUpdate.installationInProgress = false --notify Parthia installation not running.
        else
          updateAvailable(GitUpdate.gitJSONTable[1].body) --notify player an update is available
          return --end releaseSearch
        end --if errorFound
      else --this is not a repair install. So let the player know no update is available.
        if pecho then pecho("Thank you for beta testing!\n\tNo new releases at this time.\n")
        else cecho("Thank you for beta testing!\n\tNo new releases at this time.\n") end
      end --if GitUpdate.repairInstall
    end --if beta tester is not using latest release
  else --The user is not a beta tester.
    local errorFound = releaseSearch() --search for latest NONbeta release
    if errorFound then
      tecErrorNotification(errorFound)
      GitUpdate.installationInProgress = false --notify Parthia installation not running.
      return --error found stop update.
    end --if error found
  end --if betaTester

  --We do not know how large the git release JSON is we will trash it just incase
  --doing this after error catch, if error is found this table will still exist
  GitUpdate.gitJSONTable = nil
  
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
  
end --function compareVersions

--The user has now run the aliase GitUpdate.aliasName to continue forward.

--Download the scripts in the latest release 
function DownloadGitScripts()
  --turn off the standard update command. So user will not attempt to run it while
  --it is running. Also leave it off so user can not process an update when one 
  --is not required.
  disableAlias(GitUpdate.aliasName)
  GitUpdate.downloadError = false --in case of previous download error.

  --check if an installation is in progress.
  if GitUpdate.installationInProgress then
    if pecho then
      pecho("An update is currently processing. Please wait for it to complete.\n"
        .."Once the update is done you will need to check if an update is still "
        .."required by running: ")
      pechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;"..GitUpdate.updateCheckAlias, 
        [[DownloadGitReleaseJSON()]],
        "Check for updates", true)
    else
      echo("An update is currently processing. Please wait for it to complete.\n"
        .."Once the update is done you will need to check if an update is still "
        .."required by running: ")
      cechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;"..GitUpdate.updateCheckAlias, 
        [[DownloadGitReleaseJSON()]],
        "Check for updates", true)
    end
    return
  end
  GitUpdate.installationInProgress = true --notify Parthia an update is in progress

  --if GitUpdate.trackedURLs has been initialized.
  if type(GitUpdate.trackedURLs[1]) == "string" then 
    trackDownloads(GitUpdate.trackedURLs) --initialize trackDownloads
  else --GitUpdate.trackedURLs was not initialized throw error.
    errorFound = "function DownloadGitScripts, trackedURLs was not initialized."
    tecErrorNotification(errorFound)
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
    return --stop because we can not proceed.
  end --if GitUpdate.trackedURLs is not nil.

  --download the files required.
  for index, trackedDownload in ipairs(GitUpdate.trackedURLs) do
    debugToDisplay("function DownloadGitScripts, downloading "
      ..trackedDownload.."\n\tto "
      ..GitUpdate.localRespitory..trackedDownloads.files[index])
    --download file
    downloadFile(GitUpdate.localRespitory..trackedDownloads.files[index], trackedDownload)
  end --for GitUpdate.trackedURLs

end --function GitUpdate.downloadScripts()

--After all files have been downloaded GitUpdateEventHandler will call InstallGitUpdates

local function InstallGitUpdates()
  if GitUpdate.downloadError then --if a download error occured.
    tecErrorNotification("function InstallGitUpdates, Download error occured. Update can not be processed.\n")
    GitUpdate.downloadError = false --Reset now that we have caught the error.
  end --if GitUpdate.downloadError
  local localSourceDirectory = GitUpdate.localRespitory --Keep required data outside of GitUpdate
  for index, fileName in ipairs(trackedDownloads.files) do --loop through scripts, and install them
    local packageName = fileName:match("(.*)%.") --remove extension from filename
    local packageTypeList = {"alias", "trigger", "timer", "keybind", "script", 
                             "Alias", "Trigger", "Timer", "Keybind", "Script",
                             "KeyBind"}                               
    for index, packageTypeName in ipairs(packageTypeList) do
      packageType = packageName:match(packageTypeName) --find packageType in the package name
      if packageType then --package name contains a package type. Use it to error check.
        debugToDisplay("function InstallGitUpdates: Package type found, "
          ..packageType..". Error checking will be processed for" ..packageName)
        break --packageType found. Contining this would would nil packageType
      end --if packageType
    end --for ipairs(packageTypeList)

    --if this package is installed as a module. Do not install it.
    if getModulePath(packageName) then
      local errorFound = packageName..", is installed as a module. Having one script installed as "
        .."both a module and a package is not supported."
      tecWarningNotification("function InstallGitUpdates, "..errorFound)
      pecho(errorFound.." If you are not a developer player installation instructions "
        .."can be found ")
      pechoLink("&lt;:"..GitUpdate.cmdHighlight.."&gt;here", 
        [[openUrl("]]..GitUpdate.installationURL..[[")]],
        "Player installation site", true)
      cecho("\n")
      
    else --script is not installed as a module already proceed with instalation as package
      uninstallPackage(packageName) --remove old package
      --comment out uninstallPackage and uncomment raiseEvent to test without uninstalling package
      --raiseEvent("sysUninstallPackage", packageName)
      
      if packageType then --package name contains a package type. Use it to error check.
        if 0 ~= exists(packageName, packageType) then --if packagename appears in mudlet
          debugToDisplay("&lt;yellow:&gt;Warning function InstallGitUpdates: appearance of the package "
            ..packageName.." in the "..packageType.." section unexpected.")
        end --if 0 ~= exists(packageName, packageType)
      end --if packageType
      
      installPackage(localSourceDirectory..fileName) --install new package
      --comment out installPackage and uncomment raiseEvent to test without installing package
      --raiseEvent("sysInstallPackage", packageName, localSourceDirectory..fileName)
      
      if packageType then --package name contains a package type. Use it to error check.
        if 0 == exists(packageName, packageType) then --if packageName does not exist in mudlet
          local errorFound = "function InstallGitUpdates: "..packageName.." was not found in "
            .." the "..packageType.." section. After package installation."
          tecErrorNotification(errorFound) --display error.
          GitUpdate.installationError = true --Notify InstallGitUpdates there is an error
        end --if 0 ~= exists(packageName, packageType)
      end --if packageType
    end --if getModulePath(packageName)

  end --for InstallGitUpdates
  
  if GitUpdate.installationError then --there were errors during installation.
    pecho("Errors during installation. Please report issues using the report issues button "
      .."in the settings window.\n")
    GitUpdate.installationInProgress = false --notify Parthia installation not running.
      --if events were previously created, kill them.
    if GitUpdate.downloadDoneID then
      killAnonymousEventHandler(GitUpdate.downloadDoneID)
    end --if GitUpdate.downloadDoneID
    if GitUpdate.downloadErrorID then
      killAnonymousEventHandler(GitUpdate.downloadErrorID)
    end --if GitUpdate.downloadErrorID
    if GitUpdate.installPackageID then
      killAnonymousEventHandler(GitUpdate.installPackageID)
    end --if GitUpdate.installPackageID
    if GitUpdate.uninstallPackageID then
      killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
    end --if GitUpdate.downloadDoneID
    return --stop update process
  end --if GitUpdate.installationError
  
  --go through list of unwanted packages and modules remove them. GitUpdate.removeModules
  for _, removeScriptsTable in pairs({GitUpdate.removePackages, GitUpdate.removeModules}) do
    for _, packageToRemove in ipairs(removeScriptsTable) do
      uninstallPackage(packageToRemove) --uninstall unwanted packages.
      --check for a folder that shares a name with an unwanted package in each section type
      for _, packageType in ipairs( {"alias", "trigger", "timer", "keybind", "script"}) do
        --if the a folder exists with the name of an unwanted package
        if (exists(packageToRemove, packageType) &gt; 0) then 
          tecWarningNotification("function InstallGitUpdates, package "
            ..packageToRemove.." was removed but a folder for it still exits "
            .."in the "..packageType.." section.")
        end --if exists(packageToRemove)
      end --for ipairs( "alias", "trigger", "timer", "keybind", "script")
    end --for ipairs(GitUpdate.removePackages) 
  end --for pairs(GitUpdate.removePackages, GitUpdate.removeModules)
  
  --resetProfile() --reset to profile so UI will properly reset.
  pecho("Loading display please wait.\n")
  UIManagerSetTheme("PlayersTheme", false) --reset the display
  debugToDisplay("Updates completed.\n")
  pecho("Updates completed.\n")
  GitUpdate.installationInProgress = false --notify Parthia installation not running.
  if (tecUsernameEntry or tecPasswordEntry) and passwordInputEventID then --if the user is in the middle of a login.
    tecUsernameEntry = true
    tecPasswordEntry = false
    cecho("\nPlease enter your username.\n")
  end --if (tecUsernameEntry or tecPasswordEntry) and passwordInputEventID
    --if events were previously created, kill them.
  if GitUpdate.downloadDoneID then
    killAnonymousEventHandler(GitUpdate.downloadDoneID)
  end --if GitUpdate.downloadDoneID
  if GitUpdate.downloadErrorID then
    killAnonymousEventHandler(GitUpdate.downloadErrorID)
  end --if GitUpdate.downloadErrorID
  if GitUpdate.installPackageID then
    killAnonymousEventHandler(GitUpdate.installPackageID)
  end --if GitUpdate.installPackageID
  if GitUpdate.uninstallPackageID then
    killAnonymousEventHandler(GitUpdate.uninstallPackageID) 
  end --if GitUpdate.downloadDoneID

  --runs a function specified in config
  if GitUpdate.postUpdateFunction then GitUpdate.postUpdateFunction(true) end

end --function InstallGitUpdates

function GitUpdateEventHandler(event, ...)
  if event == "sysDownloadDone" then --if it is a downloadDone event.
    --arg[1] is full file including directory
    --ReplaceStringMagicChar puts ecscape % before lua magic characters
    local file = ReplaceStringMagicChar(arg[1]) 
    debugToDisplay("function GitUpdateEventHandler, file downloaded post magic "
      .."character replacement it is:\n\t"..file)
    
    if GitUpdate.gitReleaseURLJSONFile:match(file:match(GitUpdate.filePattern)) then --download is version check file
      debugToDisplay("function GitUpdateEventHandler, Download: "..file
        .."\n\tcompareVersions() called.")
      compareVersions() --Use downloaded JSON file to check if latest version is installed
    --if the name of the file being downloaded is in trackedDownloads.fileList
    elseif trackedDownloads.fileList:match(file:match(GitUpdate.filePattern)) then
      local boolOrErrorMessage = trackDownloads(file:match(GitUpdate.filePattern))
          if boolOrErrorMessage then --if true, all files have downloaded.
            debugToDisplay("function GitUpdateEventHandler, all downloads completed. "
              .."Running function InstallGitUpdates()")
            InstallGitUpdates() --install the downloaded scripts
          elseif type(boolOrErrorMessage) == "string" then --if error found
            tecErrorNotification(boolOrErrorMessage) --notify player of error
          else --all downloads are not completed.
            debugToDisplay("function GitUpdateEventHandler, "..file.." completed downloading. Not all tracked files downloaded yet.")
          end --if boolOrErrorMessage
    else
      debugToDisplay("function GitUpdateEventHandler, Downloaded file: "..file
        .."\n\tWas NOT caught by event handler. If this SHOULD be a tracked download, system "
        .."attempted to track: "..file:match(GitUpdate.filePattern))
    end --elseif file downloaded is new script
  elseif event == "sysDownloadError" then --if there is a download error.
    local errorFound = arg[1] --sysDownloadError only argument is error message.
    local erroredURL = arg[1]:match(".*(https:%/%/%S+)") --retreive URL in error message
    --debugc("Errored URL: "..erroredURL)
    --if  then error download's URL matches downloads for this update engine
    if trackedDownloads.urlList:match(erroredURL) or GitUpdate.gitReleaseURL == erroredURL then
      tecErrorNotification("fuction GitUpdate.downloadErrorEventHandler, "..errorFound)
      GitUpdate.downloadError = true --notify InstallGitUpdates not to proceed.
    else --for any other download errors.
      debugToDisplay("fuction GitUpdate.downloadErrorEventHandler, "..errorFound)
    end --if trackedDownloads.urlList:match(erroredURL)
  elseif event == "sysInstallPackage" then --after a package has installed.
    local localInstalledPackageName = arg[1] --notify 
    local localInstalledPackageFileName = arg[2]
    debugToDisplay("function GitUpdateEventHandler: "..localInstalledPackageName.." package installed from file: "
      ..localInstalledPackageFileName)
  elseif event == "sysUninstallPackage" then --after a package has installed.
    local tecUninstalledPackage = arg[1]
    debugToDisplay("function GitUpdateEventHandler: "..tecUninstalledPackage.." package uninstalled.")
  end --if event name
end --function tecUpdate.eventHandler()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>parthia talk</name>
					<packageName></packageName>
					<script>--functions to manage the tts system.</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetVoice(voiceName, displayToScreen)</name>
						<packageName></packageName>
						<script>--set the voice the player wants to use.
function parthiaTalkSetVoice(voiceName, displayToScreen)
  
  displayToScreen = fuzzyBoolean(displayToScreen) --verify boolean is good.  
  --make certain variable passed is a string or a number.
  if not type(voiceName) == "string" or not type(voiceName) == "number" then
    tecErrorNotification("function parthiaTalkSetVoice, sent a non string variable for name.")
  end --if not type(voiceName) == "string"

  local ttsVoicesSupported = ttsGetVoices() --get list of voice types the player's system supports.
  local voiceNameCorrect = false --used to check if name sent matches one supported by the players computer.
  
  --check if voiceName is a supproted voice or index for ttsVoicesSupported table
  for integer, ttsName in ipairs(ttsVoicesSupported) do --loop through supported ttsnames table
    if type(voiceName) == "string" then --if voice name is a string
      if voiceName == ttsName then --if the voiceName sent matches a name supported by this system
        ttsSetVoiceByName(voiceName) --set the voice to voiceName
        voiceNameCorrect = true --the name was correct
        tecSettings.parthiaTalkVoice = ttsName --set voice name for startup
        if displayToScreen then
          pecho("Parthia talk voice set to "..ttsName..".\n")
          dontForgetToSave() --remind player to save
        end --if displayToScreen
      end --if voiceName == ttsName then
    elseif type(voiceName) == "number" then --if voice name is a number
      if voiceName == integer then --argument number passed is smaller or same size as ttsVoicesSupported table
        ttsSetVoiceByIndex(voiceName) --set the voice to index voiceName
        voiceNameCorrect = true --the name was correct
        tecSettings.parthiaTalkVoice = ttsName --set voice name for startup
        if displayToScreen then --if player ran command remind them to save
          pecho("Parthia talk voice set to "..ttsName..".\n")
          dontForgetToSave() --remind player to save
        end --if displayToScreen
      end --if voiceName == integer then
    end --if type(voiceName) == "string"
  end --of ipairs(ttsVoicesSupported)
  
  if not voiceNameCorrect then --if voiceName was incorrect show player correct usage
    if displayToScreen then --if player ran command send messages to screen
      pecho("Supported voice commands are ")
      for index, ttsName in ipairs(ttsVoicesSupported) do --loop through supported ttsnames table
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice "..ttsName, --show clickable command
          [[ parthiaTalkSetVoice("]]..ttsName..[[", true)]],
          "Set parthia talk name to "..ttsName, true)
        pecho("parthia talk voice "..ttsName, true) --speak message only if parthia talk is enabled
        pecho(" whose numbered version is ")
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk voice "..tostring(index), 
        [[ parthiaTalkSetVoice("]]..ttsName..[[", true)]],
        "Set parthia talk name to "..ttsName, true)
        pecho("parthia talk voice "..index, true) --speak message only if parthia talk is enabled
        pecho(". ")
      end --of ipairs(ttsVoicesSupported)
      pecho("\n")
    else
      --the default setting for tecSettings.parthiaTalkVoice is "" in function tecClientReset. Doing this allows parthia to use OS's default on startup after loading settings from file.
      if not voiceName == "" then 
        tecWarningNotification("function parthiaTalkSetVoice, automated call sent incorrect name or number. "
          .." function sent "..tostring(voiceName))
      end --if not voiceName == ""
    end --if displayToScreen
  end --if not voiceNameCorrect then

end --function parthiaTalkSetVoice(name)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetVoice()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetVoice()
  return tecSettings.parthiaTalkVoice
end --function parthiaTalkGetVoice()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetThoughts()</name>
						<packageName></packageName>
						<script>--get the enabled or disabled state of ParthiaTalkThoughts
function parthiaTalkGetThoughts()
  return tecSettings.parthiaTalkThoughts
end --function function parthiaTalkGetThoughts</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetThoughts(displayToScreen, mode)</name>
						<packageName></packageName>
						<script>--set if thoughts speak even if parthia talk is disabled
--mode is optional, normally it will toggle
function parthiaTalkSetThoughts(displayToScreen, mode)

  displayToScreen = fuzzyBoolean(displayToScreen) --should messages be displayed to player
  mode = fuzzyBoolean(mode) --set mode if it is not being toggled

  if mode == nil then --if mode was not passed at all
    if parthiaTalkGetThoughts() then --if parthia talk thoughts only is enabled
      tecSettings.parthiaTalkThoughts = false --switch parthia talk thoughts to off
      if displayToScreen then pecho("Parthia talk thoughts disabled\n") end
    else --if parthia talk thoughts is not enabled
      tecSettings.parthiaTalkThoughts = true --switch parthia talk thoughts to on
      if displayToScreen then pecho("Parthia talk thoughts enabled\n") end
    end --if parthiaTalkGetThoughts()
  else --if mode was passed
    tecSettings.parthiaTalkThoughts = mode --set variable to the mode passed
    if displayToScreen then pecho("Parthia talk thoughts set to "..tostring(mode).."\n") end
  end --if mode == nil
  
  if displayToScreen then dontForgetToSave() end --if player ran command remind them to save

end --parthiaTalkSetThoughts(displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetSpeech()</name>
						<packageName></packageName>
						<script>--get the enabled or disabled state of parthia talk speech
function parthiaTalkGetSpeech()
  return tecSettings.parthiaTalkSpeech
end --function function parthiaTalkGetSpeech</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetSpeech(displayToScreen, mode)</name>
						<packageName></packageName>
						<script>--set if game speech speaks even if parthia talk is disabled
--mode is optional, normally it will toggle
function parthiaTalkSetSpeech(displayToScreen, mode)

  displayToScreen = fuzzyBoolean(displayToScreen) --should messages be displayed to player
  mode = fuzzyBoolean(mode) --set mode if it is not being toggled

  if mode == nil then --if mode was not passed at all
    if parthiaTalkGetSpeech() then --if parthia talk speech is enabled
      tecSettings.parthiaTalkSpeech = false --switch parthia talk speech to off
      if displayToScreen then pecho("Parthia talk speech disabled.\n") end
    else --if parthia talk speech is not enabled
      tecSettings.parthiaTalkSpeech = true --switch parthia talk speech to on
      if displayToScreen then pecho("Parthia talk speech enabled.\n") end
    end --if parthiaTalkGetSpeech()
  else --if mode was passed
    tecSettings.parthiaTalkSpeech = mode --set variable to the mode passed
    if displayToScreen then pecho("Parthia talk speech set to "..tostring(mode)..".\n") end
  end --if mode == nil
  
  if displayToScreen then dontForgetToSave() end --if player ran command remind them to save

end --parthiaTalkSetSpeech(displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetSpeed(speed, displayToScreen)</name>
						<packageName></packageName>
						<script>--set speed parthia talks speaks at
function parthiaTalkSetSpeed(speed, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  speed = tonumber(speed) --convert speed to number incase it is a string
  if not speed then speed = 12 end --if speed was not a number, set it out of supported range to display supported commands
  
  if displayToScreen then --player called funtion, send messages to screen
    if speed &gt; 11 or speed &lt; 1 then --speed is out of supported range
      pecho("Supported parthia talk speed commands are\n")
      for i=1,11 do --loop from 1 to 11
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk speed "..i, --display clickable link to screen
          [[ parthiaTalkSetSpeed("]]..i..[[", true)]],
          "Set parthia talk speech rate to "..i, true)
        pecho(", set the speed parthia talk speeks at to "..tostring(i)..".")
        if i &lt; 3 then --show player lower numbers mean slower, higher means faster.
          pecho(" very slow\n")
        elseif i &gt; 2 and i &lt; 6 then 
          pecho(" slow\n")
        elseif i == 6 then
          pecho("&lt;green&gt; Default\n")
        elseif i &gt; 6 and i &lt; 10 then
          pecho(" fast\n")
        elseif i &gt; 9 and i &lt; 12 then
          pecho(" very fast\n")
        else 
          cecho("\n") 
        end --if i &lt; 3
      end --for i=1,10
      pecho("Click a command above or type it into the command line.\n")
      return --exit function
    end --if speed &gt; 11 or speed &lt; 1
  end --if displayToScreen
  
  --mudlets supported speech rates range is -1 to 1
  local speechRate = (speed - 6) * .2 
  debugToDisplay("function parthiaTalkSetSpeed, speech rate is "..tostring(speechRate))
  --pecho("Setting speech rate to "..tostring(speechRate).."\n")
  ttsSetRate(speechRate)
  tecSettings.parthiaTalkSpeed = speed --store speed setting for startup
  if displayToScreen then
    pecho("Parthia talk speed set to "..tostring(speed)..".\n")
    dontForgetToSave()
  end --if displayToScreen
end --parthiaTalkSetSpeed(speed)
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetSpeed()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetSpeed()
  return tecSettings.parthiaTalkSpeed
end --function parthiaTalkGetSpeed()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetPitch(pitch, displayToScreen)</name>
						<packageName></packageName>
						<script>--set Pitch parthia talks speaks in
function parthiaTalkSetPitch(pitch, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --will messages be displayed
  pitch = tonumber(pitch) --convert pitch to number incase it is a string
  if not pitch then pitch = 12 end --if pitch was not a number, set it out of supported range to display supported commands
  
  
  if displayToScreen then 
    if pitch &gt; 11 or pitch &lt; 1 then --if pitch is out of supported range
      pecho("Supported parthia talk pitch commands are\n")
      for i=1,11 do --loop from 1 to 11
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk pitch "..i, 
          [[ parthiaTalkSetPitch("]]..i..[[", true)]],
          "Set the pitch parthia talk speaks in to "..i, true)
        pecho(", set the pitch parthia talk speeks at to "..tostring(i)..".")
        if i &lt; 3 then
          pecho(" very deep\n")
        elseif i &gt; 2 and i &lt; 6 then 
          pecho(" deep\n")
        elseif i == 6 then
          pecho("&lt;green&gt; Default\n")
        elseif i &gt; 6 and i &lt; 10 then
          pecho(" high\n")
        elseif i &gt; 9 and i &lt; 12 then
          pecho(" very high\n")
        else 
          cecho("\n")
        end --if i &lt; 3
      end --for i=1,10
      pecho("Click a command above or type it into the command line.\n")
      return --exit function
    end --if pitch &gt; 11 or pitch &lt; 1 then
  end --if displayToScreen
  
  --mudlets supported pitch range is -1 to 1
  local pitchLevel = (pitch - 6) * .2 
  debugToDisplay("function parthiaTalkSetPitch, pitch level is "..tostring(pitchLevel)
    .." function was sent pitch number "..tostring(pitch))
  ttsSetPitch(pitchLevel) --set the pitch level
  tecSettings.parthiaTalkPitch = pitch --store pitch setting for startup
  if displayToScreen then
    pecho("Parthia talk pitch set to "..tostring(pitch)..".\n")
    dontForgetToSave() --remind player to save
  end --if displayToScreen
end --parthiaTalkSetPitch(pitch, displayToScreen)
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetPitch()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetPitch()
  return tecSettings.parthiaTalkPitch
end --function parthiaTalkGetPitch()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetQueueEnabled()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetQueueEnabled()
  return tecSettings.parthiaTalkQueueEnabled
end --function parthiaTalkGetQueueEnabled()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetQueueEnabled(displayToScreen, mode)</name>
						<packageName></packageName>
						<script>function parthiaTalkSetQueueEnabled(displayToScreen, mode)

  displayToScreen = fuzzyBoolean(displayToScreen) --should messages be displayed to player
  mode = fuzzyBoolean(mode) --set mode if it is not being toggled

  if mode == nil then --if a mode was not passed. Toggle the queues state
    if parthiaTalkGetQueueEnabled() then --queue is currently enabled.
      tecSettings.parthiaTalkQueueEnabled = false 
      if displayToScreen then pecho("Parthia Talk queue disabled, only most recent message will be spoken.\n") end
    else --queue is currently disabled
      tecSettings.parthiaTalkQueueEnabled = true 
      if displayToScreen then pecho("Parthia Talk queue enabled. Message will wait in line to be spoken the turn they were sent into the queue. Some computers will not play more than two or three messages in their queue.\n") end
    end --parthiaTalkGetQueueEnabled()
  else 
    tecSettings.parthiaTalkQueueEnabled = mode 
    if displayToScreen then pecho("Parthia talk queue set to "..tostring(mode).."\n") end
  end --if mode == nil
  
  dontForgetToSave() --remind player to save

end --function parthiaTalkSetQueueEnabled()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkGetVolume()</name>
						<packageName></packageName>
						<script>function parthiaTalkGetVolume()
  return tecSettings.parthiaTalkVolume
end --function parthiaTalkGetVolume()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaTalkSetVolume(volume, displayToScreen)</name>
						<packageName></packageName>
						<script>--set volume parthia talks speaks at
function parthiaTalkSetVolume(volume, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  volume = tonumber(volume) --convert volume to number incase it is a string
  if not volume then volume = 11 end --if volume was not a number, set it out of supported range to display supported commands
  
  if displayToScreen then --player called funtion, send messages to screen
    if volume &gt; 10 or volume &lt; 1 then --volume is out of supported range
      pecho("Supported parthia talk volume commands are\n")
      for i=1,10 do --loop from 1 to 11
        cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia talk volume "..i, --display clickable link to screen
          [[parthiaTalkSetVolume("]]..i..[[", true)]],
          "Set the volume parthia talk speaks in to "..i, true)
        pecho(", set the volume parthia talk speeks at to "..tostring(i)..".")
        if i &lt; 3 then --show player lower numbers mean slower, higher means faster.
          pecho(" very quiet\n")
        elseif i &gt; 2 and i &lt; 5 then 
          pecho(" quiet\n")
        elseif i == 5 then
          pecho("&lt;green&gt; Default\n")
        elseif i &gt; 5 and i &lt; 9 then
          pecho(" loud\n")
        elseif i &gt; 8 and i &lt; 11 then
          pecho(" very loud\n")
        else 
          cecho("\n") 
        end --if i &lt; 3
      end --for i=1,10
      pecho("Click a command above or type it into the command line.\n")
      return --exit function
    end --if volume &gt; 11 or volume &lt; 1
  end --if displayToScreen
  
  --mudlets supported volume range is 0 to 1
  local volumeLevel = volume * .1
  debugToDisplay("function parthiaTalkSetvolume, volume is "..tostring(speechRate))
  ttsSetVolume(volumeLevel)
  tecSettings.parthiaTalkvolume = volume --store volume setting for startup
  if displayToScreen then
    pecho("Parthia talk volume set to "..tostring(volume)..".\n")
    dontForgetToSave()
  end --if displayToScreen
end --parthiaTalkSetvolume(volume, displayToScreen)
</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>data collection</name>
				<packageName></packageName>
				<script>--[[
filters to collect data from in game commands.
like using ac . to populate room characters window.
]]--</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Room Characters ac .</name>
					<packageName></packageName>
					<script>--[[
Scripts for working with filtering the approach check command 
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECRoomCheckActive()</name>
						<packageName></packageName>
						<script>function getTECRoomCheckActive()
	return tecRoomObjects.checkActive
end --end function getRoomCharactersActive</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)</name>
						<packageName></packageName>
						<script>function setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) --verify good boolean sent
  tecRoomCheckActive = fuzzyBoolean(tecRoomCheckActive) --verify good boolean sent
	tecRoomObjects.checkActive = tecRoomCheckActive --tell triggers to expect a room check
  tecRoomObjects.displayToScreen = displayToScreen --will ac . display to main?
end --end function setRoomCharactersActive</script>
						<eventHandlerList />
					</Script>
					<Script isActive="no" isFolder="no">
						<name>clearTECRoomObjects()</name>
						<packageName></packageName>
						<script>--Moved to variables Data Themese - Variables script</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>runTECRoomObjectCheck(displayToScreen)</name>
						<packageName></packageName>
						<script>--used for functions that track objects in the current room.
function runTECRoomObjectCheck(displayToScreen)

  displayToScreen = displayToScreen or false --if not declared default is false

	clearTECRoomObjects() --clear room data before running check

	clearRoomCharacterWindow() --clear all roomCharacter windows
	
	setTECRoomCheckActive(true,displayToScreen)--set a room check to true.

  send("ac .", false) --send an ac . command to list characters in the room.

end --function runRoomCharacterCheck()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>echoLeftRoomCharacterWindows(message)</name>
						<packageName></packageName>
						<script>--display text to left side of all Room Character Windows
function echoLeftRoomCharacterWindows(message)
  if type(message) ~= "string" then --if the type is incorrect
    tecErrorNotification("function echoLeftRoomCharacterWindows, sent a none string variable.")
  end --if type(message) ~= "string"
  --display messages to side of the screen
  hecho(roomCharacters.console.name,message) --send message or standard room character window
  hecho(MultiWindow.roomCharacters.console.name,message) --send message to room character multi window
  debugToDisplay("function echoLeftRoomCharacterWindows, message: "..message)
end --function echoLeftRoomCharacterWindows()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>echoRightRoomCharacterWindows(message)</name>
						<packageName></packageName>
						<script>function echoRightRoomCharacterWindows(message)
  if type(message) ~= "string" then --if the type is incorrect
    tecErrorNotification("function echoRightRoomCharacterWindows, sent a none string variable.")
  end --if type(message) ~= "string"
  --display messages to side of the screen
  hecho(roomCharacters.rightConsole.name,message) --send message or standard room character window
  hecho(MultiWindow.roomCharacters.rightConsole.name,message) --send message to room character multi window
  debugToDisplay("function echoRightRoomCharacterWindows, message: "..message)
end --function echoLeftRoomCharacterWindows()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>clearRoomCharacterWindow()</name>
						<packageName></packageName>
						<script>function clearRoomCharacterWindow()
	clearWindow(roomCharacters.console.name) --clear left side standard room characters window
  clearWindow(MultiWindow.roomCharacters.console.name) --clear left side of the MultiWindow room characters console
  clearWindow(MultiWindow.roomCharacters.rightConsole.name) --clear right side of standard room character window
  clearWindow(roomCharacters.rightConsole.name) --clear the right side of the multi window room characters console
  tecRoomObjects.refreshMessageDisplayed = false --tell Parthia refresh message has not been shown
end --clearRoomCharacterWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecRoomCharRefreshNotification()</name>
						<packageName></packageName>
						<script>--Show notification to the player than something has changed and a room check is needed
local function tecRoomCharRefreshMessage()
  --displaying to right panel, because it will have very little text in it
  echoRightRoomCharacterWindows("Refresh Recommended ")
    cechoLink(roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cechoLink(MultiWindow.roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  echoRightRoomCharacterWindows(" or press ctrl+r.\n")
end --function tecRoomCharRefreshMessage()

function tecRoomCharRefreshNotification()

  if not tecRoomObjects.refreshMessageDisplayed then
    tecRoomCharRefreshMessage()
    tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
  end --if tecRefreshNotification is needed
  
end --function recRoomCharRefreshNotification()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecResetRoomCharacterWindow()</name>
						<packageName></packageName>
						<script>--clear out the room character windows and tell player how to refresh
function tecResetRoomCharacterWindow()
  clearRoomCharacterWindow() --Room characters window no longer accurate, clear it.
  echoLeftRoomCharacterWindows("Populate this space with characters in this room by:")
  echoRightRoomCharacterWindows("running command ")
  cechoLink(roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cechoLink(MultiWindow.roomCharacters.rightConsole.name,"&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  echoRightRoomCharacterWindows(" or pressing ctrl+r.\n")
  tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
end --function tecResetRoomCharacterWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>createCharacterCmdTable(stringToAdd)</name>
						<packageName></packageName>
						<script>--[[
returns a table that can be used with popup functions
]]--
function createCharacterCmdTable(stringToAdd)
  local characterCmdList = {}
  for i,v in ipairs(tecSettings.commandList) do
    table.insert(characterCmdList, v..stringToAdd..[["]])
  end
  
  return characterCmdList, tecSettings.commandHelp
end --function createCharacterCmdTable</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>stats</name>
					<packageName></packageName>
					<script>--[[
collect data from the stats command

]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getStatsCheckActive()</name>
						<packageName></packageName>
						<script>function getStatsCheckActive()
  return statsFilter.checkActive
end --function getStatsCheckState()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setStatsCheckActive(mode)</name>
						<packageName></packageName>
						<script>function setStatsCheckActive(mode)
  mode = fuzzyBoolean(mode)
  statsFilter.checkActive = mode --a stats check is active
  if not statsFilter.checkActive then --if disabeling
    debugToDisplay("function setStatsCheckActive, settings statsFilter.checkActive to false.")
    statsFilter.displayToScreen = true --if the check is done make certain displayToScreen is true
    for variableName, variable in pairs(parthiaPlayer.CurrentCharacter) do
      if type(variable) == "string" then --if the variable is a string
        variable = replaceDoubleSpaces(variable) --replace double blanks spaces with 1 space
        variable = removeEndSpace(variable) --remove blank spaces at the end of a variable
        parthiaPlayer.CurrentCharacter[variableName] = variable
        debugToDisplay("function setStatsCheckActive, CurrentCharacter."..variableName.." adjusted to ".."\""..parthiaPlayer.CurrentCharacter[variableName].."\"") 
      end --if type(variable) == "string"
    end --for pairs(parthiaPlayer.CurrentCharacter)
    parthiaMap.checkCharacter() --check where the character is. For when login occurs. It uses the character name, that is why it is here
  end --if not mode
end --function setStatsCheckActive(mode)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>runStatsCollection(displayToScreen)</name>
						<packageName></packageName>
						<script>function runStatsCollection(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) 
  setStatsCheckActive(true) --tell Parthia we will be collecting stats data
  send("stats",displayToScreen) --send command do not echo
  statsFilter.displayToScreen = displayToScreen --tell stats filter not to display command to pecho
  statsFilter.lineCount = 0 --counts lines shown, to stop infinite runs on error
end --function runStatsCollection()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>condition</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getConditionCheckActive()</name>
						<packageName></packageName>
						<script>function getConditionCheckActive()
  return conditionFilter.checkActive
end --function getStatsCheckState()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setConditionCheckActive(mode)</name>
						<packageName></packageName>
						<script>function setConditionCheckActive(mode)
  mode = fuzzyBoolean(mode)
  conditionFilter.checkActive = mode --a stats check is active
  if not mode then conditionFilter.displayToScreen = true end --if the check is done make certain displayToScreen is true
end --function setConditionCheckActive(mode)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>runConditionCollection(displayToScreen)</name>
						<packageName></packageName>
						<script>function runConditionCollection(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen) 
  setConditionCheckActive(true) --tell Parthia we will be collecting stats data
  send("condition",displayToScreen) --send command do not echo
  conditionFilter.displayToScreen = displayToScreen --tell stats filter not to display command to pecho
  conditionFilter.lineCount = 0 --counts lines shown, to stop infinite runs on error
end --function runConditionCollection(displayToScreen)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>HelpTheDevelopers</name>
					<packageName></packageName>
					<script>--[[
Functions to collect information from data for future features
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getHelpDevs()</name>
						<packageName></packageName>
						<script>--get enabled or disabled state of Help Developers
function getHelpDevs()
  return tecSettings.helpDevelopers
end --function getHelpDevs()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setHelpDevs(mode)</name>
						<packageName></packageName>
						<script>--set enabled or disabled state of Help Developers
function setHelpDevs(mode)
  tecSettings.helpDevelopers = fuzzyBoolean(mode)
end --function setHelpDevs(mode)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>saveHelpDevs(displayToScreen)</name>
						<packageName></packageName>
						<script>--[[
save help developers table to file.
If the command was run by the player prompt to open the save folder and send data to a developer
]]--
function saveHelpDevs(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  
  local helpDevFolderExist = lfs.chdir(helpDevDataFolder) --check if the help developers folder already exists
  if not helpDevFolderExist then --if the help developers folder does not exist
    local profileFolderExists = lfs.chdir(getMudletHomeDir()) --make certain the mudlet profile exists and change to that directory
    if profileFolderExists then --The mudlet folder exists
      lfs.mkdir(helpDevDataFolder) --make the help developers folder
    end --if profileFolderExists
  end --if not helpDevFolderExist

  if getHelpDevs() then --if Help Devs is enabled save the data
    --Save the table to file.
    table.save(helpDevDataFile, HelpDevsData)
  	if displayToScreen then --if player ran command
      pecho("Help developers data saved.\n")
      sendHelpDevs() --display message to help players submit Help Developers data
    end --if displayToScreen
  else --help the devs is not enabled.
    if displayToScreen then
      pecho("Help Developers is not enabled. Enable it with ")
      pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia help developers", 
      [[expandAlias("parthia help developers")]],
      "Toggle state of Help Developers", true)
      pecho("\n")
    end --if displayToScreen
  end

end --function saveHelpDevs()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>loadHelpDevs(displayToScreen)</name>
						<packageName></packageName>
						<script>function loadHelpDevs(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  local tmpTable = {} --tmp table to hold data.	
	local path = helpDevDataFile --name and folder of file
	
  if not io.exists(path) then --If the file does not exist let the user know.
		tecWarningNotification("function loadHelpDevs, file "..path.." not found.")
		if displayToScreen then
      pecho("[  info  ]  - Help The Developers save file not found.\n")
    end --if displayToScreen
    return --kill the function before real errors occur
	else --file was found
    table.load(path, tmpTable) --Load the data in from file
    HelpDevsData = table.update(HelpDevsData, tmpTable) --update the existing HelpDevsData table incase load is run after startup
    if displayToScreen then 
      pecho("[  OK  ]  - Help The Developers data successfully loaded from file.\n") 
    end --if displayToScreen
	end --end if file exists else
  
end --function loadHelpDevs(displayToScreen)
</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>sendHelpDevs()</name>
						<packageName></packageName>
						<script>--displays a message to help players submit data collected by Help Developers
function sendHelpDevs()
  pecho("To submit Help Developers data open the folder containing it by running or clicking command ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia help developers open", 
    [[tecOpenDirectory(helpDevDataFolder)]], 
    "Open help developers folder", true)
  pecho("\n"..[[Please attach the file named Help The Developers Data.txt to:]])
  pecho("\nAn issues report at Parthia's ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Github Issue Page", 
    [[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
    "Goto issues page", true)
  pecho("\nA message on the Devs channel of ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Parthia's discord server", 
    [[openUrl("https://discord.gg/SQtNmq9")]], 
    "Goto issues page", true)
  pecho("\nTo view data collected by Help Developers run:\n")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia room data", 
  [[expandAlias("parthia room data")]],
  "Display Help Developers room data", true)
  echo(", Display Help Developers collected room data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia character data", 
  [[expandAlias("parthia character data")]],
  "Display Help Developers character data", true)
  echo(", Display Help Developers collected character data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player combat data", 
  [[expandAlias("parthia player combat data")]],
  "Display Help Developers player combat data", true)
  echo(", Display Help Developers collected player combat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia player noncombat data", 
  [[expandAlias("parthia player noncombat data")]],
  "Display Help Developers player noncombat data", true)
  echo(", Display Help Developers collected player noncombat data.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia object data", 
  [[expandAlias("parthia object data")]],
  "Display Help Developers object data", true)
  echo(", Display Help Developers collected object data.\n")
  
end --sendHelpDevs()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Actions</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>sortActions(stringToCheck)</name>
						<packageName></packageName>
						<script>--[[
Detects if actions player is involved in are combat or non combat actions.
If no string is passed it looks for the action in the global line variable
]]--
function sortActions(stringToCheck)
  stringToCheck = stringToCheck or line
  if type(stringToCheck) ~= "string" then --make certain a string was passed
    tecErrorNotification("function sortActions, passed a non string variable. Received: "..tostring(stringToCheck).." expected a string.")
  end --if type(stringToCheck) ~= "string"
  
  if stringToCheck:match("^%[Success: %d+, Roll: %d+%]") then --if match is true this is a non combat action
    debugToDisplay("function, sortActions non-combat action found.")
    sortNonCombatActions() --sort and collect data from last action that appeared on screen
  else --this is a combat action
    debugToDisplay("function, sortActions combat action found.") 
    sortCombatActions() --sort and collect data from last action that appeared on screen
  end --if then  stringToCheck:match("(Success: %d+, Roll: %d+)")
end --function sortActions</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>sortCombatActions(stringToCheck)</name>
						<packageName></packageName>
						<script>--[[
Detects if combat action is against the player or if the player is running the action
saves the action to the Help Developers table if the player has Help Developers enabled
If a string is not passed 
]]--
function sortCombatActions(stringToCheck)
  stringToCheck = stringTocheck or line --if user did not pass a string, check global line
  if type(stringToCheck) ~= "string" then --make certain a string was passed
    tecErrorNotification("function collectCombatActions, passed a non string variable. Received: "..tostring(stringToCheck).." expected a string.")
  end --if type(stringToCheck) ~= "string"

  if  stringToCheck:match("at you") or --if the attack is directed at the player.
      stringToCheck:match("misses you") or
      stringToCheck:match("towards you") or 
      stringToCheck:match("slap you,") or
      stringToCheck:match("head butt you") or 
      stringToCheck:match("tries to distract you") or
      stringToCheck:match("a knee into you") or 
      stringToCheck:match("parthia playercombatdata") then
    if getHelpDevs() then --if Help Developers is enabled
      if not table.contains(HelpDevsData.Combat.AgainstPlayer, stringToCheck) then --if stringToCheck is not in the AgainstPlayer table
        debugToDisplay("function collectCombatActions, adding "..stringToCheck.." to HelpDevsData.Combat.AgainstPlayer table.")
        HelpDevsData.Combat.AgainstPlayer[stringToCheck] = "" --collect attack to table.
      end --if not table.contains(HelpDevsData.Combat.AgainstPlayer, stringTocheck)
    end --if getHelpDevs()
  elseif  stringToCheck:match("%] You") or --if the attack is one the player is using
          stringToCheck:match(", you") then
    if getHelpDevs() then --if Help Developers is enabled
      if not table.contains(HelpDevsData.Combat.PlayerAttacks, stringToCheck) then --if stringToCheck is not in the HelpDevsData.Combat.PlayerAttacks table
        debugToDisplay("function collectCombatActions, adding "..stringToCheck.." to HelpDevsData.Combat.PlayerAttacks table.")
        HelpDevsData.Combat.PlayerAttacks[stringToCheck] = "" --collect attack to table.
      end --if not table.contains(HelpDevsData.Combat.PlayerAttacks, stringTocheck)
    end --getHelpDevs()
  else --we do not know where this attack belongs
    if getHelpDevs() then --if Help Developers is enabled
      if not table.contains(HelpDevsData.Combat.Unsorted, stringToCheck) then --if stringToCheck is not in the HelpDevsData.Combat.Unsorted table
        debugToDisplay("function collectCombatActions, adding "..stringToCheck.." to HelpDevsData.Combat.Unsorted table.")
        HelpDevsData.Combat.Unsorted[stringToCheck] = "" --collect attack to table.
      end --if not table.contains(HelpDevsData.Combat.Unsorted, stringTocheck)
    end --if getHelpDevs() then
  end --if stringToCheck:match sort combat types if elseif series
  
end --function sortCombatActions(stringToCheck)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>sortNonCombatActions(stringToCheck)</name>
						<packageName></packageName>
						<script>function sortNonCombatActions(stringToCheck)
  stringToCheck = stringTocheck or line --if user did not pass a string, check global line
  if type(stringToCheck) ~= "string" then --make certain a string was passed
    tecErrorNotification("function sortNonCombatActions, passed a non string variable. Received: "..tostring(stringToCheck).." expected a string.")
  end --if type(stringToCheck) ~= "string"

  if getHelpDevs() then --if Help Developers is enabled
    if not table.contains(HelpDevsData.NonCombatActions.Unsorted, stringToCheck) then --if stringToCheck is not in the unsorted table
      debugToDisplay("function sortNonCombatAction, adding "..stringToCheck.." to HelpDevsData.NonCombatActions.Unsorted table.")
      HelpDevsData.NonCombatActions.Unsorted[stringToCheck] = "" --collect attack to table.
    end --if not table.contains(HelpDevsData.Combat.AgainstPlayer, stringTocheck)
  end --if getHelpDevs()

end --function sortNonCombatActions</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Game commands</name>
				<packageName></packageName>
				<script>--[[
Commands used to interact with the game itself.

IE: `wait for drover`
]]--</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>wait for drover</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaSetWaitForDrover(waiting, displayToScreen)</name>
						<packageName></packageName>
						<script>function parthiaSetWaitForDrover(waiting, displayToScreen)
  waiting = fuzzyBoolean(waiting) --make certain it is a good variable
  
  if parthiaGetWaitForDrover() then parthisSetStopRun(true, true) end --hide the you are not doing anything message
  
  parthiaWaitingForDrover = waiting
  
  if displayToScreen then
    if waiting then 
      pecho("You patiently wait for the drover to arrive.\n")
    else
      pecho("You stop waiting for the drover.\n")
    end
  end
end --function parthiaSetWaitForDrover(waiting)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaGetWaitForDrover()</name>
						<packageName></packageName>
						<script>function parthiaGetWaitForDrover()
  return parthiaWaitingForDrover 
end --function parthiaGetWaitForDrover()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Courses</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>courses.disable(displayToScreen)</name>
						<packageName></packageName>
						<script>--makes certain all courses scripts are disabled.
function courses.disable(displayToScreen)

  displayToScreen = fuzzyBoolean(displayToScreen)

  disableTrigger("Courses 4 Part")
  disableTrigger("Courses 3 Part")
  
  if courses.running then parthisSetStopRun(true, true) end --hide the you are not doing anything message
  
  courses.running = false
  courses.fourPart = false
  courses.threePart = false
  courses.lookRan = false
  
  if displayToScreen then
    pecho("\nYou are no longer running courses.\n")
  end --if displayToScreen

end --function courses.disable(displayToScreen)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>courses.firstStep()</name>
						<packageName></packageName>
						<script>--message that the course has no more to offer comes after the room arrival message. This function prevents moving when it is no longer needed
function courses.firstStep()

  if courses.running then
    if courses.fourPart then
      send("go south")
    elseif courses.threePart then
      send("go east")
    end --if courses.fourPart
  end --if courses.running
    
end --function courses.threePartFirstStep()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>stop</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>parthiaGetStopRan()</name>
						<packageName></packageName>
						<script>--return if the stop command was run by scripts.
function parthiaGetStopRan()
  
  return parthiaStopRan
  
end --parthiaGetStopRan()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthisSetStopRun(mode, delay)</name>
						<packageName></packageName>
						<script>--[[
Used to suppress the "You aren't doing anything." message that appears when a player runs the stop command to stop scripts, but they are not doing a task in the game
Used in trigger "You aren't doing anything." if the mode is true the message is suppressed. If not the message is shown.
delay allows the player to run `stop` than delay for the "You aren't doing anything." message to arrive. Setting it to false after it arrives.

usage:
  parthisSetStopRun(mode, delay)
  mode is a boolean. true stops the "You aren't doing anything." false allows it to show.
  delay is a boolean. If true the function waits half a second to set the mode.
]]--

function parthisSetStopRun(mode, delay)
  mode = fuzzyBoolean(mode)
  delay = fuzzyBoolean(delay)
  
  if delay then
    tempTimer(.5, [[parthisSetStopRun(true)]])
  else
    parthiaStopRan = mode
  end --if delay

end --function parthisSetStopRun(mode, delay)</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>parthiaStopScripts(displayToScreen)</name>
						<packageName></packageName>
						<script>--stops all scripts running in parthia
function parthiaStopScripts(displayToScreen)

  if courses.running then courses.disable(displayToScreen) end --If running, disable courses scripts
  if parthiaGetWaitForDrover() then parthiaSetWaitForDrover(false, displayToScreen) end --if running, disable waiting for drover script

end --function parthiaStopScripts(displayToScreen)</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>numpad navigation</name>
				<packageName></packageName>
				<script>--enable or disable numpad naviation</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setNumpadNavigation(mode)</name>
					<packageName></packageName>
					<script>--enable or disable numberpad navigation support
function setNumpadNavigation(mode)
  mode = fuzzyBoolean(mode) --made certain variable sent is good.
  numNaviationkeyName = "numpad navigation" --name of the navitation group the navigation keys are in
  
  if mode then --if true enable numpadgroup
    enableKey(numNaviationkeyName)
  else --if false disable
    disableKey(numNaviationkeyName)
  end --if mode then
  
  --save to file if player wants numpad navigation enabled.
  tecSettings.numpadNavigationEnabled = mode
  
end --function setNumNaviation(mode)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getNumpadNaviation()</name>
					<packageName></packageName>
					<script>--returns the enabled or disabled state of numpad navigation
function getNumpadNaviation()
  return tecSettings.numpadNavigationEnabled
end --function getNumpadNaviation()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Parthia Map</name>
				<packageName></packageName>
				<script>--[[
Basic flow of mapping is:
The player successfully moves. (Failed movement handled in trigger: "failed movement" and "You are in the middle of something.")
That movement direction (IE east or west) is tracked with (alias group "movement", script "parthiaMap.findSpecialExits")
parthiaMap.room (table that holds data about players current room) gets copied to parthiaMap.previousRoom in trigger "Player enters a room". parthiaMap.room is then reset with parthiaMap.resetRoom
trigger "TEC Map Rooms" calls function parthiaDrawMapRooms().
parthiaDrawMapRooms() collects sizes and positions of near by rooms into table parthiaMap.room
trigger "TEC map exits" calls function parthiaDrawMapExits()
parthiaDrawMapExits() collects data about exits into table parthiaMap.room
trigger "TEC map exits" than calls function parthiaMap.Move() to move player on the map. This is a FLAWED method as some rooms do NOT have exits. So that trigger NEVER occurs!
parthiaMap.Move() uses mapping functions to find where near by rooms match to exits for the room the player is in.
  parthiaMap.Move() uses the direction the player moved to know which near by room was used to.
  if this is an existing room
    parthiaMap.Move uses the mudlet map ID for the previous room to find it's exits.
      The exits in the previous room contain the room ID that exit leads to.
      That ID is used to move the player on the map.
  If it is a new room and parthiaMap.mapping is true
    parthiaMap.Move uses the room's position on the alice TEC Map to calculate where that room belongs in the mudlet mapper
    parthiaMap.Move created the new room mudlet's mapping system gives it an ID and tracks where it belongs
    parthiaMap.Move creates lines for all the exits in the room.
    parthiaMap.Move sets doors on each exit line if a door or gate exists.
    parthiaMap.Move connects the exits for the room the player move from and the room the player is currently in, including special and unique exits. 
There is obviously a LOT more that needs to be done, but this is the start
      

parthiaMap table that contains parthia mapping scripts and data types.

vertical movement can not be collected from messages echoed in the game.
An example of game echo moving vertically is: You climb a spiral stairway of steel grille steps.
The key word climb can be used to detect if a player moved up or down if only one of those options are available. This works in dark rooms also.
The keyword climb in the vertical movement echo can not be used to collect vertical movement if both up and down movement is available.
To detect if a player has moved up or down when both options are available. We turn to the function addLinksToDirections.
That function already works with detecting exits in the room description echo message.
In a room echo exit directions and exit descriptions are colored. We detect when the words "upwards" or "downwards" appear in colored text. Just before a exit direction is echoed in color, that exit's description is also colored in text.
We take that description and store it into parthiaMap.room.exits[tmpRoomType].description = previousRoomType where tmpRoomType is a direction. 
From there we capture all movement commands that can make the player use a special exit like: go ladder
This has been done in alias group "movement". If a command is run IE: climb up go down go ladder. The direction is passed to function parthiaMap.detectDirection(dir)
detectDirection detects if this movement will send the player up or down. Including if they use a special command like go ladder or go 2 ladder
if detectDirection detects vertical movement it sets: parthiaMap.directionWalked = "up" (or "down") and parthiaMap.dirtectionCollected = true and displays a message to parthias debug console.



currently detection data is reset in trigger Player enters a room that will need to be changed to add support for movement when room is dark.

parthiaMap.config() and parthiaMap.load function are called in script `Post Initilization`

Create option to disable mapping if colored text is disabled. Then when it is found, notify the player the parthia map can not work with colored text disabled. 
]]--

--tell mudlet we are going to create a maping script https://wiki.mudlet.org/w/Mapping_script#Making_your_own_mapping_script
mudlet = mudlet or {}
mudlet.mapper_script = true

parthiaMap = parthiaMap or {} --table to hold the mapper data.

--parthiaMap.TECMapRooms = {} table that holds the size, position, and area of nearby rooms
--parthiaMap.previousRoom = nil --will contain a room table of the last room the payer was in
--parthiaMap.directionWalked = "" --direction player has walked. collected in trigger parthia mapper walk detected via function parthiaMap.findSpecialExits
--parthiaMap.roomID = nil --will hold the ID of the current room the player is in
--parthiaMap.roomName = nil --will hold the short name of the room, collected in function addLinksToDirections()
--parthiaMap.previousRoomID = nil --will hold the ID of the previous room the player is in
--parthiaMap.exits = {} --holds the exits for the current room, collected in function addLinksToDirections()
--parthiaMap.coords = {} --location in the current area
--parthiaMap.dirtectionCollected = false --used to tell mapper if a movement direction has been collected. Is collected in functions parthiaMap.findSpecialExits and parthiaMap.detectDirection. Used in parthiaMap.Move
--parthiaMap.upAvailable = false --keeps track of it player can move up in this area. Used to track movement commands like go ladder
--parthiaMap.downAvailable = false --keeps track of it player can move up in this area. Used to track movement commands like go ladder
--parthiaMap.stepsGoUp = true --if true steps add 1 to Z. If false steps remove 1 from z
--parthiaMap.playerClimbed = false --sets to true when a player climbs in trigger "player climbed"
--parthiaMap.currentAreaID = 1 --the area id that the players current room is in
--parthiaMap.room.exitEcho = "" --the message that echos to screen as a player enters a room, that lists a description for this rooms exits
--parthiaMap.specialExitMovement = false --sets to the room id the exit leads to when player runs a command that uses a special exit.
--parthiaMap.specialExitAttempted = false --records if a special exit was attempted. Used to automatically create a special exit for mappers.
--parthiaMap.playerCmd = false --the command the player used during this movement. be a carinal direction if player used a shorthand for one
--parthiaMap.entryIndex = 1 --index used to tell what exit was entered through to get to current room
--parthiaMap.exitIndex = 1 --index used to tell what exit was exited through from previous room to get to current room
--parthiaMap.descriptionOfExitUsed = "" --stores the description of the exit player used.
--parthiaMap.moveNeeded = false --Movement needs to be delayed because sometimes there is not SKOOT 10 message. This is used to track if movement has already begun. Used in function parthiaMap.delayMove()</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.resetRoom()</name>
					<packageName></packageName>
					<script>--Used to reset the data table to track the players current room
function parthiaMap.resetRoom()
  parthiaMap.room = {} -- clear the table
  parthiaMap.room.id = nil --will hold the ID of the current room the player is in
  parthiaMap.room.name = nil --will hold the short name of the room, collected in function addLinksToDirections()
  parthiaMap.room.exits = {} --holds the exits for the current room, collected in function addLinksToDirections()
  parthiaMap.room.coords = {} --location in the current area
  parthiaMap.room.size = nil --size of the room, collection in function parthiaDrawMapRooms()
  if not parthiaMap.dirtectionCollected then --if resetRoom is called after directionWalk was collected do not reset directionWalked
    parthiaMap.directionWalked = "NOT COLLECTED" --direction the player has walked
  end --if not parthiaMap.dirtectionCollected
  parthiaMap.TECMapRooms = {} --rooms that appear on the map
  parthiaMap.TECMapExits = {} --exits that appear on the map
  parthiaMap.room.confirmedExits = {} --exits that have been confirmed to be in this room.
  parthiaMap.room.specialExits = {} --store special exit descriptions
end --function parthiaMap.resetRoom()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.config()</name>
					<packageName></packageName>
					<script>--[[
creates basic data need for using mudlet's mapper within Parthia.
It is called in script "Post Initilization"
]]--
function parthiaMap.config()
  parthiaMap.currentAreaID = nil --will hold the current area name
  parthiaMap.mapping = false --is a map being created
  parthiaMap.stepsGoUp = true --if true steps add 1 to Z. If false steps remove 1 from z
  parthiaMap.playerClimbed = false --sets to true when a player climbs in trigger "player climbed"
  parthiaMap.directions = { --used to tell mapper acceptable directions. Used in addLinksToDirections to collect room exit directions
    "north", "northeast", "east", "southeast", "south", "southwest",
    "west", "northwest", "up", "down"
  }
  parthiaMap.resetRoom() --prepare table parthiaMap.room
  parthiaMap.saveTable = {} --table to collect data that needs to be saved to file
  parthiaMap.savePath = tecSettingsFolder.."MapData.lua"
  parthiaMap.load(true) --load map settings from file
  parthiaMap.currentAreaID = 1 --set the default room to the welcome area
  parthiaMap.notMovement = false --sets to true if login occured from trigger "Login Successful"
end --parthiaMap.config()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.addArea(areaName)</name>
					<packageName></packageName>
					<script>--[[
Used to create a new area with in mudlet's mapper
Useage:
parthiaMap.addArea("Name of Area")
This function is used in alias "parthia map area add"
]]--
function parthiaMap.addArea(areaName)
  if type(areaName) ~= "string" then
    tecErrorNotification("function parthiaMap.addArea, argument 1 expected string variable receive a "..type(areaName))
  end --if areaName ~= "string"
  
  local newID, err = addAreaName(areaName) --creates a new area in the mapper https://wiki.mudlet.org/w/Manual:Mapper_Functions#addAreaName
  
  if newID == nil or newID &lt; 1 or err then --if the mapper errored on area creation
    pecho("That area name could not be added.")
    if err then --error message available
      pecho(" - error is: ".. err.."\n")
    else --there was an error but no error message
      echo("\n")
    end --if err
  else --no error found
    pecho("&lt;green&gt;Created new area "..areaName.." with the ID of "..newID..".&lt;reset&gt;\n")
    pecho("Your next step will begin mapping in the new area.\nIf you do not want to map in the new area run commands ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map character area", 
      [[printCmdLine("parthia map character area ");
      pecho("Now type the name of the area to remove and press enter.\n")]],
      "change mapping area", true)
    pecho(" or ")
    pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/maparea", 
      [[printCmdLine("/maparea ");
        pecho("Now type the name of the area to remove and press enter.\n")]],
      "change mapping area", true)
    pecho(". To change to the area you would like to map.")
    --parthiaMap.coords = { 0,0,0 } --reset coordinates becuas
    parthiaMap.currentAreaID = newID --set the new ID for mapping in the new space
  end --if newID == nil or newID &lt; 1 or err
end --function parthiaMap.addArea</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.removeArea(areaName, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
Used to remove an area with in mudlet's mapper, and all rooms in that area.
This function is used in alias "parthia map area remove"
Useage:
parthiaMap.removeArea(areaName, displayToScreen)
  areaName, is the full name of an area. With correct capitolization
  displayToScreen, is if you would like messages displayed to screen
Examples:
  parthiaMap.removeArea("Name of area", true), removes area named "Name of area", and displays errors to screen
  local errorFound parthiaMap.removeArea("Name of area", true), removes area named "Name of area", and displays errors to screen and sending errors to variable errorFound
  parthiaMap.removeArea("Name of area"), removes area named "Name of area", error messages will only go to error consoles.
]]--
function parthiaMap.removeArea(areaName, displayToScreen)
  if type(areaName) ~= "string" then
    tecErrorNotification("function parthiaMap.removeArea, argument 1 expected string variable receive a "..type(areaName))
  end --if areaName ~= "string"
  displayToScreen = fuzzyBoolean(displayToScreen)

  --verify the area exists than delete it
  local areasTable = getAreaTable() --get a table that contains all the ids and names of of each area
  for k,v in pairs(areasTable) do --loop through all the areas that have been created
    if k == areaName then --if an area with the name passed exists
      parthiaMap.clearAreaRooms(v) --empty the area
      deleteArea(k) --remove the area
      if displayToScreen then pecho("Area "..areaName.." removed.\n") end
      return --stop function were able to do desired action
    end --if k == areaName
  end --for pairs(areasTable)

  --Area with the name of the first argument does not exist
  if displayToScreen then pecho("Could not find area "..areaName..".\n") end
  local errorFound = "function parthiaMap.removeArea, failed could not find areaName."
  tecWarningNotification(errorFound)
  return errorFound

end --function parthiaMap.removeArea(areaName)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.changeArea(areaName, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
Changes character's current area.
Function would only be useful for mappers. When they have to move between existing areas while mapping.
Is used in alias `parthia map character area`
Useage:
  parthiaMap.changeArea(areaNameOrID, displayToScreen)
  areaNameOrID, contains the full name or id of an area
  displayToScreen, is if error messages get displayed to screen
Examples:
  parthiaMap.changeArea(1, false), changes current area to 1, displaying messages to error consoles only
  parthiaMap.changeArea("Welcome Room", true), changes to area "Welcome Room", displaying errors to screen
  local errorFound = parthiaMap.changeArea(2, false), changes area to 2, and fills variable errorFound with an error if found
]]--
function parthiaMap.changeArea(areaNameOrID, displayToScreen)
  if type(areaNameOrID) ~= "string" then
    tecErrorNotification("function parthiaMap.changeArea, argument 1 expected string variable receive a "..type(areaNameOrID))
  end --if areaNameOrID ~= "string"
  displayToScreen = fuzzyBoolean(displayToScreen)

  --verify the area exists than change to that ID
  local areasTable = getAreaTable() --get a table that contains all the ids and names of of each area
  for k,v in pairs(areasTable) do --loop through all the areas that have been created
    if k == areaNameOrID or v == tonumber(areaNameOrID) then --if an area with the name or ID passed exists
      parthiaMap.currentAreaID = v
      if displayToScreen then pecho("Changed to area "..k..", that has an ID of "..v..".\n") end
      return --stop function were able to do desired action
    end --if k == areaNameOrID
  end --for pairs(areasTable)

  --Area with the name of the first argument does not exist
  if displayToScreen then pecho("Could not find area "..areaNameOrID..".\n") end
  local errorFound = "function parthiaMap.changeArea, failed could not find areaName."
  mapDebug(errorFound)
  return errorFound

end --function parthiaMap.changeArea(areaNameOrID)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.connectRooms()</name>
					<packageName></packageName>
					<script>--call when mapping is ready to connect the exits of the players previous and current rooms
function parthiaMap.connectRooms()
  local entryDir = parthiaMap.getEntranceDirection()
  local exitDir = parthiaMap.directionWalked
  local entryIndex = parthiaMap.entryIndex --index used to tell what exit was entered through to get to current room
  local exitIndex = parthiaMap.exitIndex --index used to tell what exit was exited through from previous room to get to current room
  local plCmdExitDesc = parthiaMap.playerCmd:match("^%d*%s*(.+)%s*") --capture the description of the exit provided in the player's command

  if not parthiaMap.specialExitAttempted then --if the movement was a cardinal direction
    --connect exit stubs that appear on map.
    mapDebug("function parthiaMap.connectRooms, connecting previous room ID: "..parthiaMap.previousRoom.id.." to current room ID "..parthiaMap.room.id.." using previous room exit "..parthiaMap.directionWalked..". In if not parthiaMap.specialExitAttempted.")
    setExit(parthiaMap.previousRoom.id, parthiaMap.room.id, parthiaMap.directionWalked)
    mapDebug("function parthiaMap.connectRooms, connecting current room ID: "..parthiaMap.room.id.." to previous room ID "..parthiaMap.previousRoom.id.." using current room exit "..parthiaMap.getEntranceDirection().."In if not parthiaMap.specialExitAttempted.")
    setExit(parthiaMap.room.id, parthiaMap.previousRoom.id, parthiaMap.getEntranceDirection())
  end --if not parthiaMap.specialExitAttempted

  --get the special exit that leads to the previous room
  local entrySpecialExit = "" --will store what special exit leads to previous room
  for spExitName,spExitTbl in pairs(parthiaMap.room.specialExits) do --look through the special exits in this room
    if parthiaMap.descriptionOfExitUsed:lower() == spExitName:lower() then
      entrySpecialExit = spExitName:lower()
      break --stop as we found what we are looking for
    end --ipairs(spExitTbl)
  end --for pairs(parthiaMap.room.specialExits)
  
  --get the special exit used to get to this room
  local exitedSpecialExit = ""
  for spExitName,spExitTbl in pairs(parthiaMap.previousRoom.specialExits) do --look through the special exits in this room
    if parthiaMap.descriptionOfExitUsed:lower() == spExitName:lower() then
      exitedSpecialExit = spExitName:lower()
    end --ipairs(spExitTbl)
  end --for pairs(parthiaMap.room.specialExits)
  
  --find what order the previous room appeared in the SKOOT 6 message
  local entrySpecialExitRoomOrder = ""
  for k,v in ipairs(parthiaMap.room.adjacentRooms) do --loop through rooms that are next to this one
    --find the previous room in the adjacentRooms table
    if  parthiaMap.room.confirmedExits[entryDir]
    and parthiaMap.room.confirmedExits[entryDir][entryIndex]
    and parthiaMap.room.confirmedExits[entryDir][entryIndex].room then --up and down will be nil
      if  parthiaMap.room.confirmedExits[entryDir][entryIndex].room.ypos == v.ypos
      and parthiaMap.room.confirmedExits[entryDir][entryIndex].room.xpos == v.xpos then
        entrySpecialExitRoomOrder = k --record the order the room appear in on SKOOT 6 message
        break --stop as we found what we are looking for
      end ----find the order the room appear in on SKOOT 6 message
    end --if  parthiaMap.room.confirmedExits[entryDir]
  end --ipairs(parthiaMap.room.adjacentRooms)
  --find the order this room appeared in the previous rooms SKOOT 6 message
  local exitedSpecialExitRoomOrder = ""
  for k,v in ipairs(parthiaMap.previousRoom.adjacentRooms) do --loop through rooms that are next to this one
    --find the previous room in the adjacentRooms table
    if  parthiaMap.previousRoom.confirmedExits[exitDir]
    and parthiaMap.previousRoom.confirmedExits[exitDir][exitIndex]
    and parthiaMap.previousRoom.confirmedExits[exitDir][exitIndex].room then
      if  parthiaMap.previousRoom.confirmedExits[exitDir][exitIndex].room.ypos == v.ypos
      and parthiaMap.previousRoom.confirmedExits[exitDir][exitIndex].room.xpos == v.xpos then
        exitedSpecialExitRoomOrder = k --record the order the room appear in on SKOOT 6 message
        break --stop as we found what we are lookg for
      end --find the order the room appear in on SKOOT 6 message
    end --if parthiaMap.previousRoom.confirmedExits[exitDir]
  end --ipairs(parthiaMap.room.adjacentRooms)

  --make unique exit, a special exit that does not appear on the exits echo list. Requires the person mapping to manually use the exit.
  if parthiaMap.specialExitAttempted then --if a special exit was attempted this movement.
    local uniqueExit = exitedSpecialExit:match(plCmdExitDesc) --if the players command is not already about to be mapped. 
    if not uniqueExit then --if there was no match to the
      addSpecialExit(parthiaMap.previousRoom.id, parthiaMap.room.id, parthiaMap.playerCmd)
      mapDebug("function parthiaMap.connectRooms, unique exit from room id: "..parthiaMap.previousRoom.id.." to room id: "..parthiaMap.room.id.." exit type: \""..parthiaMap.playerCmd.."\"")
    end --if not uniqueExit
  end --if parthiaMap.specialExitAttempted

  --if movement is up or down. Create the special exit now. Stopping further data sorting
  if entryDir == "up" or entryDir == "down" then 
    addSpecialExit(parthiaMap.previousRoom.id, parthiaMap.room.id, exitedSpecialExit)
    mapDebug("function parthiaMap.connectRooms, special exit from room id: "..parthiaMap.previousRoom.id.." to room id: "..parthiaMap.room.id.." exit type: \""..exitedSpecialExit.."\"")
    addSpecialExit(parthiaMap.room.id, parthiaMap.previousRoom.id, entrySpecialExit)
    mapDebug("function parthiaMap.connectRooms, special exit from room id: "..parthiaMap.room.id.." to room id: "..parthiaMap.previousRoom.id.." exit type: \""..exitedSpecialExit.."\"")
    return --function has done what was needed. Stop it.
  end --if entryDir == "up" or entryDir == "down"
  
  --create a standard special exit.
  --parthiaMap.previousRoom.id, parthiaMap.room.id, parthiaMap.directionWalked
  addSpecialExit(parthiaMap.previousRoom.id, parthiaMap.room.id, exitedSpecialExit.."@#"..exitedSpecialExitRoomOrder)
  mapDebug("function parthiaMap.connectRooms, special exit from room id: "..parthiaMap.previousRoom.id.." to room id: "..parthiaMap.room.id.." exit type: \""..exitedSpecialExit.."@#"..exitedSpecialExitRoomOrder.."\". Inside else of if parthiaMap.specialExitAttempted.")
  addSpecialExit(parthiaMap.room.id, parthiaMap.previousRoom.id, entrySpecialExit.."@#"..entrySpecialExitRoomOrder)
  mapDebug("function parthiaMap.connectRooms, special exit from room id: "..parthiaMap.room.id.." to room id: "..parthiaMap.previousRoom.id.." exit type: \""..exitedSpecialExit.."@#"..exitedSpecialExitRoomOrder.."\". Inside else of if parthiaMap.specialExitAttempted")

  if parthiaMap.specialExitAttempted then --special movement while mapping used
    if #parthiaMap.room.confirmedExits[entryDir] &lt; 2 then
      setExit(parthiaMap.room.id, parthiaMap.previousRoom.id, parthiaMap.getEntranceDirection())
      addCustomLine(parthiaMap.room.id, parthiaMap.previousRoom.id, parthiaMap.directionWalked, "solid line", {127,127,127}, false)
      mapDebug("function parthiaMap.connectRooms, exit from id: "..parthiaMap.room.id.." to room id: "..parthiaMap.previousRoom.id.." going direction "..parthiaMap.getEntranceDirection()..". In if parthiaMap.specialExitAttempted.")
    else
      pecho("&lt;green&gt;Multiple exits found in each room of movement. You will need to return to the previous room to map the path from this room, to the previous room.&lt;reset&gt;\n")
    end --if #parthiaMap.room.confirmedExits[entryDir] &lt; 2
  end --if parthiaMap.specialExitAttempted
end --function parthiaMap.connectRooms()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.Move(room, previousRoom, directionWalked)</name>
					<packageName></packageName>
					<script>function parthiaMap.Move(room, previousRoom, directionWalked)
  parthiaMap.moveNeeded = false --Movement needs to be delayed because sometimes there is not SKOOT 10 message. This is used to track if movement has already begun. Used in function parthiaMap.delayMove()
  if parthiaMap.notMovement then --if the trigger that called this function was not from movement. Stop the function
    parthiaMap.notMovement = false
    return
  end --if parthiaMap.notMovement
  room = room or parthiaMap.room
  previousRoom = previousRoom or parthiaMap.previousRoom
  directionWalked = directionWalked or parthiaMap.directionWalked
  local entryIndex = 1 --key for the exit in confirmed exits table. For the current room's exit that was used to enter the room
  local exitIndex = 1 --key for the exit in confirmed exits table. For the previous room's exit that was used to enter this room
  local entryDir = parthiaMap.getEntranceDirection() --direction player entered current room
  local x,y,z = 0,0,0 --coordinates for current location
  local dir = directionWalked --direction player walked
  if room.xpos and room.ypos and room.size then --if we have the data to set the current rooms area set to rooms area
    parthiaMap.setRoomArea() --set the area of the current room
    parthiaMap.findAdjacentRooms() --find what rooms are by the players current room
    parthiaMap.findRoomExits() --finds exits on the TEC Map for the room the player is in
  else
    if parthiaMap.mapping then --if a player is currently creating new maps
      tecErrorNotification("function parthiaMap.Move, was not able to collect room size or position in TEC Map, if next room is a new room it will not be created.")
    else
      mapDebug("function parthiaMap.Move, was not able to collect room size or position in TEC Map, if next room is a new room it will not be created.")
    end --if parthiaMap.mapping
  end --if room.xpos and room.ypos and room.size
  
  --if the or previous room has no exits, it is a desk, market stall or other `room` within a room. Stop movement.
  if (next(parthiaMap.room.confirmedExits) == nil  and next(parthiaMap.room.specialExits) == nil) --current room has no exits
  or (next(parthiaMap.previousRoom.confirmedExits) == nil  and next(parthiaMap.previousRoom.specialExits) == nil) then --previous room had no exits
    parthiaMap.room.id = previousRoom.id --record the corrent room id.
    parthiaMap.setCharacterLocation() --center on the new room, make certain character location gets saved. Also resets special movement booleans.
    mapDebug("function parthiaMap.Move, found room within room. No movement room id copied.")
    return --stop the movement
  end --if  next(parthiaMap.room.confirmedExits) == nil and next(parthiaMap.room.specialExits) == nil

  if previousRoom then --if we are not mapping the first room
  
    --find the keys needed for exited and entered exits.
    if parthiaMap.previousRoom.confirmedExits then --verify the exits table exists
      if parthiaMap.previousRoom.confirmedExits[dir] and parthiaMap.room.confirmedExits[entryDir] then --make certain this is not an exitless movement
        if #parthiaMap.previousRoom.confirmedExits[dir] &gt; 1 --only do if either the current or previous room have multiple exits.
        or #parthiaMap.room.confirmedExits[entryDir] &gt; 1 then
          --loop through current and previous room confirmedExits tables, find what room coordinate leads to the previous room
          for previousRoomExitsKey, previousRoomExit in ipairs(parthiaMap.previousRoom.confirmedExits[dir]) do --loop through previous room's exits
            
            --get a target coordinate that will match the correct room coordinates in the confirmed exits table
            if previousRoomExit.room and previousRoomExit.open then --if a room was found for this exit.
              local targetCoord = parthiaMap.room.size * .5 --We need to adjust x and y by half the room's size
              if targetCoord &lt; 1 then targetCoord = 0 end --if the previous room is size 1 we do not adjust by size
              local previousRoomAdjust = parthiaMap.previousRoom.size * .5 --We need to adjust x and y by half the room's size
              if previousRoomAdjust &lt; 1 then previousRoomAdjust = 0 end --if the previous room is size 1 we do not adjust by size
              targetCoord = -(targetCoord + previousRoomAdjust) --invert variable, it will be use to represent top left corner of the previousRoom
              --loop through current exits, seeing if the room they lead to is the previousRoom
              for currentRoomExitsKey, currentRoomExits in ipairs(parthiaMap.room.confirmedExits[entryDir]) do --loop through current rooms exits
                --pecho("previousRoomExit.room.xpos: "..previousRoomExit.room.xpos.." currentRoomExits.room.xpos: "..currentRoomExits.room.xpos.." targetCoord: "..targetCoord.."\n")
                --pecho("previousRoomExit.room.ypos: "..previousRoomExit.room.ypos.." currentRoomExits.room.ypos: "..currentRoomExits.room.ypos.." targetCoord: "..targetCoord.."\n")
                if currentRoomExits.room and previousRoomExit.open then
                  if  previousRoomExit.room.xpos + currentRoomExits.room.xpos == targetCoord
                  and previousRoomExit.room.ypos + currentRoomExits.room.ypos == targetCoord then
                    entryIndex = currentRoomExitsKey
                    exitIndex = previousRoomExitsKey
                    break --stop the loop found what we are looking for
                  end --if  previousRoomExit.room.xpos + parthiaMap.room.confirmedExits[entryDir][entryIndex].room.xpos == targetCoord
                end
              end --for ipairs(parthiaMap.room.confirmedExits[entryDir])
            end --if previousRoomExit.room
          end --for ipairs(parthiaMap.previousRoom.confirmedExits[dir])
        end --if #parthiaMap.previousRoom.confirmedExits[dir] &gt; 1
      end --if parthiaMap.previousRoom.confirmedExits[dir] and parthiaMap.room.confirmedExits[entryDir]
    end --if parthiaMap.previousRoom.confirmedExits
    
    parthiaMap.entryIndex = entryIndex --index used to tell what exit was entered through to get to current room
    parthiaMap.exitIndex = exitIndex --index used to tell what exit was exited through from previous room to get to current room

    --We are at a known location within the map data, use that to track location.
    if previousRoom.id then --if we had a previous room
      mapDebug("Attempting movement from previous room id: "..previousRoom.id)
      local previousArea = getRoomArea(previousRoom.id) --get the area id for the last room
      if parthiaMap.currentAreaID == previousArea then --supports creating new area where movement in previous area would have been legal. Like creating new area while in welcome area logging into a character than attempting to map the game world
        if parthiaMap.specialExitMovement then --if a special exit was used during this movement
          room.coords = {getRoomCoordinates(parthiaMap.specialExitMovement)} --record room coordinates
          parthiaMap.setCharacterLocation(parthiaMap.specialExitMovement) --center on the new room, make certain character location gets saved
          mapDebug("function parthiaMap.Move, able to get current room ID "..room.id.." from previous rooms special exits table.")
          return parthiaMap.specialExitMovement --stop function return id moved to
        else --all other movement types
          if parthiaMap.mapping then --if creating new maps
            if not parthiaMap.specialExitAttempted then --if this is a standard cardinal movement. Needing when 
              local previousExits = getRoomExits(previousRoom.id)--exits in previous room holds neighboring room IDs.
              if previousExits[dir] then --The last room the character was in has this rooms ID in its exits table
                room.coords = {getRoomCoordinates(previousExits[dir])}
                room.id = previousExits[dir] --collect the current room's id
                parthiaMap.setCharacterLocation() --center on the new room, make certain character location gets saved
                mapDebug("function parthiaMap.Move, able to get current room ID "..room.id.." from previous rooms exits table. Inside if not parthiaMap.specialExitAttempted.")
                return room.id --stop function return id moved to
              end --if previousExits[dir]
            end --if not parthiaMap.specialExitAttempted
          else --not creating new maps.
              local previousExits = getRoomExits(previousRoom.id)--exits in previous room holds neighboring room IDs.
              if previousExits[dir] then --The last room the character was in has this rooms ID in its exits table
                room.coords = {getRoomCoordinates(previousExits[dir])}
                room.id = previousExits[dir] --collect the current room's id
                parthiaMap.setCharacterLocation() --center on the new room, make certain character location gets saved
                mapDebug("function parthiaMap.Move, able to get current room ID "..room.id.." from previous rooms exits table.")
                return room.id --stop function return id moved to
              end --if previousExits[dir]
          end --if parthiaMap.mapping
        end --if parthiaMap.specialExitMovement else
      end --if parthiaMap.currentAreaID == previousArea then
    end --if previousRoom.id

    mapDebug("function parthiaMap.Move, Unable to find current room ID from previous room exits table. Calculating it now")

    --character is moving into an unmapped space. 
    if previousRoom.size and previousRoom.id then
      mapDebug("function parthiaMap.Move, previousRoom size and ID available gathering coordinates of previousRoom.id: "..previousRoom.id)
      x,y,z = getRoomCoordinates(previousRoom.id)
      if x == nil or y == nil or z == nil then --should be code here to handle being lost.
        mapDebug("function parthiaMap.Move, previousRoom.id refers to room that no longer exists. Setting coordinates to 0,0,0.")
        x,y,z = 0,0,0
        previousRoom.size = 0 --previous room size should not be used.
        previousRoom.id = nil
      end --if x == nil or y == nil or z == nil
    else --if previousRoom.size and previousRoom.id, data in previousRoom table is not useable
      if not previousRoom.size then
        mapDebug("function parthiaMap.Move, previous room size not available. Using 0.")
        previousRoom.size = 0
      end --if not previousRoom.size
      if previousRoom.coords then --if we know the previous rooms coordinates use them
        x,y,z = unpack(previousRoom.coords)
        if x == nil or y == nil or z == nil then
          x,y,z = 0,0,0
          mapDebug("function parthiaMap.Move, found previous room coords but they did not unpack properly. Using 0,0,0.")
        else --if x == nil or y == nil or z == nil
          mapDebug("function parthiaMap.Move, previousRoom.coords available but NOT ID.")
        end --if x == nil or y == nil or z == nil
      else --we do not know where we are.
        mapDebug("function parthiaMap.Move, previous room coords not available. Using 0,0,0.")
        x,y,z = 0,0,0
      end --if previousRoom.coords
    end --if previousRoom.size and previousRoom.id
  else --if previousRoom, previous room does not exist
    mapDebug("function parthiaMap.Move, previous room table not available. Using size 0 coordinates 0,0,0")
    previousRoom = {}
    previousRoom.size = 0
    x,y,z = 0,0,0
  end --if previousRoom

  --Character is in an unmapped area. Find coordinates and create a room if
  mapDebug("function parthiaMap.Move, getting room coordinates room.size: "..room.size.." previousRoom.size: "..previousRoom.size.." directionWalked: "..directionWalked.."\n")

  --determin where the new room needs to be.
  if dir == "u" or dir == "up" then
    z = z + 1
  elseif dir == "down" or dir == "d" then
    z = z - 1
  else --movement is not up or down
    if parthiaMap.previousRoom then --if this is not the first movement.
      if parthiaMap.room.confirmedExits[entryDir] then --verify there is a exit in the direction player is moving
        if parthiaMap.room.confirmedExits[entryDir][entryIndex].room then --verify there is a room on the map for this exit
          local roomSizeAdjustment = parthiaMap.room.size * .5 --We need to adjust x and y by half the room's size
          if roomSizeAdjustment &lt; 1 then roomSizeAdjustment = 0 end --if the previous room is size 1 we do not adjust by size
          y = y + parthiaMap.room.confirmedExits[entryDir][entryIndex].room.ypos + roomSizeAdjustment --use the location of the current room in reference to the previous room to decide the players coordinates
          x = x + -(parthiaMap.room.confirmedExits[entryDir][entryIndex].room.xpos) - roomSizeAdjustment ---use the location of the current room in reference to the previous room to decide the players coordinates
        else --The mapper did not show a room in this direction. Meaning vertical movement with horizonal directional command.
--[[
Prefface below. That code can not handle a large room with many smaller rooms exiting into it, or (vice versa) a direction with multiple exits.
code to hangle movement that is vertical in game without the player going up or down goes here
A good place to test this is the stands in the colosseum.
When you go up the benches it will not show rooms to the east or west.
Another location that does this is the Iridine bank.
Fix is probably using the two room sizes to resolve.
]]--
          if dir == "north" then
            y = y+(1*room.size)
          elseif dir == "northeast" then
            y = y+(1*room.size)
            x = x+(1*previousRoom.size)
          elseif dir == "east" then
            x = x+(1*previousRoom.size)
          elseif dir == "southeast" then
            y = y-(1*previousRoom.size)
            x = x+(1*previousRoom.size)
          elseif dir == "south" then
            y = y-(1*previousRoom.size)
          elseif dir == "southwest" then
            y = y-(1*previousRoom.size)
            x = x-(1*room.size)
          elseif dir == "west" then
            x = x-(1*room.size)
          elseif dir == "northwest" then
            y = y+(1*room.size)
            x = x-(1*room.size)
          end --if dir ==

          if parthiaMap.mapping then
            pecho("Movement through an exit that had no room on the TEC provided map occured.\n"..
                  "Please verify this rooms position on the Parthia Map matches its position in the TEC Map. Room pips in Parthia map should be at the upper left corner of where that room appears on the TEC Map.\n"..
                  "If it is incorrect room can be dragged and dropped into the correct location.\n")
          end --if parthiaMap.mapping
          if parthiaMap.playerClimbed then --If the player climb to get to the room they are in, we know veritcal and horizontal movement occured.
            if parthiaMap.mapping then pecho("Movement that was both vertical and horizontal at the same time was detected. ") end
            if parthiaMap.getStepsGoUp() then --if mapper has set steps to go up than increase Z
              z = z + 1
              if parthiaMap.mapping then
                pecho("This movement was considerted to be upward movement. If it was downward movement please go back to your previous room. Delete this room. Run command ")
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map steps go down", 
                  [[parthiaMap.setStepsGoUp(false, true)]],
                  "Steps and ramps go up", true)
                pecho(" or ")
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapdown", 
                  [[parthiaMap.setStepsGoUp(false, true)]],
                  "Steps and ramps go down", true)
              end --if parthiaMap.mapping
            else --if mapper has set steps to go down, than decrease z
              z = z - 1
              if parthiaMap.mapping then
                pecho("This movement was considerted to be downward movement. If it was upward movement please go back to your previous room. Delete this room. Run command ")
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map steps go up", 
                  [[parthiaMap.setStepsGoUp(true, true)]],
                  "Steps and ramps go up", true)
                pecho(" or ")
                pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapup", 
                  [[parthiaMap.setStepsGoUp(true, true)]],
                  "Steps and ramps go down", true)
              end --if parthiaMap.mapping
            end --if parthiaMap.getStepsGoUp()
          end --if parthiaMap.playerClimbed
        end --if parthiaMap.room.confirmedExits[entryDir][1].room
      end --if parthiaMap.room.confirmedExits[entryDir]
    end --if parthiaMap.previousRoom
  end --if dir == "u" or dir == "up"

  room.coords = {x,y,z} --collect the coordinates we used we may never need it though
  mapDebug("function parthiaMap.Move, room coords after move are: "..x..","..y..","..z)

  local roomFound = getRoomsByPosition(parthiaMap.currentAreaID,x,y,z) --move and check if there is a room here
  if roomFound[0] then --making certain there is not an unexpecrted room here
    parthiaMap.room.id = roomFound[0] --set the room id
    mapDebug("Lost room found ID: "..parthiaMap.room.id)
    if parthiaMap.mapping then --if player is creating new maps
      parthiaMap.connectRooms() --connect the exit nodes for the room player is in and the one they moved from
    end --if parthiaMap.mapping
    parthiaMap.setCharacterLocation() --center on the new room, make certain character location gets saved
  else --no unexpected room found
    if parthiaMap.mapping then --if player is creating new maps
      parthiaMap.addRoom() --we are mapping in a space with no previous room, add one.
    else
      mapDebug("function parthiaMap.Move, Mapping currently disabled. In unmapped area.")
    end --if parthiaMap.mapping
  end --if roomFound[0]
  
  parthiaMap.save(false) --movement successful, save new room ID to file.
  
  mapDebug("function parthiaMap.Move, Completed mapping space that was previously unmapped.")

end --parthiaMap.Move(room, previousRoom, directionWalked)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.getEntranceDirection(directionWalked)</name>
					<packageName></packageName>
					<script>--Returns the opposit direction it is passed.
function parthiaMap.getEntranceDirection(directionWalked)
  dir = directionWalked or parthiaMap.directionWalked
  if dir == "north" then --return the oposite of the direction walked in to find where player entered this room
    return "south"
  elseif dir == "northeast" then
    return "southwest"
  elseif dir == "east" then
    return "west"
  elseif dir == "southeast" then
    return "northwest"
  elseif dir == "south" then
    return "north"
  elseif dir == "southwest" then
    return "northeast"
  elseif dir == "west" then
    return "east"
  elseif dir == "northwest" then
    return "southeast"
  elseif dir == "u" or dir == "up" then
    return "down"
  elseif dir == "down" then
    return "up"
  end --if dir ==
end </script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.addRoom(room, previousRoom)</name>
					<packageName></packageName>
					<script>--creates a new room in mudlet's mapping system. Arguments are optional.
function parthiaMap.addRoom(room, previousRoom)
  room = room or parthiaMap.room
  previousRoom = previousRoom or parthiaMap.previousRoom

  if parthiaMap.mapping then --if the player is creating new maps
    local newID = createRoomID() --create a new ID in the mudlet maping system
    mapDebug("Creating room name: "..room.name.." with ID "..newID)
    room.id = newID --collect the new ID
    addRoom(room.id) --create the new room
    setRoomArea(room.id, parthiaMap.currentAreaID) --set room to area currently being mapped.
    setRoomName(room.id, room.name) --give the room a name
    
    --create exits --https://wiki.mudlet.org/w/Manual:Mapper_Functions#setExitStub
    for exitDirection,exit in pairs(room.exits) do --loop through all the exits found
      mapDebug("function parthiaMap.addRoom, creating exit stub in direction "..exitDirection)
      setExitStub(room.id, exitDirection, true) --make the exit stubs

      if exit.door and exitDirection ~= "up" and exitDirection ~= "down" then --there is a door in one of the directions that setDoor supports
        local doorMade = setDoor(room.id, parthiaMap.getShortDirection(exitDirection), 1) --create an open door. 
        if doorMade then --if the door was created successfully
          mapDebug("function parthiaMap.addRoom, created door in exit direction "..exitDirection)
        else --if doorMade, the door failed to be made
          tecWarningNotification("function parthiaMap.addRoom, failed to make door  in direction "..exitDirection)
        end --if doorMade
      end --if exit.door

    end --for pairs(exits)
    
    --set room coordinates
    if parthiaMap.previousRoom then --if we are NOT mapping the first room
      setRoomCoordinates(room.id,unpack(room.coords)) --set coordinates if we are mapping
      if previousRoom.id then --if we have a previous room ID, connect the rooms
        parthiaMap.connectRooms() --connect the exit nodes for the room player is in and the one they moved from
      end --if parthiaMap.previousRoom.id
    else --if this is the first room mapped
      setRoomCoordinates(room.id,0,0,0)
    end --if parthiaMap.previousRoom
    
    --set room's user data
    --setRoomUserData(341, "some table", yajl.to_string({name = "bub", age = 23}))
    
    parthiaMap.setCharacterLocation() --center on the new room, make certain character location gets saved
  end --if parthiaMap.mapping
end --function parthiaMap.addRoom()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.clearAreaRooms(areaID)</name>
					<packageName></packageName>
					<script>--[[
delte all rooms in an area
Usage
parthiaMap.clearAreaRooms(1)
This function is used in alias "parthia map area clear ID"
]]--
function parthiaMap.clearAreaRooms(areaID)
  areaID = areaID or parthiaMap.currentAreaID
  local areaTable = getAreaRooms(areaID)
  
  --get the name of this area
  local areasTable = getAreaTable() --get a table that contains all the ids and names of of each area
  local areaName = ""
  for k,v in pairs(areasTable) do --loop through all the areas that have been created
    if v == areaID then areaName = k break end --when we find the area to clear record the name
  end --for pairs(areasTable)
  
  if not areaTable[0] then --if the table is empty there are no rooms in this area.
    pecho("No rooms found in area name: "..areaName..". Area ID: "..areaID.."\n")
    return
  end --if not areaTable[0]
  
  for i=0, #areaTable do --loop through the entire area table, bug means there is an index 0
    pecho("Removing room ID: "..areaTable[i].."\n")
    deleteRoom(areaTable[i]) --delete each room found
  end --for i=0, #areaTable
  
end --function parthiaMap.resetAreaRooms(areaID)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.trackPreviousRoom()</name>
					<packageName></packageName>
					<script>--used to track what the previous room was
function parthiaMap.trackPreviousRoom()

  --prepare for next movement
  parthiaMap.previousRoom = {}
  parthiaMap.previousRoom = table.deepcopy(parthiaMap.room) --keep track of what the previous room was
  if parthiaMap.previousRoom.id then
    mapDebug("function parthiaMap.trackPreviousRoom(),  migrated room to previousRoom previousRoom ID now: "..parthiaMap.previousRoom.id)
  else
    mapDebug("&lt;yellow&gt;function parthiaMap.trackPreviousRoom(), migrated room to previous room. No ID available.&lt;reset&gt;")
  end --if parthiaMap.previousRoom.id
  
  parthiaMap.resetRoom() --clear the room table
  
end --function parthiaMap.trackPreviousRoom()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.load(displayToScreen)</name>
					<packageName></packageName>
					<script>--load player character locations from file.
function parthiaMap.load(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)

  if io.exists(parthiaMap.savePath) then --if the file exists, load it.
    table.load(parthiaMap.savePath, parthiaMap.saveTable)
    if displayToScreen then pecho("[  OK  ]  - Parthia map settings successfully loaded from file.\n") end
  else --the save file does not exist
    if displayToScreen then pecho("[ Info ]  - No map settings file.\n") end
  end --if io.exists(parthiaMap.savePath)

end --function parthiaMap.load(displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.save(displayToScreen)</name>
					<packageName></packageName>
					<script>--Save map settings to file
function parthiaMap.save(displayToScreen)
  displayToScreen = fuzzyBoolean(displayToScreen)
  parthiaTableSave(parthiaMap.saveTable, parthiaMap.savePath, false, displayToScreen)
end --function parthiaMap.save()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.getShortDirection(dir)</name>
					<packageName></packageName>
					<script>--returns the short hand version of a dirrection.
--Currently only needed because function setDoor requires shorthand direction
function parthiaMap.getShortDirection(dir)
  if dir then
    if type(dir) ~= "string" then
      tecErrorNotification("parthiaMap.getShortDirection, sent a non string variable for argument 1. Expected string, receive a "..type(dir))
    end
  else
    tecErrorNotification("parthiaMap.getShortDirection, requires a string for argument 1.")
  end
  
  
  if dir == "north" then --return the oposite of the direction walked in to find where player entered this room
    return "n"
  elseif dir == "northeast" then
    return "ne"
  elseif dir == "east" then
    return "e"
  elseif dir == "southeast" then
    return "se"
  elseif dir == "south" then
    return "s"
  elseif dir == "southwest" then
    return "sw"
  elseif dir == "west" then
    return "w"
  elseif dir == "northwest" then
    return "nw"
  elseif dir == "u" or dir == "up" then
    return "u"
  elseif dir == "down" or dir == "d" then
    return "d"
  end --if dir ==

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.detectDirection(dir)</name>
					<packageName></packageName>
					<script>--[[
used to sort movement to a direction the parthia mapping system supports.
currently only supports up and down movement.
Will support all directions and sepecial movement like go gate or go 2 gate

Useage
parthiaMap.detectDirection("up")
parthiaMap.detectDirection("down")
]]--

--used to tell detectDirection what is NOT going to be z movement.
--Made outside the function so it is not recreated each time the function is called. Wasting processing time.
parthiaMap.notZMovement = {
  "east", "eas", "ea", "e",
  "southeast", "se",
  "south", "sout", "sou", "so", "s",
  "southwest", "sw",
  "west", "wes", "we", "w",
  "northwest", "nw",
  "north", "nort", "nor", "no", "n",
  "northeast", "ne",
  "leave", "leav", "lea", "le"
}

local zMovement = {
  "up", "u",
  "down", "d"
}

--returns the room id a special exit leads to
--intended to be used with captured user movement commands that are special exit commands.
local function specialExitMatch(playerCmd)
  if playerCmd then
    if type(playerCmd) ~= "string" then
      tecErrorNotification("function specialExitMatch, argument 1 expected string variable receive a "..type(playerCmd))
      return
    end --if type(playerCmd) ~= "string"
  else 
    tecErrorNotification("function specialExitMatch, argument 1 expected received nil")
  end --if playerCmd
  
  playerCmd = playerCmd:lower() --make certain variables are lower case, so matching will be more accurate
  parthiaMap.specialExitAttempted = true --records if a special exit was attempted. Used to automatically create a special exit for mappers.
  
  local plCmdExitNum = playerCmd:match("^%s*(%d+)%s") --capture the number at the start of the line, if it is there.
  local plCmdExitDesc = playerCmd:match("^%s*%d*%s*(.+)%s*") --capture the description of the exit provided in the player's command
  
  mapDebug("function specialExitMatch, playerCmd: \""..playerCmd.."\" plCmdExitNum: "..tostring(plCmdExitNum).." plCmdExitDesc: \""..plCmdExitDesc.."\"\n")
  
  if plCmdExitNum == nil then plCmdExitNum = 1 end --if the player did not specify an exit number check for the first match
  plCmdExitNum = tonumber(plCmdExitNum) --convert it to number for future matching

  spExits = getSpecialExitsSwap(parthiaMap.room.id) --collect special exits in this room
  
  --check if players command perfectly matches a special exit a mapper created
  --sort the table in order the rooms these exits appear in the SKOOT 6 message
  local sortedSpExits = {}
  for exitDesc,exitRoomID in pairs(spExits) do
    ----check if the players command perfectly matches a special exit.
    if exitDesc == playerCmd then
      mapDebug("function specialExitMatch, found perfect special exit match for player command: "..playerCmd.." to roomID: "..exitRoomID..". Inside if exitDesc == playerCmd")
      parthiaMap.specialExitMovement = exitRoomID
      return exitRoomID --found the correct exit type. Return it's room ID
    end --if exitDesc == playercmd
    --sort the exits table
    local sortKey = tonumber(exitDesc:match("#(%d)$"))
    if sortKey then
      table.insert(sortedSpExits, sortKey, exitDesc)
    else
      mapDebug("&lt;orange&gt;function specialExitMatch, failed to find a room order for exit: "..exitDesc.."&lt;reset&gt;")
    end --if sortKey
  end --for pairs(spExits)
  
  --find the exit the player is looking for in the sortedSpExits table
  local i = 0 --iterator to keep track of how may times the exit exitDesc (exit description from the players command) is found in this rooms special exits table
  for _,v in pairs(sortedSpExits) do
    if v:match(plCmdExitDesc) then --if the exit type the player is checking for exists.
      i = i + 1 --increase match iterator
      if i == plCmdExitNum then --if the exit number matches the number the player input.
        for exitDesc, exitRoomID in pairs(spExits) do
          if v == exitDesc then
            mapDebug("function specialExitMatch, found special exit match at: \""..v.."\" to roomID: "..exitRoomID.."\n")
            parthiaMap.specialExitMovement = exitRoomID --record id to global variable
            return exitRoomID --found the correct exit type. Return it's room ID
          end --if v == exitDesc
        end --for pairs(spExits)
      end --if i == plCmdExitNum
    end --if v:match(plCmdExitDesc)
  end --for pairs(sortedSpExits)

  mapDebug("&lt;orange&gt;function specialExitMatch, failed to find a special exit from command player ran.&lt;reset&gt;\n")

end --local function specialExitMatch(exit)

function parthiaMap.detectDirection(playerCmd)
  playerCmd = playerCmd or parthiaMap.directionWalked
  playerCmd = playerCmd:lower()
  parthiaMap.playerCmd = playerCmd --record the command the player used
  
  --if this is Z movement
  if table.contains(zMovement, playerCmd) then
    if parthiaMap.upAvailable then --if it is possible for the player to move up
      if playerCmd == "up" then --player is going up
        parthiaMap.directionWalked = "up"
        parthiaMap.dirtectionCollected = true
        mapDebug("function detectDirection, directionWalked up found.")
        return
      elseif parthiaMap.room.exits["up"].description:match(playerCmd) then
        parthiaMap.directionWalked = "up"
        parthiaMap.dirtectionCollected = true
        mapDebug("function detectDirection, directionWalked up found.")
        return
      end --if parthiaMap.room.exits["up"].description:match(playerCmd)
    end --if parthiaMap.upAvailable
    
    if parthiaMap.downAvailable then --if it is possible for the player to move down
      if playerCmd == "down" then --player is going down
        parthiaMap.directionWalked = "down"
        parthiaMap.dirtectionCollected = true
        mapDebug("function parthiaMap.horizontalTracking, directionWalked down found.")
        return
      elseif parthiaMap.room.exits["down"].description:match(playerCmd) then
        parthiaMap.directionWalked = "down"
        parthiaMap.dirtectionCollected = true
        mapDebug("function parthiaMap.horizontalTracking, directionWalked down found.")
        return
      end --if parthiaMap.room.exits["down"].description:match(playerCmd)
    end --if parthiaMap.downAvailable
  elseif table.contains(parthiaMap.notZMovement, playerCmd) then
    --code to adjust standardmovement goes here.
  else --if the input is not a standard movement, a special exit command was used
    specialExitMatch(playerCmd) --find what exit, than room ID this command leads to
  end --if not table.contains(parthiaMap.notZMovement, playerCmd)
end --parthiaMap.horizontalTracking</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.setRoomArea()</name>
					<packageName></packageName>
					<script>--[[
sets area of a room. Default is players current room.
requires the "room" passed to it is a table that has variables:
room.size, number the size of the room
room.xpos, number the xposition of the room on the current TEC Map
room.ypos, number the yposition of the room on the current TEC Map
]]--
function parthiaMap.setRoomArea(room)
  room = room or parthiaMap.room --collect room table.
  --Make certain the argument passed is a table and has all the required variables
  if type(room) ~= "table" then
    tecErrorNotification("function parthiaMap.setRoomArea, argument 1 expected table variable receive a "..type(exitDescription))
    return
  else --if a table was passed, make certain 
    if (not room.size) or (type(room.size) ~=  "number") then
      tecErrorNotification("function parthiaMap.setRoomArea, requires table passed have a number variable size, ie room.size")
      return
    end --if not room.size
    if (not room.xpos) or (type(room.xpos) ~=  "number") then
      tecErrorNotification("function parthiaMap.setRoomArea, requires table passed have a number variable xpos, ie room.xpos")
      return
    end --if not room.size
    if (not room.ypos) or (type(room.ypos) ~=  "number") then
      tecErrorNotification("function parthiaMap.setRoomArea, requires table passed have a number variable ypos, ie room.ypos")
      return
    end --if not room.size
  end --if type(exitDescriptionUsed) ~= "string"
  
  room.area = {} --create table to hold room area.
  
  --create a table that represents the squeres the room covers on the TEC Map
  for xi=0, room.size do --loop until the room size is reached.
    room.area[(room.xpos+xi)] = {} --create a table for xposition. That is the coordinates the room is painted on the TEC map.
    for yi=0, room.size do --loop until the room size is reached
      room.area[(room.xpos+xi)][(room.ypos+yi)] = true --fill the xposition table to show what the room covers on the y access of the TEC map
    end --for yi=0, room.size
  end --for xi=0, room.size
end --function parthiaMap.setRoomArea(room)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.trackTECMapRooms(size, xpos, ypos)</name>
					<packageName></packageName>
					<script>--[[
used to track where rooms appear in the SKOOT 6 message
Or where rooms appear on the TEC Map.
We do this so we can check if these rooms are adjacent to the players room
this is important so we can figure out the coordinates for the room the player walks to.
This is called in function parthiaDrawMapRooms() and collects the rooms size xpos and ypos
]]--

--ADD ERROR CHECKING!!!!!!!!!!!!!!!!!

function parthiaMap.trackTECMapRooms(size, xpos, ypos)
  if not parthiaMap.TECMapRooms then
    parthiaMap.TECMapRooms = {}
  end
  
  --if trackTECMapRooms was passed the players current room than do not map it. Should not be needed.
  --if parthiaMap.room.size == size and parthiaMap.room.xpos == xpos and parthiaMap.room.ypos == ypos then
  --  return
  --end --if parthiaMap.room.size == size and parthiaMap.room.xpos == xpos and parthiaMap.room.ypos == ypos
  
  table.insert(parthiaMap.TECMapRooms, {})
  if not next(parthiaMap.TECMapRooms[#parthiaMap.TECMapRooms]) then --the table is empty
    parthiaMap.TECMapRooms[#parthiaMap.TECMapRooms].size = tonumber(size/10) --collect the size for parthiaMap
    parthiaMap.TECMapRooms[#parthiaMap.TECMapRooms].xpos = tonumber(xpos/10) --used to calculate area of room and where other rooms should be created while mapping
    parthiaMap.TECMapRooms[#parthiaMap.TECMapRooms].ypos = tonumber(ypos/10) --used to calculate area of room and where other rooms should be created while mapping
  else --the table was not created
    tecErrorNotification([[function parthiaMap.trackTECMapRooms, failed to make a room table at parthiaMap.TECMapRooms[]]..(#parthiaMap.TECMapRooms+1).."]")
  end --if parthiaMap.TECMapRooms[#parthiaMap.TECMapRooms]

end --function parthiaMap.trackTECMapRooms(size, xpos, ypos)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.trackTECMapExits(direction, xpos, ypos, open)</name>
					<packageName></packageName>
					<script>--[[
Used to track where all the exits are that appear in SKOOT 10 message
]]--

--ADD ERROR CHECKING!!!!!!!!!!!!!!!!!

function parthiaMap.trackTECMapExits(direction, xpos, ypos, open)
  if not parthiaMap.TECMapExits then
    parthiaMap.TECMapExits = {}
  end
  if open then --if the exit is open
    if open == "1" then
      open = true
    elseif open == "0" then
      open = false
    end --if open == "1"
  else --if the exit was not passed. Assume it is open.
    open = true
  end --if open
   
  table.insert(parthiaMap.TECMapExits, {})
  if not next(parthiaMap.TECMapExits[#parthiaMap.TECMapExits]) then --the table is empty
    parthiaMap.TECMapExits[#parthiaMap.TECMapExits].direction = tostring(direction) --collect orientation of the exit
    parthiaMap.TECMapExits[#parthiaMap.TECMapExits].xpos = tonumber(xpos/10) --used to see if this exit is for the players current room
    parthiaMap.TECMapExits[#parthiaMap.TECMapExits].ypos = tonumber(ypos/10) --used to see if this exit is for the players current room
    parthiaMap.TECMapExits[#parthiaMap.TECMapExits].open = open
  else --the table was not created
    tecErrorNotification([[function parthiaMap.trackTECMapExits, failed to make a exit table at parthiaMap.TECMapExits[]]..(#parthiaMap.TECMapExits+1).."]")
  end --if parthiaMap.TECMapExits[#parthiaMap.TECMapExits]

end --function parthiaMap.trackTECMapExits(direction, xpos, ypos)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.findAdjacentRooms()</name>
					<packageName></packageName>
					<script>--[[
Used to find the rooms by the players current room

]]--

--put the loop that checks for rooms in a function.
--This way if we find a match it is easy to stop checking this room with return
local function loopRooms(TECMapRoom)
  for xi=0, TECMapRoom.size do --loop through the possible adjacent room's x position
    if parthiaMap.room.area[(TECMapRoom.xpos+xi)] then --if the rooms share a x position
      for yi=0, TECMapRoom.size do --loop through the possible adjacent room's y position
        if parthiaMap.room.area[(TECMapRoom.xpos+xi)][(TECMapRoom.ypos+yi)] then --if the rooms share BOTH a x AND y position these rooms are side by size.
          table.insert(parthiaMap.room.adjacentRooms, table.deepcopy(TECMapRoom))
          return --match found, do not check this room any longer.
        end --if parthiaMap.room.area[(TECMapRoom.xpos+xi)][(TECMapRoom.ypos+yi)]
      end --for yi=0, TECMapRoom.size
    end --if parthiaMap.room.area[(TECMapRoom.xpos+xi)]
  end --for xi=0, TECMapRoom.size
end --function loopRooms(TECMapRoom)

function parthiaMap.findAdjacentRooms()
  parthiaMap.room.adjacentRooms = {} --we should NOT have an existing adjacentRooms table so make a blank one
  for k,roomToCheck in ipairs(parthiaMap.TECMapRooms) do --loop through the rooms found on the Alice TEC Map
    loopRooms(roomToCheck) --use the function above because we would like to stop checking when the room is known to be adjacent.
  end --for ipairs(parthiaMap.TECMapRooms)
end --function parthiaMap.findAdjacentRooms()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>round(num, numDecimalPlaces)</name>
					<packageName></packageName>
					<script>--[[
rounds a numer to the decimal point specified with the second argument
usage:
round(1.1) --returns 1
round(1.23, 1) --returns 1.2
round(1.5) --returns 2
]]--
function round(num, numDecimalPlaces)
  return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num)) --don't know I didn't write it. Got it from a google
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.findSpecialExits(exitEcho)</name>
					<packageName></packageName>
					<script>--[[
finds the description for all the current rooms exits.
Store this in the parthiaMap.room.exits table.
these descriptions will stored in userdata
  than used when a player runs a command to use a keyword on an exit.
method
players runs `go 2 door`
mapper 
]]--
function parthiaMap.findSpecialExits(exitEcho)
  exitEcho = exitEcho or parthiaMap.room.exitEcho
  local previousRoomType = ""
  parthiaMap.room.specialExits = {}
  local spExitToDir = {} --keep track of special exits for directions
  local lastSpExit = "" --keep track of the last special exit that appears 
  
  for exit in string.gmatch( exitEcho, "00[^0]%x[^0]%x\"&gt;(.-)&lt;\/" ) do --find exits for this room
    
    --upwards and downwards is not a function exit type. Though it appears on the exit echo
    if exit == "upwards" then exit = "up" end
    if exit == "downwards" then exit = "down" end
    
    --if this exit is a standard exit name
    if table.contains(parthiaMap.directions, exit) then 
      
      --record the direction(s) special exits go
      if #spExitToDir &gt; 1 then --there has been more than one exit since the last standard exit
        for k,v in ipairs(spExitToDir) do --loop through those previous special exits found
          table.insert(parthiaMap.room.specialExits[v],exit) --record the direction those special exits go in
        end --for ipairs(spExitToDir)
      else --there is has only been one special exit since last
        table.insert(parthiaMap.room.specialExits[lastSpExit],exit)
      end --if #spExitToDir &gt; 1
      spExitToDir = {} --prevents duplicate entries
    
    else --this is a special exit
    
      --track special exits
      table.insert(spExitToDir, exit)
      parthiaMap.room.specialExits[exit] = {}
      lastSpExit = exit --keep track of the last special exit used
      
    end --if table.contains(parthiaMap.directions, exit)
    
    if table.contains(parthiaMap.directions, exit) then --if this exit is a standard exit name
      local exitIsADoor = false --will tell addRoom function if there is a door at this exit
      if previousRoomType:lower():match("door") or previousRoomType:lower():match("gate") then --check if this exit is a door or gate
        exitIsADoor = true 
      end --if previousRoomType:lower():match("door") or previousRoomType:lower():match("gate")
      parthiaMap.room.exits[exit] = { door = exitIsADoor } --mark that this direction is a door or a gate so the mapper can add a door later.
      if exit == "up" then --if this exit allows player to move up or down
        parthiaMap.upAvailable = true --needed because go u could be short for something other than go up
        parthiaMap.room.exits[exit].description = previousRoomType --keep track of a description of the exit. Use this to compair against movement commands like go ladder
      elseif exit == "down" then
        parthiaMap.downAvailable = true --needed because go d, could be used as short for go door
        parthiaMap.room.exits[exit].description = previousRoomType --keep track of a description of the exit. Use this to compair against movement commands like go ladder
      end --if exit == "up"
    end --if table.contains(parthiaMap.directions, exit)
    previousRoomType = exit --Keep track of the last room type used.
  end --for string.gmatch( line, "0020ff\"&gt;(%P+)&lt;\/" )
  
  local tmpCurrentRoomType = exitEcho:match("^You arrive at (%P+)%p")
  if tmpCurrentRoomType then --if something was found above.
    if parthiaMap.getEnabled() then --if player is using parthiaMap
      parthiaMap.room.name = tmpCurrentRoomType --collect this description for a room name.
    end --if parthiaMap.getEnabled()
  end --if tmpCurrentRoomType

  --collection direction walked for mapper
    if not parthiaMap.dirtectionCollected then --if we have not collection a movement direction yet do so now.
      parthiaMap.directionWalked = exitEcho:match(" You are facing (%a+)%.")
      if parthiaMap.directionWalked then
        mapDebug("function addlinksToDirections, Direction walked: "..parthiaMap.directionWalked)
      else
        mapDebug("function addlinksToDirections, could collect direction walked")
      end --if parthiaMap.directionWalked
    end --if not parthiaMap.dirtectionCollected
    parthiaMap.dirtectionCollected = false --reset directionCollected for next movement.

end --function parthiaMap.findSpecialExits()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.findRoomExits()</name>
					<packageName></packageName>
					<script>--[[
Detects if an exit touches the area the room the player is in than verifies the exit is for this room
Determines which adjacent room that exit leads to

Something to keep in mind while figuring adjacent objects.
ypos having a negative number means the object appears high on the map. NOT lower
xpos works as normal.
The objects draw point or 0,0 of that object is the top left of that object

if multiple exits horizontal
  exit 1 is the more northern exit. Exit 2 is the more southern exit
  The exit that defaults to that direction is the more northern. IE command east will go through the more norther exit.
  
if multiple exits vertical
  exit 1 is the more western. Exit 2 is the more eastern exit
  The exit that defaults to that direction is the more western. IE command north will go through the more western exit. This means we will attach 
  
in the case of multiple exits in the same direction we need to determine which is the exit when the player uses that standard direction command east west north south...

We will check for matching rooms to exits by the exits in the parthiaMap.room.confirmedExits table this way we are not needlessly doing matches.
]]--

--for each know exit, find what room it leads to than track that.
function sortAdjacentRooms()
  
  for exitDirection,directionExitsTable in pairs(parthiaMap.room.confirmedExits) do --loop through exits know to be for this room
    for _, exitTable in ipairs(directionExitsTable) do
      if exitTable.open then --make certain the exit is open, if it is not there is no room that it connects to.
        --If this is a corner exit, find the room it leads to, put that room in the parthiaMap.room.confirmedExits[exitDirection].room table
        if exitDirection == "northwest" or exitDirection == "southwest" or exitDirection == "southeast" or exitDirection == "northeast" then --if this is a corner exit
        mapDebug("function sortAdjacentRooms, checking for room at exit: "..exitDirection)
          --The math for all diaginal movement is the same only variables change
          if not parthiaMap.room.corners then --if the table does not already exist
            parthiaMap.room.corners = {} 
            parthiaMap.room.corners.northwest = { --where the northwest corner is for the current room
             xpos = parthiaMap.room.xpos, --nw's x position
             ypos = parthiaMap.room.ypos --nw's y position
            }
            parthiaMap.room.corners.northeast = { xpos = parthiaMap.room.xpos+parthiaMap.room.size, ypos = parthiaMap.room.ypos, }
            parthiaMap.room.corners.southeast = { xpos = parthiaMap.room.xpos+parthiaMap.room.size, ypos = parthiaMap.room.ypos+parthiaMap.room.size, }
            parthiaMap.room.corners.southwest = { xpos = parthiaMap.room.xpos , ypos = parthiaMap.room.ypos+parthiaMap.room.size}
          end --if not parthiaMap.room.corners
          for k,adjacentRoom in ipairs(parthiaMap.room.adjacentRooms) do --loop through rooms know to be adjacent of the players room
            if not adjacentRoom.sorted then --if the proper exit for this room has not been found yet.
              local adjacentRoomCorner = {} --Checking for rooms in a corner use the same math for all corners. Only variables change. Use this table to use those variables
              adjacentRoomCorner.northwest = { --store the x y coords of the corner in this room that matches up with the northwest corner of the players current room
                xpos = adjacentRoom.xpos+adjacentRoom.size, --x for the corner we want to check
                ypos = adjacentRoom.ypos+adjacentRoom.size --y for the corner we want to check 
              } --cornerTable.northwest
              adjacentRoomCorner.northeast = {xpos = adjacentRoom.xpos, ypos = adjacentRoom.ypos+adjacentRoom.size}
              adjacentRoomCorner.southeast = {xpos = adjacentRoom.xpos, ypos = adjacentRoom.ypos}
              adjacentRoomCorner.southwest = {xpos = adjacentRoom.xpos+adjacentRoom.size, ypos = adjacentRoom.ypos}
              mapDebug("\tfunction sortAdjacentRooms, checking room, adjacentRoom.xpos: "..adjacentRoom.xpos.." adjacentRoom.ypos: "..adjacentRoom.ypos.." adjacentRoom.size: "..adjacentRoom.size)
              mapDebug("\tfunction sortAdjacentRooms, compairing adjacentRoomCorner[exitDirection].xpos: "..adjacentRoomCorner[exitDirection].xpos.." to parthiaMap.room.corners[exitDirection].xpos "
              ..parthiaMap.room.corners[exitDirection].xpos.." AND adjacentRoomCorner[exitDirection].ypos: "..adjacentRoomCorner[exitDirection].ypos
              .." to parthiaMap.room.corners[exitDirection].ypos: "..parthiaMap.room.corners[exitDirection].ypos)
              if  (adjacentRoomCorner[exitDirection].xpos == parthiaMap.room.corners[exitDirection].xpos) and (adjacentRoomCorner[exitDirection].ypos == parthiaMap.room.corners[exitDirection].ypos) then --if the appropriate corners of the two rooms are aligned this is the correct room for this exit.
                mapDebug("function sortAdjacentRooms, parthiaMap.room.adjacentRooms.xpos: "..adjacentRoomCorner[exitDirection].xpos.." parthiaMap.room.adjacentRooms.ypos: "..adjacentRoomCorner[exitDirection].ypos.." is "..exitDirection.." of the current room.")
                exitTable.room = adjacentRoom --record info for this room in the appropriate exit table
                adjacentRoom.sorted = true --this room does not need to be checked again.
                break --found this exit no need to keep looking.
              end --if  (cornerTable[exitDirection].xpos == parthiaMap.room.xpos) and (cornerTable[exitDirection].ypos == parthiaMap.room.ypos)
            end --if not roomTable.sorted
          end --for ipairs(parthiaMap.room.adjacentRooms)
        elseif exitDirection == "north" or exitDirection == "south" or exitDirection == "east" or exitDirection == "west" then
          for k,adjacentRoom in ipairs(parthiaMap.room.adjacentRooms) do --loop through rooms know to be adjacent of the players room
            local sidesTable = {} --track where the sides for this room are
            sidesTable.north = { --remember each side is a line
              axisMin = adjacentRoom.xpos, --where n starts for this room. Furthest west location
              axisMax = adjacentRoom.xpos+adjacentRoom.size, --where n ends for this room. Furthest east location
              oppositeAxis = adjacentRoom.ypos+adjacentRoom.size, --Where n is on y or it's north south location
              exitAxis = exitTable.xpos, --where the exit is on x, east west
              exitOppositeAxis = round(exitTable.ypos) --where the exit is on y, north south
            } --sidesTable
            sidesTable.south = { axisMin = adjacentRoom.xpos, axisMax = adjacentRoom.xpos+adjacentRoom.size, oppositeAxis = adjacentRoom.ypos , exitAxis = exitTable.xpos, exitOppositeAxis = round(exitTable.ypos)}
            sidesTable.east = { axisMin = adjacentRoom.ypos, axisMax = adjacentRoom.ypos+adjacentRoom.size, oppositeAxis = adjacentRoom.xpos , exitAxis = exitTable.ypos, exitOppositeAxis = round(exitTable.xpos)}
            sidesTable.west = { axisMin = adjacentRoom.ypos, axisMax = adjacentRoom.ypos+adjacentRoom.size, oppositeAxis = adjacentRoom.xpos+adjacentRoom.size, exitAxis = exitTable.ypos, exitOppositeAxis = round(exitTable.xpos) }
            --using variables above is the exit we are checking within the side of the adjacent that shares a side with the current room
            if sidesTable[exitDirection].exitAxis &gt;= sidesTable[exitDirection].axisMin and sidesTable[exitDirection].exitAxis &lt;= sidesTable[exitDirection].axisMax
            and sidesTable[exitDirection].exitOppositeAxis == sidesTable[exitDirection].oppositeAxis then
              exitTable.room = adjacentRoom --record info for this room in the appropriate exit table
              adjacentRoom.sorted = true --this room does not need to be checked again.
            end --if sidesTable[exitDirection].exitAxis &gt;= sidesTable[exitDirection].axisMin and sidesTable[exitDirection].exitAxis &lt;= sidesTable[exitDirection].axisMax and sidesTable[exitDirection].exitOppositeAxis == sidesTable[exitDirection].oppositeAxis
          end --for ipairs(parthiaMap.room.adjacentRooms)
        end --if exitDirection.match("northwest")
      end --if exitTable.open
    end --for ipairs(directionExitsTable)
  end --for pairs(parthiaMap.room.confirmedExits)
end --function sortAdjacentRooms()

--[[
function sortRoomExits, takes exit's xpos ypos and direction than decides what room exit it belongs to
  this function is called in another inside a loop. So it can stop the current check when an exit is sorted

if the exit is at the lowest x, highest y and dir is "northwest" that is the northwest exit
if the exit is at the highest x, highest y and dir is "northeast" that is the ne exit
if the exit is at the lowest x, lowest y and dir is "northeast" that is the southwest exit
if the exit is at the highest x, lowest y and dir is "northwest" that is the se exit
if the exit is on the highest x and dir is "hor" that is the east exit
if the exit is on the lowest x and dir is "hor" that is the west exit
if the exit is on the highest y and dir is "ver" that is the south exit, Yes that is correct. Highest.
if the exit is on the lowest y and dir is "ver" that is the north exit
]]--
local function sortRoomExits(roomExits)
  
    --track the location of the room's exits
    local xposRounded = round(roomExits.xpos) --round the positions. They have length, so they are slightly off point so they are centered between the two rooms.
    local yposRounded = round(roomExits.ypos) --round the positions. They have length, so they are slightly off point so they are centered between the two rooms.
    
    --track the area of the room
    local roomXMin = parthiaMap.room.xpos
    local roomXMax = parthiaMap.room.xpos + parthiaMap.room.size
    local roomYMin = parthiaMap.room.ypos
    local roomYMax = parthiaMap.room.ypos + parthiaMap.room.size
    
    if roomExits.direction == "hor" or roomExits.direction == "ver" then -- if this is an east, west, north or south exit
      --Math needed to determin north sout east and west is the same. We only need to change the variables being checked.
      --The sidesTable sorts the variables we need when determening which direction this exit refers to.
      local sidesTable = { 
        { exit = "east", --direction currently being looked for
          axisPoint = roomXMax, --point on the axis the exit needs to be on for this direction
          exitAxis = xposRounded, --the axis point of the exit for this direction
          exitOppositeAxis = roomExits.ypos, --opposite axis of this exit for this direction
          oppositeAxisMin = roomYMin, --The lowest the exit can be on the opposit axis
          oppositeAxisMax = roomYMax, --The highest the exit can be on the opposit axis
          acceptableDirection = "hor" --an acceptable orentation for the exit's direction on the map
        }, --end table {exit = "east...}
        { exit = "west", axisPoint = roomXMin,  exitAxis = xposRounded, exitOppositeAxis = roomExits.ypos, oppositeAxisMin = roomYMin, oppositeAxisMax = roomYMax, acceptableDirection = "hor"},
        { exit = "north", axisPoint = roomYMin,  exitAxis = yposRounded, exitOppositeAxis = roomExits.xpos, oppositeAxisMin = roomXMin, oppositeAxisMax = roomXMax, acceptableDirection = "ver"},
        { exit = "south", axisPoint = roomYMax,  exitAxis = yposRounded, exitOppositeAxis = roomExits.xpos, oppositeAxisMin = roomXMin, oppositeAxisMax = roomXMax, acceptableDirection = "ver"},
      } --end sidesTable
      for _,side in ipairs(sidesTable) do --Loop through the sidesTable above
        if side.axisPoint == side.exitAxis then --if the side we are checking shares an access point with the exit.
          if side.exitOppositeAxis &gt;= side.oppositeAxisMin and side.exitOppositeAxis &lt;= side.oppositeAxisMax then --Make certain the exit is in the current rooms area
              if side.acceptableDirection == roomExits.direction then --if the orientation for the exit is correct for this side
                if not parthiaMap.room.confirmedExits[side.exit] then --if the exit side is not already tracked and confirmed             
                  parthiaMap.room.confirmedExits[side.exit] = {}
                  table.insert(parthiaMap.room.confirmedExits[side.exit], roomExits)
                  return --Found the side this exit belongs on. No further checks needed.     
                else --a table has already been created for this exit.
                  local position
                  if side.exit == "east" or side.exit == "west" then
                    position = "ypos"
                  elseif side.exit == "north" or side.exit == "south" then
                    position = "xpos"
                  else
                    local errorFound = "failed to find position while sorting multiple exits for a single side."
                    tecWarningNotification("function parthiaMap.sortRoomExits, "..errorFound)
                    return errorFound
                  end --if side.exit == "east" or side.exit == "west"
                  
                  table.insert(parthiaMap.room.confirmedExits[side.exit], roomExits) --insert this exit into
                  return --Found the side this exit belongs on. No further checks needed.

                end --if not parthiaMap.room.confirmedExits[side.exit]
              end --if acceptableDirection == roomExits.direction
          end --if side.exitOppositeAxis &gt;= side.oppositeAxisMin and side.exitOppositeAxis &lt;= side.oppositeAxisMax
        end --if side.axisPoint == side.exitAxis
      end --for ipairs(sidesTable)
    elseif roomExits.direction == "nw" or roomExits.direction == "ne" then
      --Math needed to determin corners is the same. We only need to change the variables being checked.
      --The cornerTable sorts the variables we need when determening which direction this exit refers to.
      local cornerTable = {
        { x = roomXMin, --acceptable x point for the exit we are checking for
          y = roomYMin, --acceptable y point for the exit we are checking for
          direction = "nw", --direction the exit icon is oriented in
          skipDir = "ne", --a exit icon direction that can be skipped for this cornerTable
          exit = "northwest" --what direction we are checking for
        }, --end table {exit = "northwest"}
        { x = roomXMax, y = roomYMin, direction = "ne", skipDir = "nw", exit = "northeast" },
        { x = roomXMin, y = roomYMax, direction = "ne", skipDir = "nw", exit = "southwest" },
        { x = roomXMax, y = roomYMax, direction = "nw", skipDir = "ne", exit = "southeast" },
      } --end cornerTable
      for k,corner in ipairs(cornerTable) do --loop through the variables in the cornerTable above 
        --mapDebug("function sortRoomExits, for exit: "..corner.exit.." corner.x: "..corner.x.. " to xposRounded: "..xposRounded)
        if corner.x == xposRounded then --does the exit's xposition match the x position for this corner?
          --mapDebug("\tChecking corner.y: "..corner.y.. " to yposRounded: "..yposRounded)
          if corner.y == yposRounded then --does the exit's yposition match the y position for this corner?
            --mapDebug("\tChecking corner.direction: "..corner.direction.." agains roomExits.direction: "..roomExits.direction)
            if roomExits.direction == corner.direction then --is the orentation for the exit's icon on the TEC Map of the corrent type for this corner?
              if not parthiaMap.room.confirmedExits[corner.exit] then --make certain the corner is was not already sorted
                parthiaMap.room.confirmedExits[corner.exit] = {}
                table.insert(parthiaMap.room.confirmedExits[corner.exit],roomExits)
                return --found what we were looking for
              else --for some reason this exit has already been sorted!
                tecWarningNotification("function sortRoomExits, found second corner.direction:"..corner.direction.." exit.")
              end --if not parthiaMap.room.confirmedExits["northwest"]
            elseif roomExits.direction == skipDir then --this is an exit for a nearby room
              return --stop the check, this exit is for a different room
            end --if roomExits.direction == corner.direction
          end --if corner.y == yposRounded
        end --if corner.x == xposRounded
      end --for ipairs(cornerTable)
    else --the exit is of an unknown type.
      tecWarningNotification("function sortRoomExits, found an exit with an unknown direction. Expected northwest ne hor or ver, received: "..roomExits.direction)
    end --if roomExits.direction == "hor" or roomExits.direction == "ver", elseif roomExits.direction == "nw" or roomExits.direction == "ne"
    
end --local function sortRoomExits()

function parthiaMap.findRoomExits()
  parthiaMap.room.TECMapExits = {} --make or reset table to store exits that appear in this rooms area.
  
  --find exits that surrounds this room on the map. May not be for this room yet.
  for k,exitToCheck in ipairs(parthiaMap.TECMapExits) do --loop through all exits that appear on the tec map when player is in this room
    local xposRounded = round(exitToCheck.xpos) --rounds to the nearest whole number
    local yposRounded = round(exitToCheck.ypos) --rounds to the nearest whole number
--    mapDebug("function parthiaMap.findRoomExits, checking exit at: xpos: "..exitToCheck.xpos.." Rounded to: "..xposRounded.." and ypos: "..exitToCheck.ypos.." Rounded to: "..round(yposRounded).."\n")
    if parthiaMap.room.area[xposRounded] then --if the exit shares a xposition with the current room on the TECMap
      if parthiaMap.room.area[xposRounded][yposRounded] then --if the exit shares both an x and y position with the current room.
        table.insert(parthiaMap.room.TECMapExits, table.deepcopy(exitToCheck)) --exit on map is one for this room. Keep track of it
      end --if parthiaMap.room.area[xposRounded][yposRounded]
    end --if parthiaMap.room.area[xposRounded]
  end --for k,exitToCheck in ipairs(parthiaMap.TECMapExits)
  
  for _,roomExits in ipairs(parthiaMap.room.TECMapExits) do --loop through exits that are in this room's area
    sortRoomExits(roomExits) --sort the exits clearly labeling which exit is what direction. 
  end --for k,roomExits in ipairs(parthiaMap.room.TECMapExits)
  
  sortAdjacentRooms() --local function for each know exit, find what room it leads to than track that.
  
end --function parthiaMap.findRoomExits()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.getEnabled()</name>
					<packageName></packageName>
					<script>--[[
Used to check if parthia map is being used
Useage: 
if parthiaMap.getEnabled() then
  --code that requires mapper here
end
]]--
function parthiaMap.getEnabled()
  return tecSettings.parthiaMapEnabled
 end --parthiaMap.getEnabled()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.setEnabled(mode, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
Sets if parthia uses the mudlet mapping system.
usage:
parthiaMap.setEnabled(true) --enable parthia's mapping system
parthiaMap.setEnabled(false) --disable parthia's mapping system
]]--
function parthiaMap.setEnabled(mode, displayToScreen)
  --make certain variables passed are good
  mode = fuzzyBoolean(mode)
  displayToScreen = fuzzyBoolean(displayToScreen)
  
  tecSettings.parthiaMapEnabled = mode --set the state for parthiaMap
  debugToDisplay("function parthiaMap.setEnabled, set tecSettings.parthiaMapEnabled to "..tostring(mode))
  
  if displayToScreen then 
    if mode then --mapping was enabled
      pecho("Parthia map enabled.\n")
    else --mapping was disabled
      pecho("Parthia map disabled.\n")
    end --if mode
    dontForgetToSave() --remind player to save their changes
  end --if displayToScreen
  
end --parthiaMap.setEnabled(mode, displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.getStepsGoUp()</name>
					<packageName></packageName>
					<script>--[[
Used to check if steps that go in non vertical directions go up or down.

Useage: 
if parthiaMap.getStepsGoUp() then
  --code that adds to z movement here
else
  --code that removes from z movement here
end

This function is used in parthiaMap.Move function
]]--
function parthiaMap.getStepsGoUp()
  return parthiaMap.stepsGoUp
end --function parthiaMap.getStepsGo()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.setStepsGoUp(mode, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
sets variable parthiaMap.stepsGoUp
This variable is true by default. Seting is function parthiaMap.config
if true steps go up, add to Z access
if false steps go down, remove from Z access

Usage:
parthiaMap.setStepsGoUp(true, true) --would set steps to go up and display a message to screen
parthiaMap.setStepsGoUp(false) --would set steps to go down
parthiaMap.setStepsGoUp() --would set steps to go down

This function is used in aliases:
parthia map steps go down
parthia map steps go up
]]--
function parthiaMap.setStepsGoUp(mode, displayToScreen)
  --make certain variables passed are good
  mode = fuzzyBoolean(mode)
  displayToScreen = fuzzyBoolean(displayToScreen)
  
  parthiaMap.stepsGoUp = mode --tell parthia map if steps go up or down
  parthiaMap.playerClimbed = false --if true the player climbed during their last movement.
  mapDebug("parthiaMap.setStepsGoUp, set parthiaMap.stepsGoUp to: "..tostring(mode))
  
  if displayToScreen then --if true display a message to screen
    if mode then --if true steps go up, or z gets added to
      pecho("When steps are used with horizontal movement methods they will be considered to go up. Z access will get added to when steps are used.\n")
    else --false means steps go down, or z gets subtracted from
      pecho("When steps are used with horizontal movement methods they will be considered to go down. Z access will get subtracted from when steps are used.\n")
    end --if mode
    pecho("This setting does not have a method to save to file.\n")
  end --if displayToScreen
  
end --parthiaMap.setStepsGoUp(mode, displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.setCharacterLocation(id, displayToScreen)</name>
					<packageName></packageName>
					<script>--[[
sets the room the current character is in
This function is called in alias `parthia map character move`, functions parthiaMap.Move, parthiaMap.addRoom, and parthiaMap.checkCharacter
usage:
parthiaMap.setCharacterLocation(id, displayToScreen)
  id, is a room id.
  displayToScreen, controls if messages are shown on main console.
examples:
  parthiaMap.setCharacterLocation(3) --sets the characters location on the parthia map to room id 3. Messages on only displayed to debug and error consoles.
  local errorFound = parthiaMap.setCharacterLocation(3) --sets the characters location on the parthia map to room id 3. Messages on only displayed to debug and error consoles. If errors are found a message describing them is put into variable errorFound
  parthiaMap.setCharacterLocation(3, true) --sets the characters location on the parthia map to room id 3. Messages displayed on main console and all error and debug consoles.
]]--
function parthiaMap.setCharacterLocation(id, displayToScreen)
  id = id or parthiaMap.room.id --set id to current rooms id
  displayToScreen = fuzzyBoolean(displayToScreen)
  
  if id then
    local roomsAreaID = getRoomArea(id) --check if this room id has an area set.
    if roomsAreaID then --all rooms are know to have areas. We are using this to verify this room exists.
      parthiaMap.room.id = id --update the current room's id
    else --the room does not exist
      local errorFound = "Attempted to change character location to room id: "..id.." the room was not found."
      if displayToScreen then pecho(errorFound) end
      tecWarningNotification("function parthiaMap.setCharacterLocation, "..errorFound)
      return roomsAreaID
    end --if roomExists
    centerview(id) --highly characters room on the map
    parthiaMap.currentAreaID = roomsAreaID --collect the area ID of the current room
    --reset movement variables to defaults
    parthiaMap.playerClimbed = false
    parthiaMap.specialExitMovement = false
    parthiaMap.specialExitAttempted = false --records if a special exit was attempted. Used to automatically create a special exit for mappers.
    parthiaMap.entryIndex = 1 --index used to tell what exit was entered through to get to current room
    parthiaMap.exitIndex = 1 --index used to tell what exit was exited through from previous room to get to current room
    if parthiaMap.saveTable[parthiaPlayer.CurrentCharacter.name] then --if the current character has location in the map save table.
      parthiaMap.saveTable[parthiaPlayer.CurrentCharacter.name].roomID = id --record the id to the map settings save table
      parthiaMap.room.id = id --record the ID to the mapper current room's id.
      local errorFound = parthiaTableSave(parthiaMap.saveTable, parthiaMap.savePath, false, false) --save the location change to file. So location is know on startup.
      if errorFound then --an error was found
        if displayToScreen then --display error message to file
          tecErrorNotification("function parthiaMap.setCharacterLocation, "..errorFound)
        else --do not display error message to file.
          tecErrorNotification("function parthiaMap.setCharacterLocation, "..errorFound, false)
        end --if displayToScreen
      end --if errorFound
      if displayToScreen then pecho("Player in room id: "..tostring(id)..".\n") end
    else
      tecWarningNotification("function parthiaMap.setCharacterLocation, table key parthiaMap.saveTable[parthiaPlayer.CurrentCharacter.name] unavailable.")
    end --if parthiaMap.saveTable[parthiaPlayer.CurrentCharacter.name]
  else --no room id is available
    local errorFound = "No room ID after data verification.\n"
    if displayToScreen then pecho(errorFound) end
    tecWarningNotification("function parthiaMap.setCharacterLocation, "..errorFound)
    return errorFound
  end --if id
end --function parthiaMap.setCharacterLocation(id, displayToScreen)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.checkCharacter()</name>
					<packageName></packageName>
					<script>--[[
This function changes the character that is currently logged in and on the map
It is called in trigger: `stats` within function setStatsCheckActive(false), only when it is sent false. Indicating stats collection and space filtering has completed
This function needs the character name to run. the stats filter is what collects the playername
]]--
function parthiaMap.checkCharacter(displayToScreen)
  local character = ""
  if parthiaPlayer.CurrentCharacter.name then --if logged into a character account
    character = parthiaPlayer.CurrentCharacter.name
  else --if the stats command does not work, the player is in the welcome room
    character = "Welcome Room ID"
    parthiaPlayer.CurrentCharacter.name = character
  end --if parthiaPlayer.CurrentCharacter.name
  displayToScreen = fuzzyBoolean(displayToScreen)
  if not parthiaMap.saveTable[character] then --if this character does not exist in the table parthiaMap uses to save
    parthiaMap.saveTable[character] = {}
    if displayToScreen then pecho("A character name of \""..character.."\", was not found in save file.") end
    mapDebug("function parthiaMap.checkCharacter, created table for character \""..character.."\" in the parthiaMap.saveTable table.")
  end --if not parthiaMap.saveTable[character]
  
  if parthiaMap.saveTable[character].roomID then --if the player had a previously saved location
    local errorFound = parthiaMap.setCharacterLocation(parthiaMap.saveTable[character].roomID) --sets the current characters location and centers map view on that room
    if errorFound then --if an error occured while attempting to set the current character's location
      local errorMessage = "Unable to move character, error recived from setCharacterLocation is: "..errorFound
      if displayToScreen then pecho(errorMessage) end
      tecWarningNotification("function parthiaMap.checkCharacter, received error from parthiaMap.setCharacterLocation. Error was: "..errorMessage)
    else --no errors found
      local parthiaMessage = "Moved character "..character.." to room ID: "..parthiaMap.saveTable[character].roomID.."\n"
      if displayToScreen then pecho(parthiaMessage) end
      mapDebug("function parthiaMap.checkCharacter, "..parthiaMessage)
    end --if errorFound
--code for finding a room hash here
  end --if parthiaMap.saveTable[character].roomID
end --parthiaMap.loadCharater(character)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.setMapping(displayToScreen)</name>
					<packageName></packageName>
					<script>function parthiaMap.setMapping(displayToScreen)
  --enable or disable new map creation
  if parthiaMap.mapping then
    parthiaMap.mapping = false
    if displayToScreen then pecho("&lt;green&gt;Mapping stopped.&lt;reset&gt;\n") end
  else
    parthiaMap.mapping = true
    if displayToScreen then pecho("&lt;green&gt;Mapping started.&lt;reset&gt;\n") end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.help()</name>
					<packageName></packageName>
					<script>function parthiaMappingTutorial()
  pecho("\nVerify mapping is enabled with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map enable", 
    [[parthiaMap.setEnabled(true, true)]],
    "Enable parthia map", true)
  pecho("\nTell parthia you want to make new maps with: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map mapping", 
    [[parthiaMap.setMapping(true)]],
    "Toggle new map creation", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/map", 
    [[parthiaMap.setMapping(true)]],
    "Toggle new map creation", true)
  pecho(".\n\nIf wanting to map a new area or no areas exist. Create a new area with command: ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map area add", 
    [[printCmdLine("parthia map area add ");
      pecho("Now type the name you would like to give to the new area.\n")]],
    "create new area", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapareaadd", 
    [[printCmdLine("/mapareaadd ");
      pecho("Now type the name you would like to give to the new area.\n")]],
    "create new area", true)
    pecho(". If they do no already exist it is recommended to create an area for the welcome Area and at least one for the game world.\n")
    pecho("\nTo support a second character in game you would need to place them in a know room and run: ")
      pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map character move", 
    [[printCmdLine("parthia map character move ");
      pecho("Now type the room id you would like to move to and press enter.\n")]],
    "move to room id", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapmove", 
    [[printCmdLine("/mapmove ");
      pecho("Now type the room id you would like to move to and press enter.\n")]],
    "move to room id", true)
  pecho(". Using the room id you know the character is currently in.\n")
end

function parthiaMap.help()
 pecho("Parthia map commands are\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map enable", 
    [[parthiaMap.setEnabled(true, true)]],
    "Enable parthia map", true)
  pecho(", enable parthia map.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map disable", 
    [[parthiaMap.setEnabled(false, true)]],
    "Enable parthia map", true)
  pecho(", enable parthia map.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map mapping", 
    [[parthiaMap.setMapping(true)]],
    "Toggle new map creation", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/map", 
    [[parthiaMap.setMapping(true)]],
    "Toggle new map creation", true)
  pecho(", toggle new map creation on or off.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map steps go up", 
    [[parthiaMap.setStepsGoUp(true, true)]],
    "Steps and ramps go up", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapup", 
    [[parthiaMap.setStepsGoUp(true, true)]],
    "Steps and ramps go down", true)
  pecho(", while mapping steps and ramps go up.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map steps go down", 
    [[parthiaMap.setStepsGoUp(false, true)]],
    "Steps and ramps go down", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapdown", 
    [[parthiaMap.setStepsGoUp(false, true)]],
    "Steps and ramps go down", true)    
  pecho(", while mapping steps and ramps go down.\n")

  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map character move", 
    [[printCmdLine("parthia map character move ");
      pecho("Now type the room id you would like to move to and press enter.\n")]],
    "move to room id", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapmove", 
    [[printCmdLine("/mapmove ");
      pecho("Now type the room id you would like to move to and press enter.\n")]],
    "move to room id", true)
  pecho(", move to a room id on the map.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map area add", 
    [[printCmdLine("parthia map area add ");
      pecho("Now type the name you would like to give to the new area.\n")]],
    "create new area", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapareaadd", 
    [[printCmdLine("/mapareaadd ");
      pecho("Now type the name you would like to give to the new area.\n")]],
    "create new area", true)
  pecho(", create new area.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map area remove", 
    [[printCmdLine("parthia map area remove ");
      pecho("Now type the name or id of the area to remove and press enter.\n")]],
    "create new area", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/maparearemove", 
    [[printCmdLine("/maparearemove ");
      pecho("Now type the name or id of the area to remove and press enter.\n")]],
    "create new area", true)    
  pecho(", create new area.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map area clear", 
    [[printCmdLine("parthia map area clear ");
      pecho("Now type the id of the area to clear the rooms from.\n")]],
    "clear rooms from area", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/mapareaclear", 
    [[printCmdLine("/mapareaclear ");
      pecho("Now type the id of the area to clear the rooms from.\n")]],
    "clear rooms from area", true)    
  pecho(", clear rooms from an area.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;parthia map character area", 
    [[printCmdLine("parthia map character area ");
      pecho("Now type the name of the area to remove and press enter.\n")]],
    "change mapping area", true)
  pecho(" or ")
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;/maparea", 
    [[printCmdLine("/maparea ");
      pecho("Now type the name of the area to remove and press enter.\n")]],
    "change mapping area", true)    
  pecho(", change the area being mapped.\n")
  
  pechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Mapping tutorial", 
    [[parthiaMappingTutorial()]],
    "Click for basic mapping tutorial", true)
  pecho(", display a basic mapping tutorial.\n")
end --function parthiaMap.help()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>parthiaMap.delayMove()</name>
					<packageName></packageName>
					<script>function parthiaMap.delayMove()

  if parthiaMap.moveNeeded then --if movement has not happened yet
    parthiaMap.Move() 
  end --if parthiaMap.moveNeeded

end --function parthiaMap.delayMove()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Windows</name>
			<packageName></packageName>
			<script>--Windows throughout Parthia, like compass or the multi window</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>status bar</name>
				<packageName></packageName>
				<script>status_bar = Geyser.Container:new({
  name = "Status",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
--GUIframe.addWindow(status_bar,"status_bar","bottom")

--set location for container in GUIframe.
status_bar.GUIframeLocation = "bottom"
--add cobntainer to UI manager.
UIManagerRegisterWindow(status_bar)</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Health Bar</name>
					<packageName></packageName>
					<script>hpbar = Geyser.Gauge:new({
  name="hpbar",
  x=0, y=0,
  width="50%", height="50%",
},status_bar)

hpbar.frontStyleSheet = [[
    border-image: url("]]..tecSettings.images["healthBar"].image..[[");
    border-radius: 5;
    margin: 5px;
]]
hpbar.front.styleSheet = hpbar.frontStyleSheet
hpbar.front:setStyleSheet(hpbar.front.styleSheet) --set the forground gradiant

hpbar.backStyleSheet = [[
    border-image: url("]]..tecSettings.images["healthBackground"].image..[[");
    border-radius: 5;
]]
hpbar.back.styleSheet = hpbar.backStyleSheet                            
hpbar.back:setStyleSheet(hpbar.back.styleSheet) --set the background gradiant

hpbar:setValue(100,100)
hpbar.text:echo("Health","black","cb14") --put writing on bar
hpbar.text:setClickCallback("parthiaStatusClick","health") --collect stats and show load to screen on click</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Fatigue Bar</name>
					<packageName></packageName>
					<script>fatiguebar = Geyser.Gauge:new({
  name="fatiguebar",
  x=0, y="50%",
  width="50%", height="50%",
},status_bar)

fatiguebar.frontStyleSheet = [[
    border-image: url("]]..tecSettings.images["fatigueBar"].image..[[");
    border-style: double;
    border-radius: 5;
    margin: 5px;
]]
fatiguebar.front.styleSheet = fatiguebar.frontStyleSheet
fatiguebar.front:setStyleSheet(fatiguebar.front.styleSheet)

fatiguebar.backStyleSheet = [[
    border-image: url("]]..tecSettings.images["fatigueBackground"].image..[[");
    border-style: double;
    border-radius: 5;
]]
fatiguebar.back.styleSheet = fatiguebar.backStyleSheet
fatiguebar.back:setStyleSheet(fatiguebar.back.styleSheet)

fatiguebar:setValue(100,100)
fatiguebar.text:echo("Fatigue","black","cb14") --put writing on bar
fatiguebar.text:setClickCallback("parthiaStatusClick","fatigue") --collect stats and show load to screen on click</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Hunger Bar</name>
					<packageName></packageName>
					<script>hungerbar = Geyser.Gauge:new({
  name="hungerbar",
  x="50%", y=0,
  width="50%", height="50%",
},status_bar)

hungerbar.frontStyleSheet = [[
    border-image: url("]]..tecSettings.images["hungerBar"].image..[[");
    border-radius: 5;
    margin: 5px;
]]
hungerbar.front.styleSheet = hungerbar.frontStyleSheet
hungerbar.front:setStyleSheet(hungerbar.front.styleSheet)

hungerbar.backStyleSheet = [[
    border-image: url("]]..tecSettings.images["hungerBackground"].image..[[");
    border-radius: 5;
]]
hungerbar.back.styleSheet = hungerbar.backStyleSheet
hungerbar.back:setStyleSheet(hungerbar.back.styleSheet)

hungerbar:setValue(100,100)
hungerbar.text:echo("Hunger","black","cb14") --put writing on bar
hungerbar.text:setClickCallback("parthiaStatusClick","hunger") --collect stats and show load to screen on click</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Encumbrance Bar</name>
					<packageName></packageName>
					<script>encumbrancebar = Geyser.Gauge:new({
  name="encumbrancebar",
  x="50%", y="50%",
  width="50%", height="50%",
},status_bar)
encumbrancebar.frontStyleSheet = [[
    border-image: url("]]..tecSettings.images["encumbranceBar"].image..[[");
    border-radius: 5;
    margin: 5px;
]]
encumbrancebar.front.styleSheet = encumbrancebar.frontStyleSheet
encumbrancebar.front:setStyleSheet(encumbrancebar.frontStyleSheet)
encumbrancebar.backStyleSheet = [[
    border-image: url("]]..tecSettings.images["encumbranceBackground"].image..[[");
    border-radius: 5;
]]
encumbrancebar.back.styleSheet = encumbrancebar.backStyleSheet
encumbrancebar.back:setStyleSheet(encumbrancebar.back.styleSheet)

encumbrancebar:setValue(100,100)
encumbrancebar.text:echo("Encumbrance","black","cb14") --put writing on bar
encumbrancebar.text:setClickCallback("parthiaStatusClick","encumbrance") --collect stats and show load to screen on click</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>resizeStatusWindow()</name>
					<packageName></packageName>
					<script>function resizeStatusWindow()
  displayDebug("resizeStatusWindow function, ran")
  resizeLabelText(encumbrancebar, 14, "black", "cb") --resize text according to label's height
  resizeLabelText(hungerbar, 14, "black", "cb") --resize text according to label's height
  resizeLabelText(fatiguebar, 14, "black", "cb") --resize text according to label's height
  resizeLabelText(hpbar, 14, "black", "cb") --resize text according to label's height
end --function resizeStatusWindow()</script>
					<eventHandlerList />
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>compasbar</name>
				<packageName></packageName>
				<script>--Reference https://wiki.mudlet.org/w/Manual:Geyser#Create_a_Clickable_Compass

--create compass object
--dirs directory
tecCompass = tecCompass or {
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"},
} --end tecCompass object declaration

--main container for tecCompass
tecCompass.window = Geyser.Container:new({
  name = "Compass",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
})

--back label for tecCompass
tecCompass.back = Geyser.Label:new({
  name = "tecCompass.back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecCompass.window) --The parent of this label. Main is main window.

--set background image for compass
tecCompass.back.styleSheet = [[border-image: url("]]..tecSettings.images["compassBackground"].image..[[");]]
tecCompass.back:setStyleSheet(tecCompass.back.styleSheet) --set the background label
    
tecCompass.overlay = Geyser.Label:new({
  name = "tecCompass.overlay",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },tecCompass.back) --put the label into the Compass container
tecCompass.overlay.styleSheet = [[border-image: url("]]..tecSettings.images["compassOverlay"].image..[[");]]
tecCompass.overlay:setStyleSheet(tecCompass.overlay.styleSheet) --set the background label
--tecCompass.overlay:setStyleSheet([[border-image: url("]]..getMudletHomeDir()..[[/imgs/compass/CompassOverlay.svg");]]) --set the background label

--Horizontal box
tecCompass.hbox = Geyser.HBox:new({
    name = "tecCompass.box",
    x = 0, --horizonal position in parent
    y = 0, --vertical position in parent
    width = "100%", --How wide box is, % of parent
    height = "100%", --How tall box is, % of parent
  },tecCompass.back) --parent of this Hbox

--create 3 vertical rows
--in parent object compas.box
tecCompass.row1 = Geyser.VBox:new({name = "tecCompass.row1",},tecCompass.hbox)
tecCompass.row2 = Geyser.VBox:new({name = "tecCompass.row2",},tecCompass.hbox)
tecCompass.row3 = Geyser.VBox:new({name = "tecCompass.row3",},tecCompass.hbox)

--create labels to hold compas images
--Each parent is the row that were 
--created with VBox above.
--row1 left row2 center row3 right
tecCompass.nw = Geyser.Label:new({
  name = "tecCompass.nw",
},tecCompass.row1)

tecCompass.w = Geyser.Label:new({
  name = "tecCompass.w",
},tecCompass.row1)

tecCompass.sw = Geyser.Label:new({
  name = "tecCompass.sw",
},tecCompass.row1)

tecCompass.n = Geyser.Label:new({
  name = "tecCompass.n",
},tecCompass.row2)
        
tecCompass.center = Geyser.VBox:new({
  name = "tecCompass.center",
},tecCompass.row2)

tecCompass.up = Geyser.Label:new({
  name = "tecCompass.up",
},tecCompass.center)

tecCompass.down = Geyser.Label:new({
  name = "tecCompass.down",
},tecCompass.center)

tecCompass.s = Geyser.Label:new({
  name = "tecCompass.s",
},tecCompass.row2)

tecCompass.ne = Geyser.Label:new({
  name = "tecCompass.ne",
},tecCompass.row3)
    
tecCompass.e = Geyser.Label:new({
  name = "tecCompass.e",
},tecCompass.row3)
  
tecCompass.se = Geyser.Label:new({
  name = "tecCompass.se",
},tecCompass.row3)
--end of compas labels

--when a label is clicked we want to
--go in that direction
function tecCompass.click(name)
  parthiaMap.detectDirection(name) --track up and down movement
  send(name)
end --tecCompass.click

--border for up and down macros when a room is available in that direction
tecCompass.styleSheetLitUpDown =
  [[QLabel{
  background-color: "]]..tecSettings.compassDefaultHighlight..[[";
  border: 2px solid ;
  border-color: #55FFFFFF}]]

--Function that will put images to direction labels. name will be n nw so on in tecCompass under triggers
function tecCompass.lit(name)
  if name == "up" or name == "down" then --if it is overlay for up or down label
    tecCompass[name]:setStyleSheet(tecCompass.styleSheetLitUpDown) --created a label with thick transparent border
  else --if it is a direction other than up or down.
    tecCompass[name]:setStyleSheet([[background-color: "]]..tecSettings.compassDefaultHighlight..[[";]])
  end --if name == "up" or name == "down"
end --function tecCompass.lit(name)

--when the space should be unlit make it fully transparent
function tecCompass.unlit(name)
  tecCompass[name]:setStyleSheet([[background-color: "#00000000";]])
end --function tecCompass.unlit(name)

--Each of the 9 labels need an image of an arrow.
--Rather than setting each individually, we'll
--iterate over the tecCompass.dirs table we made 
--awhile back and add the respective image to each.
--The names of images are a reflection of the tecCompass.dirs 
--table. This keeps it consistent and easy to refer to.
--During the iteration, the callback, setLabelOnEnter and
--setLabelOnLeave are also set for each label.

--loop through dirs in table tecCompass
for _,v in pairs(tecCompass.dirs) do
  tecCompass[v]:setStyleSheet([[
    background-color: "#000000FF";
  ]]) --apply pictures to directions on compass
  
  SetTooltip(tecCompass[v].name, "Go "..v.." ") --create hover tooltip for direction
  
	--if tecCompass is clicked, go in that direction
	tecCompass[v]:setClickCallback("tecCompass.click",v)  
end --end loop through tecCompass.dirs

--keeps the tecCompass square as the windows are adjusted.
function tecCompass.drawKeepSquare()

  --tecCompass.window:move(0,2) --small black break at top.

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_width() &lt; tecCompass.window:get_height() then
  	tecCompass.back:resize(tecCompass.window:get_width(), tecCompass.window:get_width())
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_height() &lt; tecCompass.window:get_width() then
  	tecCompass.back:resize(tecCompass.window:get_height(), tecCompass.window.height)
	end --end if height is less than width
  
  if tecCompass.back:get_width() &lt; tecCompass.window:get_width() then
    tecCompass.back:move((tecCompass.window:get_width() - tecCompass.back:get_width()) * .5)
  end
	
end --end function keep square.

--Add the status bar to the screen. On the bottom
--GUIframe.addWindow(tecCompass.window,"Compass","topleft")

--set location for container in GUIframe.
tecCompass.window.GUIframeLocation = "topleft"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecCompass.window)

--Now that we created the window. Make certain it is drawn correctly.
--tecCompass.drawKeepSquare() --function at the bottom of this script.</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Settings bar</name>
				<packageName></packageName>
				<script>tecSettingsBar = Geyser.Container:new({
  name = "Settings",    -- give it a unique name here
  x=0, y=0,                   
  width = 0, height=0, 
})

--box that will store the miniconsoles
tecSettingsBack = Geyser.Label:new({
  name = "tecSettingsBack",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},tecSettingsBar)

tecSettingsBack:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
tecSettingsConsole = Geyser.MiniConsole:new({
  name = "tecSettingsConsole",
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},tecSettingsBack)
tecSettingsConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
tecSettingsConsole:raise()

function tecSettingsWindowResize()
	
	--Resize the back label by 6. We want a 3px border around the entire window
	tecSettingsBack:resize(tostring(tecSettingsBar:get_width() - 0)
		, tostring(tecSettingsBar:get_height() - 0))
	tecSettingsBack:move (0, 0) --left and top borders
	
	--Resize the room character window by 6. We want a 3px border around the entire window
	tecSettingsConsole:resize(tostring(tecSettingsBack:get_width() - 0)
		, tostring(tecSettingsBack:get_height() - 0))
	tecSettingsConsole:move (0, 0) --left and top borders
  
  tecScrollBarCheck("tecSettingsConsole") --Checks if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." tecSettingsBack width: "..tecSettingsBack:get_width()
			.." tecSettingsBack Height: "..tecSettingsBack:get_height()
			.." tecSettingsConsole Width: "..tecSettingsConsole:get_width()
			.." tecSettingsConsole Height: "..tecSettingsConsole:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecSettingsWindowResize()

--set location for container in GUIframe.
tecSettingsBar.GUIframeLocation = "bottomleft"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecSettingsBar)

--tecRefreshSettingsWindow() --Refreshes text in settings window.
--tecSettingsWindowResize() --resize the Room Character window now</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tec map</name>
				<packageName></packageName>
				<script>--creates tec's 2d getAllMapUserData
--future ideas. create a zoom scroll with --tecMap_back:addScrollbars(tecMap, "RV")
--will probably need to complete that function for mudlet...

--Don't forget. Creating room and exit labels ahead of time reduces the time it takes to draw
--rooms while the user is playing. Do not create a system where we create labels as they play.

tecMap = Geyser.Container:new({
  name = "TEC Map",    -- give it a unique name here
  x=0, y=0,                   
  width = 0, height=0, 
  GUIframeLocation = "bottomright",
})

--Creating the background for the 2d tec map.
tecMap_back = Geyser.Label:new({
  name = "tecMap_back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecMap) --The parent of this label.

--set the appearance of what is behind the map
tecMap_back.styleSheet = [[border-image: url("]]..tecSettings.images["mapBackground"].image..[[");]]
tecMap_back:setStyleSheet(tecMap_back.styleSheet)

--rgba(25, 50, 150)

mapRoom = {} --Table to hold labels we will draw the rooms with
mapExit = {} --Table to hold labels we will draw the exits with.
--Creating empty rooms for our map system.
for i = 1, 150 do
	--Create empty room and exit labels. Hide them so no junk is on screen.
  mapRoom[i] = Geyser.Label:new({name = "mapRoom"..tostring(i),},tecMap_back) 
  mapExit[i] = Geyser.Label:new({name = "mapExit"..tostring(i),},tecMap_back) 
  mapRoom[i]:hide() --Hide the tab so they don't layer
	mapExit[i]:hide() --Hide the tab so they don't layer
end --end loop create tabs and consoles

function tecMapdrawKeepSquare()

  tecMap:move(0,0) --move the map down so there is a border on the top.
  --tecMap:resize(tecMap:get_width(), (tecMap:get_height() - 2))

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height the equal.
	if tecMap:get_width() &lt; tecMap:get_height() then
  	tecMap_back:resize(tecMap:get_width(), tecMap:get_width())
    --local centerAdjustment = ((tecMap:get_height() - tecMap_back:get_width()) * .5)
    tecMap_back:move(0,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecMap:get_height() &lt; tecMap:get_width() then
  	tecMap_back:resize(tecMap:get_height(), tecMap:get_height())
    local centerAdjustment = ((tecMap:get_width() - tecMap_back:get_height()) * .5)
    tecMap_back:move(centerAdjustment,0) --Move the map to the center of the map box
	end --en if width is less than height.
	
  local exitWarningFontStyle = [[&lt;center&gt;&lt;p style="font-size:]]
    ..tecSettings.tecTabsFontSize..[[px; color:gray"&gt;]]
	echo(mapRoom[150].name,exitWarningFontStyle.."Map exits may be misaligned until you walk.")
  mapRoom[150]:resize(tecMap_back:get_width(), (tecMap:get_height() * .1))
  mapRoom[150]:setStyleSheet(labelsStyle)
  mapRoom[150]:move(0,0)
  mapRoom[150]:show()
  mapRoom[150]:raise()
	
end --end function keep square.

--set location for container in GUIframe.
--tecMap.GUIframeLocation = "bottomright"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecMap)

--tecMapdrawKeepSquare() --call it to size the map properly</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Parthia Map</name>
				<packageName></packageName>
				<script>local parthiaMapWindow = Geyser.Mapper:new({
  name = "parthia map",
  width = "100%", height = "100%",
  x = 0, y = 0
})

parthiaMapWindow.GUIframeLocation = "bottomright"

UIManagerRegisterWindow(parthiaMapWindow)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--Creates an interactive list of PC and NPCs in players current room.

roomCharacters = Geyser.Container:new({
  name = "Room Characters",    -- give it a unique name here
  x=0, y=0
})

--box that will store the miniconsoles
roomCharacters.back = Geyser.HBox:new({
  name = "roomCharacters.back",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},roomCharacters)

--This are the miniconsoles that will hold the text
roomCharacters.console = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.console", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.console:raise()

--This are the miniconsoles that will hold the text
roomCharacters.rightConsole = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.rightConsole", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.rightConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.rightConsole:raise()

function tecCRWindowResize()
	
	--Resize the back label by keeping it square.
	roomCharacters.back:resize(tostring(roomCharacters:get_width())
		, tostring(roomCharacters:get_height()))
	roomCharacters.back:move (0, 0) --left and top borders
	
	--Resize the back label by keeping it square.
	roomCharacters.console:resize(tostring(roomCharacters.back:get_width() - 0)
		, tostring(roomCharacters.back:get_height() - 0))
	roomCharacters.console:move (0, 0) --left and top borders
  tecScrollBarCheck("roomCharacters.console") --check if a scroll bar is needed.
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." roomCharacters.back width: "..roomCharacters.back:get_width()
			.." roomCharacters.back Height: "..roomCharacters.back:get_height()
			.." roomCharacters.console Width: "..roomCharacters.console:get_width()
			.." roomCharacters.console Height: "..roomCharacters.console:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecCRWindowResize()

--set location for container in GUIframe.
roomCharacters.GUIframeLocation = "topright"
--add cobntainer to UI manager.
UIManagerRegisterWindow(roomCharacters)

--tecCRWindowResize() --resize the Room Character window now
--tecResetRoomCharacterWindow() --fill room characters window with text</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Communications Menu</name>
				<packageName></packageName>
				<script>--Communications windows at the top of the screen.

--ideas for future
--When click a tab is stays dark to show that is the active tab.
--fix the minor resizing issue with the back label not having a right margin.
--take tabs out of that damn tecComWindows table
--create the option for a combat bar. Only shows combat text...

--Origional menu from the tabs tutorial.
--Only kept it because using a lone table caused issues.
--Feelfree to take the tabs table out of the menu table.
--For me it is a logic not I just didn't feel like unting.
--menu has to be global.
tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
tecComWindows.current = tecComWindows.current or tecComWindows.tabs[1]

--A container for everything to be in.
--No size or position because that is handled in UI manager
tecComWindows.container = Geyser.Container:new({
  name = "Communications",
})

--box that will hold the tabs
tecComWindows.header = Geyser.HBox:new({
  name = "tecComWindows.header",
  x = 0, --horizontal
	y = 0, --vertical position 
  width = "100%",
  height = tabsHeight, --for now using % rather than pixel math
},tecComWindows.container)

--box that will store the miniconsoles
tecComWindows.footer = Geyser.Label:new({
  name = "tecComWindows.footer",
  x = 0, --horizontal position
	y = tabsHeight, --adjusted for tabs
  width = "100%",
	height = tecSettings.comTextWindowHeight
},tecComWindows.container)
tecComWindows.footer:setStyleSheet(labelsStyle) --set to default label style

--Create the tabs
for k,v in pairs(tecComWindows.tabs) do
  tecComWindows[v.."tab"] = Geyser.Label:new({
    name = "tecComWindows."..v.."tab",
		x = 0, --horizontal position 
		y = 0, --vertical position
		width = "100%",
		height = tabsHeight,
  },tecComWindows.header)
	--tecComWindows[v.."tab"].styleSheet = tabsStyle
  tecComWindows[v.."tab"]:setStyleSheet(tabsStyle) --set style in themes
	tecComWindows[v.."tab"]:echo(tabsFontStyle..v) --lable the tabs, set style in themes
	tecComWindows[v.."tab"]:setClickCallback("tecComWindows.click",v) --for charing tabs
  tecComWindows[v.."tab"]:raise() --bring the tab above the background label.

	--These are the miniconsoles that will hold the text
  tecComWindows[v] = Geyser.MiniConsole:new({ --tecComWindows v will be a tab name.
    name = v, --Issues experienced if I attempt to name them v.."Console"
  	x = 0, --%horizontally position in parent
  	y = 0, --%vertical position in parent
  	width = "100%", --% of parent
  	height = tecSettings.comTextWindowHeight - 1, 
		autoWrap = true, --allows text to wrap if too long
		fontSize = getTECFont(), --in variables
		font = getFont(), --get font type from main
  },tecComWindows.footer) --attach to footer show they show below tabs
	tecComWindows[v]:setColor(getBgColor()) --set miniconsoles to main consol BG color 
  tecComWindows[v]:hide() --Hide the tab so they don't layer
  if tecSettings.showScrollBars then tecComWindows[v]:enableScrollBar() end
end --end loop create tabs and consoles

function tecComWindows.click(tab) --Choose what happens when a tab is clicked.
  tecComWindows[tecComWindows.current]:hide() --Hide the current tab
  tecComWindows.current = tab --Make the clicked tab the current one.
  tecComWindows[tecComWindows.current]:show() --Show the current tab.
end --end tecComWindows.click(tab) function

--A tecComWindows has to be selected otherwise on startup it will just show.
--The label behind the tecComWindows, becuase they are hidden directly after creation.
tecComWindows[tecComWindows.current]:show()

function tecComWindowResize()
  local tecResizedFooterHeight = 50
	local tecResizedFooterWidth = 300

  --if using GUIframe manager and it is initialized
  if GetUIManager() == "GUIframe" and GUIframe.initialized then  
	 --subtract GUIframe.defaults.resizeHeight from tecComWindows.footer.height 
	 tecResizedFooterHeight = tecComWindows.container:get_height() - GUIframe.defaults.resizeHeight
	 tecResizedFooterWidth = tecComWindows.container:get_width()
  else --UI manager not specified.
	 tecResizedFooterHeight = tecComWindows.container:get_height()
	 tecResizedFooterWidth = tecComWindows.container:get_width()
  end --if GetUIManager() == "GUIframe" and GUIframe.initialized
  
	tecComWindows.footer:resize(tecResizedFooterWidth, tecResizedFooterHeight) --resize the footer
	tecComWindows.footer:move(0,(tabsHeight))
	
	--reflect changes in tecSettings so there is a chance to save the size.
	tecSettings.comTextWindowHeight = tecResizedFooterHeight
	
	--resize all of the miniconsoles
	for k,v in pairs(tecComWindows.tabs) do 
  	tecComWindows[v]:move(0, 0)
  	tecComWindows[v]:resize(tecResizedFooterWidth, tecResizedFooterHeight - 1)
	end --for tecComWindows.tabs
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Communication Window, tecComWindows.footer Height: "..tecComWindows.footer:get_height()
			.." tecComWindows.ctainer Height: "..tecComWindows.container:get_height()
			.." New tecComWindows.footer Height: "..tecResizedFooterHeight
			.." mini consoles width: "..(tecResizedFooterWidth - 0).."%"
			)--end debugToDisplay
	end --end if display debug is enabled.

end --resizeKeepTabsStatis

--tecComWindowResize() --resize com window

--set location for container in GUIframe.
tecComWindows.container.GUIframeLocation = "top"
--add cobntainer to UI manager.
UIManagerRegisterWindow(tecComWindows.container)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Macro Menu</name>
				<packageName></packageName>
				<script>--create the window that holds the macros.
macroMenu = macroMenu or {} --table to hold the windows variables
macroMenu.window = Geyser.Container:new({ name = "Macros", })
macroMenu.back = Geyser.Label:new({ --Create a label that could be used as a background
  name = "macroMenu.back",
  x = 0,y = 0, width = "100%", height = "100%" --Position and size of window
  }, macroMenu.window) --end of macroMenu.back
macroMenu.back.styleSheet = [[border-image: url("]]..tecSettings.images["macroBackground"].image..[[");]]
macroMenu.back:setStyleSheet(macroMenu.back.styleSheet)
macroMenu.box = Geyser.VBox:new({ --creates the verticle window breaks
  name = "macroMenu.box",
  x = 0, y = 0, width = "100%", height = "100%"
  }, macroMenu.back) --end macroMenu.box
--Create the five rows of buttons
macroMenu.row1 = Geyser.HBox:new({
  name = "macroMenu.row1",
  }, macroMenu.box)
macroMenu.row2 = Geyser.HBox:new({
  name = "macroMenu.row2",
  },macroMenu.box)
macroMenu.row3 = Geyser.HBox:new({
  name = "macroMenu.row3",
  }, macroMenu.box)
macroMenu.row4 = Geyser.HBox:new({
  name = "macroMenu.row4",
  }, macroMenu.box)
macroMenu.row5 = Geyser.HBox:new({
  name = "macroMenu.row5",
  }, macroMenu.box)
  
--create table to hold data for macro buttons.
local tecMacroMappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = macroMenu.row1, --the geyser box we want this label to go in
  },
  { name = "fe2", label = "II", row = macroMenu.row1, },
  { name = "fe3", label = "III", row = macroMenu.row1, },
  { name = "fe4", label = "IV", row = macroMenu.row2, },
  { name = "fe5", label = "V", row = macroMenu.row2, },
  { name = "fe6", label = "VI", row = macroMenu.row2, },
  { name = "fe7", label = "VII", row = macroMenu.row3, },
  { name = "fe8", label = "VIII", row = macroMenu.row3, },
  { name = "fe9", label = "IX", row = macroMenu.row3, },
  { name = "fe10", label = "X", row = macroMenu.row4, },
  { name = "fe11", label = "XI", row = macroMenu.row4, },
  { name = "fe12", label = "XII", row = macroMenu.row4, },
  { name = "fe13", label = "XIII", row = macroMenu.row5, },
  { name = "fe14", label = "XIV", row = macroMenu.row5, },
  { name = "fe15", label = "XV", row = macroMenu.row5, },
} --tecMacroMappings table
--add onto standard label. We want a small margin for this label.								
--macroLabelStyle = labelsStyle.."margin: 1px\n"; 537dC0
macroLabelStyle = [[
  	QLabel{
  		background-color: "#55537dC0";
      border-bottom: 1px;
      border-right: 1px;
      border-style: outset;
      border-color: lightgray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  	QLabel::hover{
  		background-color: "#33436db0";
      border-bottom: 1px;
      border-right: 1px;
      border-style: outset;
      border-color: gray;
      margin-right: 0px;
      margin-left: 0px;
  		font-size: 20px;
      qproperty-alignment: 'AlignCenter | AlignCenter';
    }
  ]]
for _, tecMacroMap in pairs(tecMacroMappings) do --loop trough mappings table using data within
  macroMenu[tecMacroMap.name] = Geyser.Label:new({
    name = "macroMenu." .. tecMacroMap.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. tecMacroMap.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, tecMacroMap.row) --parent is gettings passed via mapping table row reference
  local localMacroTooltip = "run macro "..tecMacroMap.name:match("(%d%d?)$").."  "
  SetTooltip(macroMenu[tecMacroMap.name].name, localMacroTooltip) --create hover tooltip
  macroMenu[tecMacroMap.name]:setClickCallback("onMacroClick", tecMacroMap.name)
  macroMenu[tecMacroMap.name].styleSheet = macroLabelStyle
  macroMenu[tecMacroMap.name]:setStyleSheet(macroLabelStyle)
end --for pairs(tecMacroMappings)
function onMacroClick(name) send(name, false) end --Create a click callback function

--set location for container in GUIframe.
macroMenu.window.GUIframeLocation = "bottomleft"
UIManagerRegisterWindow(macroMenu.window)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>multiWindow</name>
				<packageName></packageName>
				<script>MultiWindow = multiWindow or {}

MultiWindow.back = Geyser.VBox:new({ name = "Multi Window", }) --Horizonal box to hold our multiwindows.
MultiWindow.back.GUIframeLocation = "topright" --set location for container in GUIframe.

--MultiWindow.top = Geyser.VBox:new({ name = "MultiWindow.top", }, MultiWindow.back) --Vertical window break for the room characters windows

--Create a window that is a copy of the Room Characters window.
MultiWindow.roomCharacters = MultiWindow.roomCharacters or {} --create a table to hold roomCharters window
MultiWindow.roomCharacters.back = Geyser.HBox:new({
  name = "MultiWindow Room Characters",
  }, MultiWindow.back)
--MultiWindow.roomCharacters.back:setStyleSheet(labelsStyle) --set label for background
MultiWindow.roomCharacters.console = Geyser.MiniConsole:new({ --Create the mini console that will hold the text.
  name = "MultiWindow.roomCharacters.console",
	x = 0, y = 0, width = "100%", height = "100%", --position and size of console
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},MultiWindow.roomCharacters.back)
MultiWindow.roomCharacters.console:raise()
MultiWindow.roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
MultiWindow.roomCharacters.rightConsole = Geyser.MiniConsole:new({ --Create the mini console that will hold the text.
  name = "MultiWindow.roomCharacters.rightConsole",
	x = 0, y = 0, width = "100%", height = "100%", --position and size of console
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},MultiWindow.roomCharacters.back)
MultiWindow.roomCharacters.rightConsole:raise()
MultiWindow.roomCharacters.rightConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color

--create the window that holds the macros.
MultiWindow.macroMenu = MultiWindow.macroMenu or {} --table to hold the windows variables
MultiWindow.macroMenu.container = Geyser.Container:new({ name = "MultiWindow.Macros", }, MultiWindow.back)
MultiWindow.macroMenu.back = Geyser.Label:new({ --Create a label that could be used as a background
  name = "MultiWindow.macroMenu.back",
  x = 0,y = 0, width = "100%", height = "100%" --Position and size of window
  }, MultiWindow.macroMenu.container) --end of MultiWindow.macroMenu.back
MultiWindow.macroMenu.back.styleSheet = [[border-image: url("]]..tecSettings.images["macroBackground"].image..[[");]]
MultiWindow.macroMenu.back:setStyleSheet(MultiWindow.macroMenu.back.styleSheet)
MultiWindow.macroMenu.box = Geyser.VBox:new({ --creates the verticle window breaks
  name = "MultiWindow.macroMenu.box",
  x = 0, y = 0, width = "100%", height = "100%"
  }, MultiWindow.macroMenu.back) --end MultiWindow.macroMenu.box
--Create the five rows of buttons
MultiWindow.macroMenu.row1 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row1",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row2 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row2",
  },MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row3 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row3",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row4 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row4",
  }, MultiWindow.macroMenu.box)
MultiWindow.macroMenu.row5 = Geyser.HBox:new({
  name = "MultiWindow.macroMenu.row5",
  }, MultiWindow.macroMenu.box)
--create table to hold data for macro buttons.
local tecMacroMappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = MultiWindow.macroMenu.row1, --the geyser box we want this label to go in
  },
  { name = "fe2", label = "II", row = MultiWindow.macroMenu.row1, },
  { name = "fe3", label = "III", row = MultiWindow.macroMenu.row1, },
  { name = "fe4", label = "IV", row = MultiWindow.macroMenu.row2, },
  { name = "fe5", label = "V", row = MultiWindow.macroMenu.row2, },
  { name = "fe6", label = "VI", row = MultiWindow.macroMenu.row2, },
  { name = "fe7", label = "VII", row = MultiWindow.macroMenu.row3, },
  { name = "fe8", label = "VIII", row = MultiWindow.macroMenu.row3, },
  { name = "fe9", label = "IX", row = MultiWindow.macroMenu.row3, },
  { name = "fe10", label = "X", row = MultiWindow.macroMenu.row4, },
  { name = "fe11", label = "XI", row = MultiWindow.macroMenu.row4, },
  { name = "fe12", label = "XII", row = MultiWindow.macroMenu.row4, },
  { name = "fe13", label = "XIII", row = MultiWindow.macroMenu.row5, },
  { name = "fe14", label = "XIV", row = MultiWindow.macroMenu.row5, },
  { name = "fe15", label = "XV", row = MultiWindow.macroMenu.row5, },
} --tecMacroMappings table
--macroLabelStyle = labelsStyle --make a standard label for
for _, tecMacroMap in pairs(tecMacroMappings) do --loop trough mappings table using data within
  MultiWindow.macroMenu[tecMacroMap.name] = Geyser.Label:new({
    name = "MultiWindow.macroMenu." .. tecMacroMap.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. tecMacroMap.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, tecMacroMap.row) --parent is gettings passed via mapping table row reference
  local localMacroTooltip = "run macro "..tecMacroMap.name:match("(%d%d?)$").."  "
  SetTooltip(MultiWindow.macroMenu[tecMacroMap.name].name, localMacroTooltip) --create hover tooltip
  MultiWindow.macroMenu[tecMacroMap.name]:setClickCallback("onMacroClick", tecMacroMap.name)
  MultiWindow.macroMenu[tecMacroMap.name].styleSheet = macroLabelStyle
  MultiWindow.macroMenu[tecMacroMap.name]:setStyleSheet(macroLabelStyle)
end --for pairs(tecMacroMappings)
function onMacroClick(name) send(name, false) end --Create a click callback function

--used to hold compass and the status bars aside eachother at the bottom of the multiwindow
--MultiWindow.bottom = Geyser.HBox:new({ name = "MultiWindow.Bottom", }, MultiWindow.back) --Vertical window break for the bottom of the window
MultiWindow.bottom = Geyser.Container:new({ name = "MultiWindow.Bottom", }, MultiWindow.back) --Vertical window break for the bottom of the window

--Create the compass in the MultiWindow
MultiWindow.Compass = MultiWindow.Compass or { --table to hold compass
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"}, --directions for the compass
  } --end MultiWindow.Compass object declaration
MultiWindow.Compass.window = Geyser.Container:new({ --container for compass
  name = "Multi Compass",
  x=0, y=0, width = "50%", height="100%", --position and size of container
  },MultiWindow.bottom) --put the window in the HBox at the bottom of the MultiWindow
MultiWindow.Compass.back = Geyser.Label:new({
  name = "MultiWindow.Compass.back",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },MultiWindow.Compass.window) --put the label into the Compass container
--MultiWindow.Compass.back.styleSheet = getMudletHomeDir().. [[/imgs/backgrounds/old canvas.jpg]]
MultiWindow.Compass.back.styleSheet = [[border-image: url("]]..tecSettings.images["compassBackground"].image..[[");]]
MultiWindow.Compass.back:setStyleSheet(MultiWindow.Compass.back.styleSheet) --set the background label
--MultiWindow.Compass.back:setStyleSheet(labelsStyle) --set the background label
MultiWindow.Compass.overlay = Geyser.Label:new({
  name = "MultiWindow.Compass.overlay",
  x = "0%", y = "0%", width = "100%", height = "100%", --position and size of background
  },MultiWindow.Compass.back) --put the label into the Compass container
MultiWindow.Compass.overlay.styleSheet = [[border-image: url("]]..tecSettings.images["compassOverlay"].image..[[");]]
MultiWindow.Compass.overlay:setStyleSheet(MultiWindow.Compass.overlay.styleSheet) --set the background label
--MultiWindow.Compass.overlay:raise()
MultiWindow.Compass.hbox = Geyser.HBox:new({ --container to make columns
    name = "MultiWindow.Compass.box",
    x = 0, y = 0, width = "100%", height = "100%", --position and size of container
  },MultiWindow.Compass.back) --parent of this Hbox
--create three rows of the compass
MultiWindow.Compass.row1 = Geyser.VBox:new({name = "MultiWindow.Compass.row1",},MultiWindow.Compass.hbox)
MultiWindow.Compass.row2 = Geyser.VBox:new({name = "MultiWindow.Compass.row2",},MultiWindow.Compass.hbox)
MultiWindow.Compass.row3 = Geyser.VBox:new({name = "MultiWindow.Compass.row3",},MultiWindow.Compass.hbox)
--Create labels for the compass
MultiWindow.Compass.nw = Geyser.Label:new({ name = "MultiWindow.Compass.nw", },MultiWindow.Compass.row1)
MultiWindow.Compass.w = Geyser.Label:new({ name = "MultiWindow.Compass.w", },MultiWindow.Compass.row1)
MultiWindow.Compass.sw = Geyser.Label:new({ name = "MultiWindow.Compass.sw", },MultiWindow.Compass.row1)
MultiWindow.Compass.n = Geyser.Label:new({ name = "MultiWindow.Compass.n", },MultiWindow.Compass.row2)
MultiWindow.Compass.center = Geyser.VBox:new({ name = "MultiWindow.Compass.center", },MultiWindow.Compass.row2)
MultiWindow.Compass.up = Geyser.Label:new({ name = "MultiWindow.Compass.up", },MultiWindow.Compass.center)
MultiWindow.Compass.down = Geyser.Label:new({ name = "MultiWindow.Compass.down", },MultiWindow.Compass.center)
MultiWindow.Compass.s = Geyser.Label:new({ name = "MultiWindow.Compass.s", },MultiWindow.Compass.row2)
MultiWindow.Compass.ne = Geyser.Label:new({ name = "MultiWindow.Compass.ne", },MultiWindow.Compass.row3)
MultiWindow.Compass.e = Geyser.Label:new({ name = "MultiWindow.Compass.e", },MultiWindow.Compass.row3)
MultiWindow.Compass.se = Geyser.Label:new({ name = "MultiWindow.Compass.se", },MultiWindow.Compass.row3)
--function that occurs when a label above is clicked, 
--function MultiWindow.Compass.click(name) send(name) end --send the name of the
MultiWindow.Compass.click = tecCompass.click --send the name of the 
function MultiWindow.Compass.lit(name) --When a player can go in the direction, make the label an active image
  if name == "up" or name == "down" then --if it is overlay for up or down label
    MultiWindow.Compass[name]:setStyleSheet(tecCompass.styleSheetLitUpDown) --created a label with thick transparent border
  else --if it is a direction other than up or down.
    MultiWindow.Compass[name]:setStyleSheet([[background-color: "]]..tecSettings.compassDefaultHighlight..[[";]])
  end --if name == "up" or name == "down"
end --function MultiWindow.Compass.lit(name)
--when the space should be unlit change it back to white.
function MultiWindow.Compass.unlit(name) --When a player cannot go in the direction, make the label an active image
  MultiWindow.Compass[name]:setStyleSheet([[background-color: "#00000000";]])
end --function MultiWindow.Compass.unlit(name)
for _,v in pairs(MultiWindow.Compass.dirs) do --loop through dirs table
  SetTooltip(MultiWindow.Compass[v].name, "Go "..v.." ") --create hover tool tips
  MultiWindow.Compass[v]:setStyleSheet([[background-color: "#00000000";]]) --blank the compass directions
	MultiWindow.Compass[v]:setClickCallback("MultiWindow.Compass.click",v) --give each label an event to run the click function above.
end --end loop through MultiWindow.Compass.dirs

--create satus bar
MultiWindow.status_bar = Geyser.Container:new({
  name = "MultiWindow Status",    -- give it a unique name here
  x="50%", y=0, width = "50%", height="100%", --position and size of container
},MultiWindow.bottom)
MultiWindow.hpbar = Geyser.Gauge:new({ --create HP bar
  name="hpbar",
  x=0, y=0, width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.hpbar.front.styleSheet = hpbar.frontStyleSheet
MultiWindow.hpbar.front:setStyleSheet(MultiWindow.hpbar.front.styleSheet) --set the forground gradiant
MultiWindow.hpbar.back.styleSheet = hpbar.backStyleSheet
MultiWindow.hpbar.back:setStyleSheet(MultiWindow.hpbar.back.styleSheet) --set the background gradiant
MultiWindow.hpbar.text:setClickCallback("parthiaStatusClick","health") --collect stats and show health to screen
MultiWindow.hpbar:echo("Health","black","cb14") --put writing on bar
MultiWindow.hpbar:setValue(100,100) --set the starting fill of the bar
MultiWindow.fatiguebar = Geyser.Gauge:new({ --create fatigue bar
  name="MultiWindow fatiguebar",
  x=0, y="25%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.fatiguebar.front.styleSheet = fatiguebar.frontStyleSheet
MultiWindow.fatiguebar.front:setStyleSheet(MultiWindow.fatiguebar.front.styleSheet)
MultiWindow.fatiguebar.back.styleSheet = fatiguebar.backStyleSheet
MultiWindow.fatiguebar.back:setStyleSheet(MultiWindow.fatiguebar.back.styleSheet)
MultiWindow.fatiguebar.text:setClickCallback("parthiaStatusClick","fatigue") --collect stats and show fatigue to screen
MultiWindow.fatiguebar:echo("Fatigue","black","cb14") --put writing on bar
MultiWindow.fatiguebar:setValue(100,100) --set the starting fill of the bar
MultiWindow.hungerbar = Geyser.Gauge:new({ --create hunger bar
  name="MultiWindow hungerbar",
  x=0, y="50%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.hungerbar.front.styleSheet = hungerbar.frontStyleSheet
MultiWindow.hungerbar.front:setStyleSheet(MultiWindow.hungerbar.front.styleSheet)
MultiWindow.hungerbar.back.styleSheet = hungerbar.backStyleSheet
MultiWindow.hungerbar.back:setStyleSheet(MultiWindow.hungerbar.back.styleSheet)
MultiWindow.hungerbar.text:setClickCallback("parthiaStatusClick","hunger") --collect condition and show hunger to screen
MultiWindow.hungerbar:setValue(100,100)
MultiWindow.hungerbar:echo("Hunger","black","cb14") --put writing on bar
MultiWindow.encumbrancebar = Geyser.Gauge:new({ --make encumberance bar
  name="MultiWindow encumbrancebar",
  x=0, y="75%", width="100%", height="25%", --position and size of container
},MultiWindow.status_bar)
MultiWindow.encumbrancebar.front.styleSheet = encumbrancebar.frontStyleSheet
MultiWindow.encumbrancebar.front:setStyleSheet(MultiWindow.encumbrancebar.front.styleSheet)
MultiWindow.encumbrancebar.back.styleSheet = encumbrancebar.backStyleSheet
MultiWindow.encumbrancebar.back:setStyleSheet(MultiWindow.encumbrancebar.back.styleSheet)
MultiWindow.encumbrancebar.text:setClickCallback("parthiaStatusClick","encumbrance") --collect stats and show load to screen on click
MultiWindow.encumbrancebar:setValue(100,100)
MultiWindow.encumbrancebar:echo("Encumbrance","black","cb14") --put writing on bar

--redraw windows within MultiWindow so they fill spaces properly
function MultiWindow.redrawWindows()
  local localMultiWindowWidth = MultiWindow.back:get_width() --get width of entire multi window
  local localMultiWindowHeight = MultiWindow.back:get_height() --get width of entire multi window
  local localCompassWidth = MultiWindow.Compass.window:get_width() --get the width of the window
  local localCompassHeight = MultiWindow.Compass.window:get_height() --get the height of the window
  local localMultiWindowBottomHeight = MultiWindow.bottom:get_height() --get the height of the window
  MultiWindow.lastResizeWidth = MultiWindow.lastResizeWidth or 0 --used to detect when a resize is needed
  MultiWindow.lastResizeHeight = MultiWindow.lastResizeHeight or 0 --used to detect when a resize is needed
  displayDebug("function MultiWindow.redrawWindows,\n\t"
    .."CompassWidth "..localCompassWidth.." localCompassHeight "..localCompassHeight.." localMultiWindowBottomHeight "..localMultiWindowBottomHeight
    .."\n\tlocalMultiWindowWidth "..localMultiWindowWidth.." MultiWindow.lastResizeWidth "..MultiWindow.lastResizeWidth
    .."\n\tlocalMultiWindowHeight "..localMultiWindowHeight.." MultiWindow.lastResizeHeight "..MultiWindow.lastResizeHeight
    .."\n")
  --only run window resizing if it is needed.
  if  localMultiWindowWidth ~= MultiWindow.lastResizeWidth or  --if the multiWindow has changed size since last run
      localMultiWindowHeight ~= MultiWindow.lastResizeHeight or --if the multiWindow has changed size since last run
      localCompassWidth ~= localCompassHeight then --if the compass is not square
    localCompassHeight = localMultiWindowBottomHeight --Record the height of the bottom of the multi window to resize compass with
  	if localCompassWidth &lt; localCompassHeight then --if the compass width is less than the height of the bottom portion of the multiwindow
    	MultiWindow.Compass.window:resize(localCompassHeight, localCompassHeight) --make compass square, while widening it
      localCompassWidth = localCompassHeight --make the width variable the same as height, used to resize status bar.
  	elseif localCompassWidth &gt; localCompassHeight then --if the compass width is more than the height of the bottom portion of the multiwindow
    	MultiWindow.Compass.window:resize(localCompassHeight, localCompassHeight) --make compass square, while widening it
      localCompassWidth = localCompassHeight --make the width variable the same as height, used to resize status bar.
  	end --if elseif window is not square
    MultiWindow.status_bar:move(localCompassWidth) --move the status bar past the compass
    MultiWindow.status_bar:resize(localMultiWindowWidth - localCompassWidth) --changed the width to fill space to the right of the compass
    resizeLabelText(MultiWindow.encumbrancebar, 14, "black", "cb") --resize text according to label's height
    resizeLabelText(MultiWindow.hungerbar, 14, "black", "cb") --resize text according to label's height
    resizeLabelText(MultiWindow.fatiguebar, 14, "black", "cb") --resize text according to label's height
    resizeLabelText(MultiWindow.hpbar, 14, "black", "cb") --resize text according to label's height
    MultiWindow.lastResizeWidth = localMultiWindowWidth --record the current width, to only run resizing when needed
    MultiWindow.lastResizeHeight = localMultiWindowHeight --record the current height, to only run resizing when needed
    displayDebug("Multi window resize run.\n")
  end --if not localMultiWindowWidth == MultiWindow.lastResizeWidth or not localMultiWindowHeight == MultiWindow.lastResizeHeight
end --end function keep square.

UIManagerRegisterWindow(MultiWindow.back) --send the window to the UI Manager</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Events</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>guiChange()</name>
				<packageName></packageName>
				<script>--calls events that are needed when a window change occurs.
--Do NOT put any function that changes the GUI here!!!

--I am suspicious that calling multiple functions in one event is a no no
--I did this though because creating multiple AnonymousEvents caused issues.
--If I Recall the last event would not occur.

function guiChange()
	setMainWindowAutoWrap() --adjusts word wrap for main window.
	if getTECDisplayDebugMode() then geyserDebug() end --if displaydebug is on
  --only resize windows managed by UIManager if they are enabled
	if UIManagerSettings[tecCompass.window.name] then --if window exists chek if it is enabled
    if not UIManagerSettings[tecCompass.window.name].disabled then tecCompass.drawKeepSquare() end --Keep the windowed compass square
  end --if UIManagerSettings[tecCompass.window.name]
  if UIManagerSettings[MultiWindow.back.name] then --if window exists chek if it is enabled
    if not UIManagerSettings[MultiWindow.back.name].disabled then MultiWindow.redrawWindows() end--keep the compass in the multi window square
  end --if UIManagerSettings[MultiWindow.back.name]
  if UIManagerSettings[tecMap.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecMap.name].disabled then tecMapdrawKeepSquare() end --resize map
  end --if UIManagerSettings[tecMap.name]
  if UIManagerSettings[tecComWindows.container.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecComWindows.container.name].disabled then tecComWindowResize() end --resize commmunications window
  end --if UIManagerSettings[tecComWindows.container.name]
  if UIManagerSettings[tecSettingsBar.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[tecSettingsBar.name].disabled then tecSettingsWindowResize() end--resize the Room Character window now
  end --if UIManagerSettings[tecSettingsBar.name]
  if UIManagerSettings[status_bar.name] then --if window exists chek if it is enabled
	 if not UIManagerSettings[status_bar.name].disabled then resizeStatusWindow() end--resize the status bar window
  end --if UIManagerSettings[status_bar]
end --end function guiChange

--whenever event sysWindowReizeEvent occurs run setMainWindowAutowrap.
--In otherwords when any window geyser or main is CHANGED, run setMainWindowAutoWrap.
--That is NOT just resizing.
registerAnonymousEventHandler("sysWindowResizeEvent", "guiChange")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>authenticationInput(_, command)</name>
				<packageName></packageName>
				<script>--[[
https://wiki.mudlet.org/w/Manual:Event_Engine#sysDataSendRequest
Loin process is:
TEC sends line "Login: " mudlet trigger "Login" remove the Login: line from screen then sends the Zealous handshake to TEC
TEC then sends line "SECRET NONE" we capure this with trigger "SECRET Triger" that trigger prompts the user for their username.
  It registers function authenticationInput(_, command) in the scripts section group Events as a sysDataSendRequest event
  Trigger also sets bool tecUsernameEntry to true so the authenticationInput function nows it will receive a username
  If the user entered their user name at mudlet's connect screen it will automatically be captured by authenticationInput as the username.
When authenticationInput receives a user name it sets tecUsernameEntry to false, tecPasswordEntry and prompts the user for their password.
  If the user entered their password at mudlet's connection screen it will automatically be captured by this event.
  After reciving a password the function authenticationInput sends the ID and password to a TEC server requesting an authorization key.
  This request is done with a http post, header "Cookie" variable "biscuit=test". Over a secure ssl or tls https connection. Currently using a shell call that uses cURL.
  If the username or password is incorrect authenticationInput restarts the login process. Requiring the user to enter ID and password at mudlet's command prompt.
  When a good key is received that key is sent inplace of the password over the unsecure telnet connection encrypted as a md5 hash.
  When a successful login occurs the sysDataSendRequest event that registered authenticationIput is unregistered.
]]--
function authenticationInput(_, userInput) 
  
  if tecUsernameEntry then --If we need to acept user name from command line
    tecUsernameEntry = false --Make certain we do not liste for username again.
    tecPasswordEntry = true --we know the next command needs to be the password.
    denyCurrentSend() --Deny the origional command, in this case the password.
    tecUsername = userInput --the first item
    pecho("\nPlease enter your password.\n")
    clearCmdLine() --clear the text user entered from command line
  
  elseif tecPasswordEntry then --if password entry is set, we expect a password.
  	tecPasswordEntry = false --set this if check to false to it doesn't occur every input.
    local tecPassword = userInput --copy argument 2 to local variable
    userInput = nil --make certain this variable has been removed. It contains player password and is no longer needed.
    
    --clear the password off the screen.
    local tecMainLastLine = (getLastLineNumber("main") - 1)
    moveCursor(1,tecMainLastLine) --Move cursor to second from the newest line in main console
    selectString(tecPassword,1) --Select the password in main.
    replace("") --Replaced the selected password with.
    deselect() --Don't forget your deselects!
    pecho("Sending login request to The Eternal City.\n"
          .."A black command window will appear which sends the request.\n")
    
    local cURLCommand = "curl" --command to run cURL
  
    if getOS() == "windows" then --if the OS is windows built in curl will not work
        if not io.exists(windowsCurlFile, true) then --if curl.exe is missing windowsCurlFile declared in tecClientReset()
          if downloadcURLEventID then --A dowload for cURL was started but has not completed
          else --a download has not been started, start one now.
            downloadcURL(true) --download cURL and reconnect once it has completed
          end --if downloadcURLEventID
        end --if not io.exists(winCurl)
        cURLCommand = [[echo Sending encrypted authentication request to TEC. Please wait for an authentication key. &amp; "]]..windowsCurlFile..[["]]
    end --if getOS() == "windows"
    
    --download autherization cookie
    local cookieFile = tecSettingsFolder.."Auth Key.html" --directory and file name of authentication cookie
    if io.exists(cookieFile) then --if an old authentication cookie exists
      debugToDisplay("function authenticationInput, found cookie file at the start of login, attempting to delete.")
      os.remove(cookieFile) --remove the authentication cookie
    end --if io.exists(cookieFile)
    cURLCommand = cURLCommand..[[ -X POST https://login.eternalcitygame.com/login.php -b biscuit=test -c "]]..cookieFile..[[" -d "submit=true&amp;uname=]]..tecUsername:lower()..[[&amp;pwd=]]..tecPassword..[["]]
    tecPassword = nil --remove the password it is not longer needed
    --if debug message for cURLCommand added, remove password first
    
    os.execute (cURLCommand) --execute the curl command
    cURLCommand = nil --this variable has a copy of the password and is no longer needed
    
    --Use the data in the cookie to login
    if io.exists(cookieFile) then --if the cookie file exists
      debugToDisplay("function authenticationInput, cookie file found. Attempting login.")
      local authKey, errorFound = parthiaFileToString(cookieFile, true) --convert the downloaded authentication cookie to a string, delete the file when done
      if errorFound then --something went wrong. Attempt again.
        if io.exists(cookieFile) then --if the cookie file exists.
          debugToDisplay("function authenticationInput, failure converting cookie file to string. Requesting new cookie.")
          os.remove(cookieFile) --delete the cookie file.
        end --if errorFound then
          authKey, errorFound = parthiaFileToString(cookieFile, true) --convert the downloaded authentication cookie to a string, delete the file when done
        if errorFound then --failed to convert the authentication cookie file to a string
          tecErrorNotification("function authenticationInput found error attempting to convert autherization key to a data string. Error Found: "..errorFound)
        end --if errorFound --second attempt
      end --if errorFound
      authKey = authKey:match("pass%s+(%d+)") --find the key at the end of the cookie authentication file.
      debugToDisplay("function authenticationInput, sending login request. tecUsername:lower(): "..tecUsername:lower().." authKey: "..authKey)
      --Log into the game. md5.sumhexa converts user ID and TEC provided authentication key to md5 hash.
      sendAll("USER " .. tecUsername:lower() .. "\n", "SECRET NONE", "HASH ".. md5.sumhexa(tecUsername:lower() .. authKey .. "NONE") .. "\n", false)
      clearCmdLine() --clear password from command input bar.
    else --if the cookie file does not exist.
      pecho("Username or password incorrect. Please attempt again.\n")
      cecho("Create an ID or test login at ")
      cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;https://login.eternalcitygame.com/login.php", 
      [[openUrl("https://login.eternalcitygame.com/login.php")]], 
      "Create user ID for TEC", true)
      cecho("\nPlease enter your username.\n")
      clearCmdLine() --clear the text user entered from command line
      tecUsernameEntry = true --Listen for user name from next input
    end --if io.exists(cookieFile)
    
    denyCurrentSend() --Deny the origional command, in this case the password. this needs to 
    
	end --tecPasswordEntry
end --function tecPasswordPrompt</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tecExitHandler()</name>
				<packageName></packageName>
				<script>--runs when mudlet profile closes.
function tecExitHandler()
  send("logout") --Forces a complete logout of TEC
end --function tecExitHandler

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysExitEvent
registerAnonymousEventHandler("sysExitEvent", "tecExitHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Post Initilization</name>
				<packageName></packageName>
				<script>--[[
functions that need to be called for setup after all scripts have initialized.
]]--

--set proper state for numpad navigation
setNumpadNavigation(getNumpadNavigation)

--set tts to players preferences
if getParthiaTalk() then
  parthiaTalkSetVoice(parthiaTalkGetVoice(), false) --set voice
  parthiaTalkSetSpeed(parthiaTalkGetSpeed(), false) --set talking speed
  parthiaTalkSetPitch(parthiaTalkGetPitch(), false) --set pitch voice speaks in
  ttsSpeak(" ") --Start the queue after startup
end
--if getParthiaTalk() then ttsClearQueue() end

if getHelpDevs() then --if player has Help Developers enabled
  loadHelpDevs(true) --load data saved from Help Developers
end --if getHelpDevs()

parthiaMap.config() --load default settings for mapping system
parthiaMap.load() --load mapping data from file.

</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>UIManager</name>
					<packageName></packageName>
					<script>UIManagerFileLoad(true) --load display settings from file.
UIManagerSetTheme("PlayersTheme", false) --load windows into display
tecRefreshSettingsWindow() --Refreshes text in settings window.
tecResetRoomCharacterWindow() --fill room characters window with text

--Enable or disable scroll bars. Dependant on user preference.
tecSetScrollBars(tecSettings.showScrollBars, false)</script>
					<eventHandlerList />
				</Script>
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
