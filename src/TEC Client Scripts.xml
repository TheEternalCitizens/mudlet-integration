<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Variables Data Themese</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--[[
Used for creating variables that should be global.
Anything in the tecSettings table WILL be saved from file.
Meaning it WILL be loaded from file on a load.
]]--

function tecClientReset(displayToScreen) --reset all client settings to defaults
  --Creating a table that will be used to easily save these
  --Variables to file. So NOT putting tec.Settings. before
  --a variable will mean that it does not get saved to file.
  tecSettings = {}
  
  --set primary text color in game
  --needs to be a hex number WITH # before it.
  --If the back ground is dark this will AUTOMATICALLY be changed
  --in the text filter trigger.
  tecSettings.tecTextColor = "#c0c0c0"
  
  --Changes colors because defaults have too much contrast.
  tecSettings.GreenTextColor = "#77dd77"
  tecSettings.BlueTextColor = "#8888ff"
  tecSettings.PurpleTextColor = "#cca9dd"
  
  --background color for labels.
  tecSettings.labelBackgroundColor = "#537dC0"
  
  --background color for tabs.
  tecSettings.tabsBackgroundColor = "#436db0"
  
  --Color of label backgrounds and tabs as mouse hovers over them.
  tecSettings.hoverColor = "#5e8eff"
  
  --color that help text is highlighted in
  tecSettings.helpHighlightColor = "SteelBlue"
  
  --default font size. Do not save it to file.
  tecDefaultFontSize = 14
  
  --adjustable font size
  tecSettings.tecFontSize = 14
  
  --enable or disable debug mode.
  --Currently display red background main line to screen.
  --The code for this is at the bottom of
  --tec client triggers - text filters - text filters
  tecSettings.tecDebugMode = false
  
  --For gui messages debug, having all this put to screen when not needed muxs things up.
  tecSettings.tecDisplayDebugMode = false
  
  --for map debug messages.
  tecSettings.tecMapDebugMode = false
  
  --Height of the communications window text area.
  tecSettings.comTextWindowHeight = 100
  
  --This line is used to buffer the main line.
  --Than we filter this line in triggers - filter text 
  --It is important that this variable be global.
  --DO NOT SAVE THIS TO FILE
  filteredLine = "Reset filteredLine."
  
  --Zoom level of the map. 
  mapZoom = 1
  
  --used to keep track of characters in current room.
  	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
  
  --stores a command list for the room character window
  --Done this way so it can be customized. 
  tecSettings.commandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.commandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  tecSettings.approachedCommandList = { 
  	[[send "look ]],
  	[[send "guard ]],
  	[[send "follow ]],
  	[[send "target ]],
  	[[send "approach ]],
  	[[printCmdLine "say to ]] }
  tecSettings.approachedCommandHelp = {
  	"Look",
  	"Guard",
  	"Follow",
  	"Target",
  	"Approach",
  	"Talk" }
  	
  --Used to check if a room Character check is needed.
  doRoomCharacterCheck = false

  --used for if timer debug is or is not wanted.
  tecSettings.tecTimerDebugMode = false
  
  --Spaces inventory list 
  tecInventorySpacer = ""
  
  --use for functions that need to loop through all text windows 
  tecTextWindowNames = {"main", "tecSettingsConsole"
    ,"roomCharacters.console" , "Communication"
    ,"Thoughts", "Speech"}

	tecDebugSaveDir = getMudletHomeDir().."\/DebugingFiles\/"

	if displayToScreen then echo("Client settings set to default.\n") end

end --function tecClientReset()

tecClientReset(false) --Calling the function so these variables get created.</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--Functions that work directly with many variables that have nothing logically in common.
--For example they aren't all variables for display settings, all for font or debuging.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecFileSaveSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--Save client settings to file
function tecFileSaveSettings(displayToScreen)

--Idealy implimenting some kind of error checking would be great.
--Maybe making tecFileLoadSettings into a function that returns a table
--rather than loads the data into a global settings table

  --Save the table to file.
  table.save(getMudletHomeDir() .. "/TECClientData.lua", tecSettings)
	
	--display save to screen
	if displayToScreen then echo("Client settings saved.") end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecFileLoadSettings(displayToScreen)</name>
					<packageName></packageName>
					<script>--This perhaps should be in a sysLoadEvent

--This bugs on startup because it is calling debugToDisplay before it is declared.

--Loads variable and theme settings from file.
--Notify is boolean, to let the user know the event occured.
--In this case it is also a to screen notification that it was 
--successfull
function tecFileLoadSettings(displayToScreen)

	--Set the location and name of file.	
	local path = getMudletHomeDir() .. "/TECClientData.lua"
	path = path:gsub("\\","/")
	--If the file does not exist let the user know.
  if not io.exists(path) then 
		debugToDisplay("tecFileLoadSettings: save file doesn't exist.") --TEC debug screen
		debugc("tecFileLoadSettings: save file doesn't exist.") --mudlets debug screen
		echo("settings did not load from file\n")
	return --kill the function before real errors occur
	else
  table.load(path, tecSettings) --Load the settings in from file
	if displayToScreen then echo("Settings successfully loaded from file\n") end
	end --end if file exists else
end --function tecFileLoadSettings

--Call the function so data loads when mudlet starts.
tecFileLoadSettings(true)

--Now change some settings since data has been loaded
setFontSize(tecSettings.tecFontSize) --font size</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientSaveAll(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientSaveAll(displayToScreen)
  --Save client data to file.
  tecFileSaveSettings()
  if displayToScreen then echo("Client data saved to file.\n") end
  
  --saves the gui loadWindowLayout
  GUIframe.saveSettings()
  if displayToScreen then echo("Display settings saved to file.\n") end
end --function tecClientSaveAll</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--used to keep track of characters in current room.
function clearTECRoomObjects()
	tecRoomObjects = {characters = {}, checkActive = false, lc = 1}
end --fuctoin clearTecRoomObjects</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Themes</name>
				<packageName></packageName>
				<script>--People expressed interest in having themes.

--Important reference for themes
--https://doc.qt.io/qt-5.12/stylesheet-reference.html
--QT style sheets don't always act they was
--standard css does. Just buggy...

--lua showColors(3) shows a color chooser on screen.
--A good reference of colors, but when we offer color custimization to users, it can give them a 
--list to choose from.

--Upgrade options.
--add these variables to tecSettings so they can be saved and loaded.

--Font size for tab labels
tabsFontSize = 18

--Default tab height
tabsHeight = 30

--QLabels are QTs label system
--Used here for easy hover affects
tabsStyle = [[
	QLabel{
		background-color: ]]..tecSettings.tabsBackgroundColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: lightgray;
    border-top-left-radius: 15px;
    border-top-right-radius: 15px;
    margin-right: 1px;
    margin-left: 1px;
		font-size: 50px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
	QLabel::hover{
		background-color: ]]..tecSettings.hoverColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: gray;
    border-top-left-radius: 15px;
    border-top-right-radius: 15px;
    margin-right: 1px;
    margin-left: 1px;
		font-size: 50px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
]]

--This is now tabs text looks
tabsFontStyle = '&lt;center&gt;&lt;p style="font-size:18px; color:lightgray"&gt;'

labelsStyle = [[
	QLabel{
		background-color: ]]..tecSettings.labelBackgroundColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: lightgray;
    margin-right: 1px;
    margin-left: 1px;
		font-size: 50px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
	QLabel::hover{
		background-color: ]]..tecSettings.hoverColor..[[;
    border-width: 1px;
    border-style: outset;
    border-color: gray;
    margin-right: 1px;
    margin-left: 1px;
		font-size: 50px;
    qproperty-alignment: 'AlignCenter | AlignCenter';
  }
]]
								
buttonsStyle = [[QPushButton{
                		background-color: gray;
                    border-width: 1px;
                    border-style: outset;
                    border-color: lightgray;
                    border-top-left-radius: 15px;
                    border-top-right-radius: 15px;
										border-bottom-left-radius: 15px;
                    border-bottom-right-radius: 15px;
                    margin-right: 1px;
                    margin-left: 1px;
                		font-size: 50px;
                    qproperty-alignment: 'AlignCenter | AlignCenter';}
								 QPushButton::on{}
								 QPushButton::hover{}
]]					

--This is now tabs text looks
buttonsFontStyle = '&lt;center&gt;&lt;p style="font-size:18px; color:white"&gt;'

--Used to shape rooms on map. Intentionally left without a } at the end.
mapRoomStyle = [[
	QLabel{
	border-bottom-right-radius: 3;
	border-bottom-left-radius: 3;
	border-top-right-radius: 3;
	border-top-left-radius: 3;
	margin: 2px;
  qproperty-alignment: 'AlignCenter | AlignCenter';
]]

--Create a red style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleRed = mapRoomStyle..[[
	background-color: red;
  }
]]

--Create a Green style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleGreen = mapRoomStyle..[[
	background-color: green;
  }
]]

--Create a white style for creating map rooms
--Done by completing the intentially unfinished mapRoomStyle
mapRoomStyleWhite = mapRoomStyle..[[
	background-color: white;
  }
]]

mapStraitOpenExitStyle = [[
	QLabel{
	background-color: white;
	}
]]

mapStraitClosedExitStyle = [[
	QLabel{
	background-color: black;
	}
]]

--create table used for exits
tecExit = { "hor", "ver", "ne", "nw" }

--set the horizontal exit table
tecExit["hor"] = {"0", "1", width, height}
tecExit["hor"]["0"] = { tecExitStyleSheet = [[
	QLabel{
	background-color: black;
	}
]]
} --end tecExit["hor"][0] table declaration
tecExit["hor"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
tecExit["hor"].width = 10
tecExit["hor"].height = 3

--now set verticle table
tecExit["ver"] = {"0", "1", width, height}
tecExit["ver"]["0"] = { tecExitStyleSheet = [[
	QLabel{
	background-color: black;
	}
]]
} --end tecExit["ver"][0] table declaration
tecExit["ver"]["1"] = { tecExitStyleSheet = [[QLabel{background-color: white;}]]} 
tecExit["ver"].width = 3
tecExit["ver"].height = 10

--Use these to adjust nenw icons
local nenwExitIconSize = 10 --square size of icon

--now set ne table
tecExit["ne"] = {"0", "1", width, height}
tecExit["ne"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/ne_closed.png");]]}
tecExit["ne"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/ne_open.png");]]}
tecExit["ne"].width = nenwExitIconSize
tecExit["ne"].height = nenwExitIconSize

--now set nw table
tecExit["nw"] = {"0", "1", width, height}
tecExit["nw"]["0"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/nw_closed.png");]]}
tecExit["nw"]["1"] = { tecExitStyleSheet = [[border-image: url("]]..getMudletHomeDir()
	..[[/]].."imgs"..[[/]].."exits"..[[/nw_open.png");]]}
tecExit["nw"].width = nenwExitIconSize
tecExit["nw"].height = nenwExitIconSize</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>mudlet Communidy Functions</name>
			<packageName></packageName>
			<script>--[[
Space for mudlet functions the community makes that we need.
]]--</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TextFormatter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>standaloneFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.text = {}

function demonnic:wordWrap(str, limit, indent, indent1)
  -- pulled from http://lua-users.org/wiki/StringRecipes
  indent = indent or ""
  indent1 = indent1 or indent
  limit = limit or 72
  local here = 1-#indent1
  local function check(sp, st, word, fi)
    if fi - here &gt; limit then
      here = st - #indent
      return "\n"..indent..word
    end
  end
  return indent1..str:gsub("(%s+)()(%S+)()", check)
end

function demonnic:fText(str, opts)
  local options = demonnic:fixFormatOptions(str, opts)  
  if options.wrap and (options.strLen &gt; options.effWidth) then
    local wrapped = demonnic:wordWrap(str, options.effWidth)
    local lines = wrapped:split("\n")
    local formatted = {}
		options.fixed = false
    for _,line in ipairs(lines) do
      table.insert(formatted, demonnic:fLine(line, options))
    end
    return table.concat(formatted, "\n")
  else
    return demonnic:fLine(str, options)
  end
end

function demonnic:fixFormatOptions(str, opts)
  if opts.fixed then return table.deepcopy(opts) end
  --Set up all the things we might call the different echo types
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if opts == nil then opts = {} end -- don't overwrite options if they passed them
  --but if they passed something other than a table as the options than oopsie!
  if type(opts) ~= "table" then 
    error("Improper argument: options expected to be passed as table") 
  end
  --now we make a copy of the table, so we don't edit the original during all this
  local options = table.deepcopy(opts)
  if options.wrap == nil then options.wrap = true end --wrap by default.
  options.formatType = options.formatType or "" --by default, no color formatting.
  options.width = options.width or 80 --default 80 width
  options.cap = options.cap or "" --no cap by default
  options.spacer = options.spacer or " " --default spacer is the space character
  options.alignment = options.alignment or "center" --default alignment is centered
  if options.nogap == nil then options.nogap = false end
  if options.inside == nil then options.inside = false end --by default, we don't put the spacer inside
  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps
  --setup default options for colors based on the color formatting type
  if table.contains(dec, options.formatType) then
    options.capColor = options.capColor or "&lt;255,255,255&gt;"
    options.spacerColor = options.spacerColor or "&lt;255,255,255&gt;"
    options.textColor = options.textColor or "&lt;255,255,255&gt;"
    options.colorReset = "&lt;r&gt;"
    options.colorPattern = "&lt;%d+,%d+,%d+:?%d*,?%d*,?%d*&gt;"
  elseif table.contains(hex, options.formatType) then
    options.capColor = options.capColor or "#FFFFFF"
    options.spacerColor = options.spacerColor or "#FFFFFF"
    options.textColor = options.textColor or "#FFFFFF"
    options.colorReset = "#r"
    options.colorPattern = 'c|%d%d%d%d%d%d'
  elseif table.contains(col, options.formatType) then
    options.capColor = options.capColor or "&lt;white&gt;"
    options.spacerColor = options.spacerColor or "&lt;white&gt;"
    options.textColor = options.textColor or "&lt;white&gt;"
    options.colorReset = "&lt;reset&gt;"
    options.colorPattern = "&lt;%w*_?%w*:?%w*_?%w*&gt;"
  else
    options.capColor = ""
    options.spacerColor = ""
    options.textColor = ""
    options.colorReset = ""
    options.colorPattern = ""
  end
  options.originalString = str
  options.strippedString = string.gsub(tostring(str), options.colorPattern, "")
  options.strLen = string.len(options.strippedString)
  options.leftCap = options.cap
	options.rightCap = options.cap
  options.leftPadLen = math.floor((options.width - options.strLen)/2,1) - 1
  options.rightPadLen = options.leftPadLen + ((options.width - options.strLen)%2)
  options.maxPad = 0
  options.capLen = string.len(options.cap)
  local gapSpaces = 0
  if not options.nogap then
    if options.alignment == "center" then 
      gapSpaces = 2 
    else 
      gapSpaces = 1 
    end
  end
  options.effWidth = options.width - ((options.capLen * 2) + gapSpaces)
  if options.capLen &gt; options.leftPadLen then
    options.cap = options.cap:sub(1, leftPadLen)
    options.capLen = string.len(options.cap)
  end
  options.fixed = true
  return options
end

function demonnic:fLine(str,opts)
  local options = demonnic:fixFormatOptions(str,opts)
  local strippedString = options.strippedString
  local strLen = options.strLen
  local leftCap = options.leftCap
  local rightCap = options.rightCap
  local leftPadLen = options.leftPadLen
  local rightPadLen = options.rightPadLen
  local maxPad = options.maxPad
  local capLen = options.capLen

  if options.alignment == "center" then --we're going to center something
    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )
      rightCap = string.gsub(rightCap, "&lt;", "&gt;")
      rightCap = string.gsub(rightCap, "%[", "%]")
      rightCap = string.gsub(rightCap, "{", "}")
      rightCap = string.gsub(rightCap, "%(", "%)")
      rightCap = string.reverse(rightCap)
    end --otherwise, they'll be the same, so don't do anything
    if not options.nogap then str = string.format(" %s ", str) end
    
  elseif options.alignment == "right" then --we'll right-align the text
    leftPadLen = leftPadLen + rightPadLen
    rightPadLen = 0
    rightCap = ""
    if not options.nogap then str = string.format(" %s", str) end
    
  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.
    rightPadLen = rightPadLen + leftPadLen
    leftPadLen = 0
    leftCap = ""
    if not options.nogap then str = string.format("%s ", str) end
  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. 
  local fullLeftCap = string.format("%s%s%s", options.capColor, leftCap, options.colorReset)
  local fullLeftSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (leftPadLen - capLen)), options.colorReset)
  local fullText = string.format("%s%s%s", options.textColor, str, options.colorReset)
  local fullRightSpacer = string.format("%s%s%s", options.spacerColor, string.rep(options.spacer, (rightPadLen - capLen)), options.colorReset)
  local fullRightCap = string.format("%s%s%s", options.capColor, rightCap, options.colorReset)

  if options.inside then 
  -- "endcap===== some text =====endcap"
  -- "endcap===== some text =====pacdne" 
  -- "endcap================= some text" 
  -- "some text =================endcap"
    local finalString = string.format("%s%s%s%s%s", fullLeftCap, fullLeftSpacer, fullText, fullRightSpacer, fullRightCap)
    return finalString
  else 
  --"=====endcap some text endcap=====" 
  --"=====endcap some text pacdne====="
  --"=================endcap some text" 
  --"some text endcap================="

    local finalString = string.format("%s%s%s%s%s", fullLeftSpacer, fullLeftCap, fullText, fullRightCap, fullRightSpacer)
    return finalString
  end
end

function demonnic:align(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = ""
		options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:dalign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:calign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:halign(str, opts)
  local options = {}
  if opts == nil then
    opts = {}
  end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
    options.wrap = false
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fLine(str, options)
end

function demonnic:cfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "c"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:dfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "d"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:hfText(str, opts)
  local options = {}
  if opts == nil then opts = {} end
  if type(opts) == "table" then
    options = table.deepcopy(opts)
    options.formatType = "h"
  else
    error("Improper argument: options expected to be passed as table") 
  end
  options = demonnic:fixFormatOptions(str, options)
  return demonnic:fText(str, options)
end

function demonnic:test_ftext()
  local testString = "This is a test of the emergency broadcast system. This is only a test. If this had been a real emergency, we would have given you more sensible information after this. But this was only a test."
  
  local nTable = {width = 40, cap = "(CAP)", inside = true, alignment = 'center'}
  local cTable = table.deepcopy(nTable)
    cTable.formatType="c"
    cTable.capColor = "&lt;red:black&gt;"
    cTable.spacerColor = "&lt;purple:green&gt;"
    cTable.textColor = "&lt;purple:green&gt;"
  
  local dTable = table.deepcopy(nTable)
    dTable.formatType="d"
    dTable.capColor = "&lt;0,0,182&gt;"
    dTable.spacerColor = "&lt;0,182,0&gt;"
    dTable.textColor = "&lt;182,0,0&gt;"
  
  local hTable = table.deepcopy(nTable)
    hTable.formatType="h"
    hTable.capColor = "#FF0000"
    hTable.spacerColor = "#00FF00"
    hTable.textColor = "#0000FF"
  echo(string.rep("\n", 5))
  echo("With word wrap:\n")
  echo(demonnic:fText(testString, nTable) .. "\n")
  cecho(demonnic:fText(testString, cTable) .. "\n")
  decho(demonnic:fText(testString, dTable) .. "\n")
  hecho(demonnic:fText(testString, hTable) .. "\n")

  echo("\n\nWithout word wrap:\n")
  echo(demonnic:align(testString, nTable) .. "\n")
  decho(demonnic:dalign(testString, dTable) .. "\n")
  cecho(demonnic:calign(testString, cTable) .. "\n")
  hecho(demonnic:halign(testString, hTable) .. "\n")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>reusableFormatter</name>
					<packageName></packageName>
					<script>demonnic.TextFormatter = {}
demonnic.TextFormatter.validFormatTypes = { 'd', 'dec', 'decimal', 'h', 'hex', 'hexidecimal', 'c', 'color', 'colour', 'col', 'name'}


function demonnic.TextFormatter:setType(typeToSet)
  local isNotValid = not table.contains(self.validFormatTypes, typeToSet)
  if isNotValid then
    error("demonnic.TextFormatter:setType: Invalid argument, valid types are:" .. table.concat(self.validFormatTypes, ", "))
  end
  self.options.formatType = typeToSet
end

function demonnic.TextFormatter:toBoolean(thing)
  if type(thing) ~= "boolean" then
    if thing == "true" then
      thing = true
    elseif thing == "false" then
      thing = false
    else
      return nil
    end
  end
  return thing
end

function demonnic.TextFormatter:checkString(str)
  if type(str) ~= "string" then
    if tostring(str) then
      str = tostring(str)
    else
      return nil
    end
  end
  return str
end

function demonnic.TextFormatter:setWrap(shouldWrap)
  local argumentType = type(shouldWrap)
  shouldWrap = self:toBoolean(shouldWrap)
  if shouldWrap == nil then
    error("demonnic.TextFormatter:setWrap(shouldWrap) Argument error, boolean expected, got " .. argumentType .. ", if you want to set the number of characters wide to format for, use setWidth()")
  end
  self.options.wrap = shouldWrap
end

function demonnic.TextFormatter:setWidth(width)
  if type(width) ~= "number" then
    if tonumber(width) then
      width = tonumber(width)
    else
      error("demonnic.TextFormatter:setWidth(width): Argument error, number expected, got " .. type(width))
    end
  end
  self.options.width = width
end

function demonnic.TextFormatter:setCap(cap)
  local argumentType = type(cap)
  local cap = self:checkString(cap)
  if cap == nil then error("demonnic.TextFormatter:setCap(cap): Argument error, string expect, got " .. argumentType) end
  self.options.cap = cap
end

function demonnic.TextFormatter:setCapColor(capColor)
  local argumentType = type(capColor)
  local capColor = self:checkString(capColor)
  if capColor == nil then error("demonnic.TextFormatter:setCapColor(capColor): Argument error, string expected, got " .. argumentType) end
  self.options.capColor = capColor
end

function demonnic.TextFormatter:setSpacerColor(spacerColor)
  local argumentType = type(spacerColor)
  local spacerColor = self:checkString(spacerColor)
  if spacerColor == nil then error("demonnic.TextFormatter:setSpacerColor(spacerColor): Argument error, string expected, got " .. argumentType) end
  self.options.spacerColor = spacerColor
end

function demonnic.TextFormatter:setTextColor(textColor)
  local argumentType = type(textColor)
  local textColor = self:checkString(textColor)
  if textColor == nil then error("demonnic.TextFormatter:setTextColor(textColor): Argument error, string expected, got " .. argumentType) end
  self.options.textColor = textColor
end

function demonnic.TextFormatter:setSpacer(spacer)
  local argumentType = type(spacer)
  local spacer = self:checkString(spacer)
  if spacer == nil then error("demonnic.TextFormatter:setSpacer(spacer): Argument error, string expect, got " .. argumentType) end
  self.options.spacer = spacer
end

function demonnic.TextFormatter:setAlignment(alignment)
  local validAlignments = {
    "left",
    "right",
    "center"
  }
  if not table.contains(validAlignments, alignment) then
    error("demonnic.TextFormatter:setAlignment(alignment): Argument error: Only valid arguments for setAlignment are 'left', 'right', or 'center'. You sent" .. alignment)
  end
  self.options.alignment = alignment
end

function demonnic.TextFormatter:setInside(spacerInside)
  local argumentType = type(spacerInside)
  spacerInside = self:toBoolean(spacerInside)
  if spacerInside == nil then
    error("demonnic.TextFormatter:setInside(spacerInside) Argument error, boolean expected, got " .. argumentType)
  end
  self.options.inside = spacerInside
end

function demonnic.TextFormatter:setMirror(shouldMirror)
  local argumentType = type(shouldMirror)
  shouldMirror = self:toBoolean(shouldMirror)
  if shouldMirror == nil then
    error("demonnic.TextFormatter:setMirror(shouldMirror): Argument error, boolean expected, got " .. argumentType)
  end
  self.options.mirror = shouldMirror
end

function demonnic.TextFormatter:format(str)
  return demonnic:fText(str, self.options)
end

function demonnic.TextFormatter:new(options)
  if options == nil then options = {} end
  if options and type(options) ~= "table" then
    error("demonnic.TextFormatter:new(options): Argument error, table expected, got " .. type(options))
  end
  local me = {}
  me.options = {
    formatType = "c",
    wrap = true,
    width = 80,
    cap = "",
    spacer = " ",
    alignment = "center",
    inside = true,
    mirror = false,
  }
  for option, value in pairs(options) do
    me.options[option] = value
  end
  setmetatable(me, self)
  self.__index = self
  return me
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tableFormatter</name>
					<packageName></packageName>
					<script>demonnic = demonnic or {}
demonnic.TableMaker = {
  headCharacter = "*",
  footCharacter = "*",
  edgeCharacter = "*",
  rowSeparator = "-",
  separator = "|",

  colorReset = "&lt;reset&gt;",
  formatType = "c",
  printHeaders = true,
}

function demonnic.TableMaker:checkPosition(position, func)
  if position == nil then position = 0 end
  if type(position) ~= "number" then
    if tonumber(position) then
      position = tonumber(position)
    else
      error(func .. ": Argument error: position expected as number, got " .. type(position))
    end
  end
  return position
end

function demonnic.TableMaker:insert(tbl, pos, item)
  if pos ~= 0 then
    table.insert(tbl, pos, item)
  else
    table.insert(tbl, item)
  end
end

function demonnic.TableMaker:addColumn(options, position)
  if options == nil then options = {} end
  if not type(options) == "table" then error("demonnic.TableMaker:addColumn(options, position): Argument error: options expected as table, got " .. type(options)) end
  local options = table.deepcopy(options)
  position = self:checkPosition(position, "demonnic.TableMaker:addColumn(options, position)")
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self:insert(self.columns, position, formatter)
end

function demonnic.TableMaker:deleteColumn(position)
  if position == nil then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position)
  local maxColumn = #self.columns
  if position &gt; maxColumn then error("demonnic.TableMaker:deleteColumn(position): Argument Error: position provided was larger than number of columns in the table. Number of columns: " .. #self.columns) end
  table.remove(self.columns, position)
end

function demonnic.TableMaker:replaceColumn(options, position)
  if position == nil then
    error("demonnic.TableMaker:replaceColumn(options, position): Argument error: position as number expected, got nil")
  end
  position = self:checkPosition(position)
  if type(options) ~= "table" then error("demonnic.TableMaker:replaceColumn(options, position): Argument error: options as table expected, got " .. type(options)) end
  if #self.columns &lt; position then error("demonnic.TableMaker:replaceColumn(options, position): you cannot specify a position higher than the number of columns currently in the TableMaker. You sent:" .. position .. " and there are: " .. #self.columns .. "columns in the TableMaker") end
  options.width = options.width or 20
  options.name = options.name or ""
  local formatter = demonnic.TextFormatter:new(options)
  self.columns[position] = formatter
end

function demonnic.TableMaker:addRow(columnEntries, position)
  local columnEntriesType = type(columnEntries)
  if columnEntriesType ~= "table" then
    error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries expected as table, got " .. columnEntriesType)
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument Error, you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:addRow(columnEntries, position): Argument error, columnEntries items expected as string, got:" .. type(entry)) 
      end
    end
  end
  position = self:checkPosition(position, "demonnic.TableMaker:addRow(columnEntries, position)")
  self:insert(self.rows, position, columnEntries)
end

function demonnic.TableMaker:deleteRow(position)
  if position == nil then error("demonnic.TableMaker:deleteRow(position): Argument Error: position as number expected, got nil") end
  position = self:checkPosition(position, "demonnic.TableMaker:deleteRow(position)")
  local maxRow = #self.rows
  if position &gt; maxRow then error("demonnic.TableMaker:deleteRow(position): Argument Error: position given was &gt; the number of rows we have # of rows is:" .. maxRow) end
  table.remove(self.rows, position)
end

function demonnic.TableMaker:replaceRow(columnEntries, position)
  if position == nil then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): ArgumentError: position expected as number, received nil")
  end
  position = self:checkPosition(position, "demonnic.TableMaker:replaceRow(columnEntries, position)")
  if #self.rows &lt; position then
    error("demonnic.TableMaker:replaceRow(columnEntries, position): position cannot be greater than the number of rows already in the tablemaker. You provided: " .. position .. " and there are " .. #self.rows .. "rows in the TableMaker")
  end
  for _,entry in ipairs(columnEntries) do
    local entryCheck = self:checkEntry(entry)
    if entryCheck == 0 then
      if type(entry) == "function" then
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument Error: you provided a function for a columnEntry but it does not return a string. We need a string. It was entry number " .. _ .. "in columnEntries")
      else
        error("demonnic.TableMaker:replaceRow(columnEntries, position): Argument error: columnEntries items expected as string, got:" .. type(entry))
      end
    end
  end
  self.rows[position] = columnEntries
end

function demonnic.TableMaker:checkEntry(entry)
  if type(entry) ~= "string" then
    if type(entry) == "function" then
      local entryReturn = entry()
      if type(entryReturn) ~= string and not tostring(entryReturn) then entry = 0 end
    elseif not tostring(entry) then
      entry = 0
    end
  end
  return entry
end

function demonnic.TableMaker:checkNumber(num)
  if num == nil then num = 0 end
  if not tonumber(num) then num = 0 end
  return tonumber(num)
end

function demonnic.TableMaker:setCell(row, column, entry)
  local maxRow = #self.rows
  local maxColumn = #self.columns
  local ae = "demonnic.TableMaker:setCell(row, column, entry): Argument Error:"
  row = self:checkNumber(row)
  if row == 0 then error(ae .. " row must be a number, you provided " .. type(row)) end
  column = self:checkNumber(column)
  if column == 0 then error(ae .. " column must be a number, you provided " .. type(column)) end
  if row &gt; maxRow then error(ae .. " row is higher than the number of rows in the table. Highest row:" .. maxRow) end
  if column &gt; maxColumn then error(ae .. " column is higher than the number of columns in the table. Highest column:" .. maxColumn) end
  local entryType = type(entry)
  entry = self:checkEntry(entry)
  if entry == 0 then
    if type(entry) == "function" then 
      error(ae .. " entry was provided as a function, but does not return a string. We need a string in the end")
    else 
      error("demonnic.TableMaker:setCell(row, column, entry): Argument Error: entry must be a string, or a function which returns a string. You provided a " .. entryType)
    end
  end
  self.rows[row][column] = entry
end

function demonnic.TableMaker:totalWidth()
  local width = 0
  local numberOfColumns = #self.columns
  local separatorWidth = string.len(self.separator)
  local edgeWidth = string.len(self.edgeCharacter) * 2
  for _,column in ipairs(self.columns) do
    width = width + column.options.width
  end
  separatorWidth = separatorWidth * (numberOfColumns - 1)
  width = width + edgeWidth + separatorWidth
  return width
end

function demonnic.TableMaker:scanRow(rowToScan)
  local row = table.deepcopy(rowToScan)
  local rowEntries = #row
  local numberOfColumns = #self.columns
  local columns = {}
  local linesInRow = 0
  local rowText = ""
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset

  if rowEntries &lt; numberOfColumns then
    entriesNeeded = numberOfColumns - rowEntries
    for i = 1,entriesNeeded do
      table.insert(row, "")
    end
  end
  for index,formatter in ipairs(self.columns) do
    local str = row[index]
    local column = ""
    if type(str) == "function" then str = str() end
    column = formatter:format(str)
    table.insert(columns, column:split("\n"))
  end
  for _,rowLines in ipairs(columns) do
    if linesInRow &lt; #rowLines then linesInRow = #rowLines end
  end
  for index,rowLines in ipairs(columns) do
    if #rowLines &lt; linesInRow then
      local neededLines = linesInRow - #rowLines
      for i=1,neededLines do
        table.insert(rowLines, self.columns[index]:format(""))
      end
    end
  end
  for i= 1,linesInRow do
    local thisLine = ec
    for index,column in ipairs(columns) do
      if index == 1 then
        thisLine = string.format("%s%s", thisLine, column[i])
      else
        thisLine = string.format("%s%s%s", thisLine, sep, column[i])
      end
    end
    thisLine = string.format("%s%s", thisLine, ec)
    if rowText == "" then
      rowText = thisLine
    else
      rowText = string.format("%s\n%s", rowText, thisLine)
    end
  end
  return rowText
end

function demonnic.TableMaker:makeHeader()
  local totalWidth = self:totalWidth()
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  local header = self.frameColor .. string.rep(self.headCharacter, totalWidth) .. self.colorReset
  local columnHeaders = ""
  if self.printHeaders then
    local columnEntries = {}
    for _,v in ipairs(self.columns) do
      table.insert(columnEntries, v:format(v.options.name))
    end
    local divWithNewlines = string.format("\n%s", self:createRowDivider())
    columnHeaders = string.format("\n%s%s%s%s", ec, table.concat(columnEntries, sep), ec, divWithNewlines)
  end
  header = string.format("%s%s", header, columnHeaders)
  return header
end

function demonnic.TableMaker:createRowDivider()
  local columnPieces = {}
  for _,v in ipairs(self.columns) do
    local piece = string.format("%s%s%s", self.separatorColor, string.rep(self.rowSeparator, v.options.width), self.colorReset)
    table.insert(columnPieces, piece)
  end
  local ec = self.frameColor .. self.edgeCharacter .. self.colorReset
  local sep = self.separatorColor .. self.separator .. self.colorReset
  return string.format("%s%s%s", ec, table.concat(columnPieces, sep), ec)
end

function demonnic.TableMaker:assemble()
  local sheet = ""
  local rows = {}
  for _,row in ipairs(self.rows) do
    table.insert(rows, self:scanRow(row))
  end
  local divWithNewlines = string.format("\n%s\n", self:createRowDivider())
  local footer = string.format("%s%s%s", self.frameColor, string.rep(self.footCharacter, self:totalWidth()), self.colorReset)
  sheet = string.format("%s\n%s\n%s", self:makeHeader(), table.concat(rows, divWithNewlines), footer)
  return sheet
end


function demonnic.TableMaker:new(options)
  local me = {}
  setmetatable(me, self)
  self.__index = self
  if options == nil then options = {} end
  if type(options) ~= "table" then
    error("demonnic.TableMaker:new(options): ArgumentError: options expected as table, got " .. type(options))
  end
  local options = table.deepcopy(options)
  local columns = false
  if options.columns then
    if type(options.columns) ~= "table" then error("demonnic.TableMaker:new(options): option error: You provided an options.columns entry of type " .. type(options.columns) .. " and columns must a table with entries suitable for demonnic.TableFormatter:addColumn().") end
    columns = table.deepcopy(options.columns)
    options.columns = nil
  end
  local rows = false
  if options.rows then
    if type(options.rows) ~= "table" then error("demonnic.tableMaker:new(options): option error: You provided an options.rows entry of type " .. type(options.rows) .. " and rows must be a table with entrys suitable for demonnic.TableFormatter:addRow()") end
    rows = table.deepcopy(options.rows)
    options.rows = nil
  end
  for option, value in pairs(options) do
    me[option] = value
  end
  local dec = {"d", "decimal", "dec"}
  local hex = {"h", "hexidecimal", "hex"}
  local col = {"c", "color", "colour", "col", "name"}
  if table.contains(dec, me.formatType) then
    me.frameColor = me.frameColor or "&lt;255,255,255&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;r&gt;"
  elseif table.contains(hex, me.formatType) then
    me.frameColor = me.frameColor or "#ffffff"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "#r"
  elseif table.contains(col, me.formatType) then
    me.frameColor = me.frameColor or "&lt;white&gt;"
    me.separatorColor = me.separatorColor or me.frameColor
    me.colorReset = "&lt;reset&gt;"
  else
    me.frameColor = ""
    me.separatorColor = ""
    me.colorReset = ""
  end
  me.columns = {}
  me.rows = {}
  if columns then
    for _,column in ipairs(columns) do
      me:addColumn(column)
    end
  end
  if rows then
    for _,row in ipairs(rows) do
      me:addRow(row)
    end
  end
  return me
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>guiFramework</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2

-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.

-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.

-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.

-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.

-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.

-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.

GUIframe = GUIframe or {}

local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW/2), math.floor(mainH/2)
local quarterW, quarterH = math.floor(halfW/2), math.floor(halfH/2)
local eighthW, eighthH = math.floor(quarterW/2), math.floor(quarterH/2)

GUIframe.configs = GUIframe.configs or {}

--Default settings for display.
--These will load on a reset, and will be
--what loads when the application is run before
--saving display settings.
GUIframe.defaults = {
    tabHeight = tabsHeight,
    tabStyle = tabsStyle,
    tabEchoStyle = tabsFontStyle,
    leftStartWidth = eighthW,
    leftStartHeight = halfH,
    rightStartWidth = quarterW,
    rightStartHeight = halfH,
    topStartHeight = eighthH,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_30t.png",
    borderOffset = 2,
}

GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides = GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}

local resize_style = "border-image: url(%s%s);"

local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo

local container_names = {'topLeftContainer', 'bottomLeftContainer', 'topRightContainer',
    'bottomRightContainer', 'bottomContainer', 'topContainer'}
local tab_names = {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top","bottom","left","right"}
local side_containers = {
    left = {"topLeftContainer","bottomLeftContainer","topLeftTabs","bottomLeftTabs"},
    right = {"topRightContainer","bottomRightContainer","topRightTabs","bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"}
}

local function get_window_coords(win, update) -- gets coords for window, stores data in tabCoords table as needed
    local x, y = win:get_x(), win:get_y()
    local w, h = win:get_width(), win:get_height()
    if update then
        GUIframe.tabCoords[win.name]  = {x = x, y = y, w = w, h = h}
    end
    return x, y, w, h
end

local function check_overlap(tab, x, y) -- checks to see if given coords overlap tab or tab container
    if type(tab) == "string" then tab = GUIframe[tab] or GUIframe.tabs[tab] end
    if tab.hidden or tab.auto_hidden then return false end
    local info = GUIframe.tabCoords[tab.name]
    local x1, y1 = info.x, info.y
    local x2, y2 = x1 + info.w, y1 + info.h
    return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h) -- resizes and moves tab and updates tab coords table
    tab:move(x, y)
    tab:resize(w,h)
    local info = GUIframe.tabCoords[tab.name] or {}
    info.x, info.y = tab:get_x(), tab:get_y()
    info.w, info.h = tab:get_width(), tab:get_height()
    if table.contains(tab_names, tab.name) then
        info.container = true
    end
    GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
    if type(pos) == "table" then pos = pos.name end
    for _,w in ipairs({'right','left','container','tabs'}) do
        pos = pos:gsub(w,w:title())
    end
    local con, tab
    if string.find(pos,"Container") then
        con = GUIframe[pos]
        if not con then return end
        tabs = con.tabs
    elseif string.find(pos,"Tabs") then
        tabs = GUIframe[pos]
        if not tab then return end
        con = tabs.con
    else
        con = GUIframe[pos.."Container"]
        tabs = GUIframe[pos.."Tabs"]
    end
    return con, tabs
end

local function config()
    configs = table.update(GUIframe.defaults, GUIframe.configs)
    GUIframe.windows = {}
    GUIframe.tabCoords = {}

    tabsInfo = {
        topLeftTabs = {name = 'topLeftTabs', x = 0, y = 0, width = configs.leftStartWidth,
            height = configs.tabHeight},
        bottomLeftTabs = {name = 'bottomLeftTabs', x = 0, y = configs.leftStartHeight,
            width = configs.leftStartWidth, height = configs.tabHeight},
        topRightTabs = {name = 'topRightTabs', x = mainW - configs.rightStartWidth, y = 0,
            width = configs.rightStartWidth, height = configs.tabHeight},
        bottomRightTabs = {name = 'bottomRightTabs', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight, width = configs.rightStartWidth, height = configs.tabHeight},
    }
    containerInfo = {
        topLeftContainer = {name = 'topLeftContainer', x = 0, y = configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        bottomLeftContainer = {name = 'bottomLeftContainer', x = 0, y = configs.leftStartHeight + configs.tabHeight,
            width = configs.leftStartWidth, height = configs.leftStartHeight - configs.tabHeight},
        topRightContainer = {name = 'topRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomRightContainer = {name = 'bottomRightContainer', x = mainW - configs.rightStartWidth,
            y = configs.rightStartHeight + configs.tabHeight, width = configs.rightStartWidth,
            height = configs.rightStartHeight - configs.tabHeight},
        bottomContainer = {name = 'bottomContainer', x = configs.leftStartWidth,
            y = mainH - configs.bottomStartHeight, height = configs.bottomStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth},
        topContainer = {name = 'topContainer', x = configs.leftStartWidth, y = 0, height = configs.topStartHeight,
            width = mainW - configs.leftStartWidth - configs.rightStartWidth}
    }
    resizeInfo = {
        resizeLeft = {name = 'resizeLeft', x = configs.leftStartWidth,
            y = configs.leftStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeRight = {name = 'resizeRight', x = configs.rightStartWidth - configs.resizeWidth,
            y = configs.rightStartHeight - configs.resizeHeight / 2, height = configs.resizeHeight,
            width = configs.resizeWidth},
        resizeTop = {name = 'resizeTop', x = halfW - configs.resizeWidth / 2,
            y = configs.topStartHeight, height = configs.resizeHeight, width = configs.resizeWidth},
        resizeBottom = {name = 'resizeBottom', x = halfW - configs.resizeWidth / 2,
            y = mainH - configs.bottomStartHeight - configs.resizeHeight, height = configs.resizeHeight,
            width = configs.resizeWidth}
    }

    for name, cons in pairs(containerInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
    end
    for name, cons in pairs(tabsInfo) do
        GUIframe[name] = Geyser.Container:new(cons)
        local cname = name:gsub("Tabs","Container")
        GUIframe[cname].tabs = GUIframe[name]
        GUIframe[name].con = GUIframe[cname]
    end
    local style = resize_style
    local path = getMudletHomeDir()
    path = path:gsub("[\\/]","/")
    configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]","/")
    configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]","/")
    local no_image
    if not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage)) then
        debugc("GUIframe: config: resize image(s) not found")
        path = "255,20,147,"
        style = "background-color: rgba(%s%s);"
        no_image = true
    end

    for name, cons in pairs(resizeInfo) do
        GUIframe[name] = Geyser.Label:new(cons)
        GUIframe[name]:setColor(0,0,0,0)
        GUIframe[name]:setStyleSheet(string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setOnEnter("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "255") or configs.resizeHoverImage))
        GUIframe[name]:setOnLeave("GUIframe."..name..".setStyleSheet", GUIframe[name],
            string.format(style, path, (no_image and "100") or configs.resizeRestImage))
        GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
        GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
        GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
    end
    setBorderLeft(configs.leftStartWidth + configs.borderOffset)
    setBorderRight(configs.rightStartWidth + configs.borderOffset)
    setBorderTop(configs.topStartHeight + configs.borderOffset)
    setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
    GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
    -- hide all windows in container
    for _, win in pairs(container.windowList) do
        win:hide()
        win.active = false
    end
    -- unhighlight all tabs in tabs container
    if tabs then
        for _, tab in pairs(tabs.windowList) do
            local name = tab.name:gsub("Tab","")
            local show = GUIframe.windows[name].showText
            if show then
                tab:echo(configs.tabEchoStyle..name)
            end
	    end
	end
end

local function adjustTabs(tabs)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    -- remove duplicated window names
    local found = {}
    for k,v in ipairs(tabs.windows) do
        if not table.contains(found,v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
            table.insert(found,v)
        end
    end
    -- calculate tab width and set height
    local w, h = math.floor(100 / #tabs.windows), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    local shown, first
    for k,v in ipairs(found) do
        local tab = tabs.windowList[v]
        if not first then first = v:gsub("Tab","") end
        if not shown and tab.active then
            shown = v
        elseif tab.active then
            tab.active = false
        end
        update_tab(tab, wrap(w * (k-1)), 0, wrap(w), h)
    end
    if first and not shown and GUIframe.windows[first] then GUIframe.windows[first]:show() end
    tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
    local windows = tabs.windows
    while table.contains(windows, name) do
        table.remove(windows, table.index_of(windows, name))
    end
    table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local windows = table.deepcopy(tabs.windows)
    local space_pos = tabs.space_pos
    local tab_pos = table.index_of(windows, tab.name)
    -- calculate tab width and set height
    local num_tabs = #windows + 1
    if tab_pos then
        num_tabs = num_tabs - 1
        if pos &gt; tab_pos then pos = pos - 1 end
        if pos == space_pos then pos = pos + 1 end
    elseif space_pos and pos &gt;= space_pos then
        pos = pos + 1
    end
    local w, h = math.floor(100 / num_tabs), configs.tabHeight
    local function wrap(num) return tostring(num) .. "%" end
    -- resize and reposition all tabs
    if tab_pos then table.remove(windows,tab_pos) end
    for k,v in ipairs(windows) do
        if k &gt;= pos then
            update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
        else
            update_tab(tabs.windowList[v], wrap(w * (k-1)), 0, wrap(w), h)
        end
    end
    tabs.space_pos = pos
end

local function round(num,roundTo)
	local b, r = math.modf(num/roundTo)
	if r &gt;= 0.5 then
		b = b + 1
	end
	return b * roundTo
end

local function setBorder(side, val)
    local funcs = {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
    val = math.max(val,0)
	funcs[side](val)
end

local function resizeContainers(side, w, h)
    if table.contains({"left", "right"}, side) then
        local info = {
            left = {resize = "resizeLeft", cons = {"topLeftContainer","bottomLeftContainer"},
                tabs = {"topLeftTabs","bottomLeftTabs"}, x = 0, w = w},
            right = {resize = "resizeRight", cons = {"topRightContainer","bottomRightContainer"},
                tabs = {"topRightTabs","bottomRightTabs"}, x = w, w = mainW - w}
        }
        info = info[side]
        -- move and resize top, bottom and tab containers
        update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
        update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
        GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
        GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
        GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
        GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
        -- adjust border size
        setBorder(side, info.w + configs.borderOffset)

        -- adjust width of top and bottom containers
        local x, y
        x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
        w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
        for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
            y, h = con:get_y(), con:get_height()
            con:resize(w, h)
            con:move(x, y)
        end
    elseif table.contains({"top", "bottom"}, side) then
        local x = 0
        w = mainW
        if GUIframe.sides.left ~= "hidden" then
            w = w - GUIframe.topLeftContainer:get_width()
            x = GUIframe.topLeftContainer:get_width()
        end
        if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
        local info = {top = {con = "topContainer", y = 0, h = h}, bottom = {con = "bottomContainer", y = h, h = mainH - h}}
        local con = GUIframe[info[side].con]
        con:resize(w, info[side].h)
        con:move(x, info[side].y)
        setBorder(side, info[side].h + configs.borderOffset)
    end
end

local function refresh()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    mainW, mainH = getMainWindowSize()
    local rH, rW = configs.resizeHeight, configs.resizeWidth
    local x, y, w
    -- adjust bottom left and right container heights
    for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
        C:resize(C:get_width(), mainH - C:get_y())
    end
    -- reposition right containers
    w = GUIframe.topRightContainer:get_width()
    for _, C in ipairs({GUIframe.topRightContainer, GUIframe.topRightTabs,
        GUIframe.bottomRightContainer, GUIframe.bottomRightTabs}) do
        C:move(mainW - w,C:get_y())
    end
    -- resize and reposition bottom and top containers
    w, x = mainW, 0
    if GUIframe.sides.left ~= "hidden" then
        w = w - GUIframe.topLeftContainer:get_width()
        x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then w = w - GUIframe.topRightContainer:get_width() end
    for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
        C:resize(w, C:get_height())
        C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
    end
    -- reposition resize labels
    x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    GUIframe.resizeLeft:move(x, y - rH / 2)
    x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
    GUIframe.resizeRight:move(x - rW, y - rH / 2)
    x = (GUIframe.topContainer:get_width() - rW) / 2
    if GUIframe.sides.left ~= "hidden" then x = x + GUIframe.topLeftContainer:get_width() end
    y = GUIframe.topContainer:get_height()
    GUIframe.resizeTop:move(x, y)
    y = GUIframe.bottomContainer:get_y()
    GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden
function GUIframe.enable(side)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.enable: invalid side",2) end
    local cons = side_containers[side]
    for _, con in ipairs(cons) do
        GUIframe[con]:show()
        for _,win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
            if win.active then win:show() end
        end
    end
    if table.contains({"left","right"}, side) then
        setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
    else
        setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
    end
    GUIframe["resize"..side:title()]:show()
    GUIframe.sides[side] = "enabled"
    refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated
function GUIframe.disable(side, hide)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not table.contains(sides,side) then error("GUIframe.disable: invalid side",2) end
    local cons = side_containers[side]
    GUIframe.sides[side] = "disabled"
    if hide then
        for _, con in ipairs(cons) do
            GUIframe[con]:hide()
            for _, win in pairs(GUIframe[con].windowList) do -- loop can be removed after Geyser fix comes in
                if win.type == "mapper" then win:hide() end
            end
        end
        local border = _G["setBorder"..side:title()]
        border(0)
        GUIframe.sides[side] = "hidden"
    end
    GUIframe["resize"..side:title()]:hide()
    refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable
function GUIframe.addWindow(window, name, container, hideText)
    if not GUIframe.initialized then config() end
    if type(container) == "table" then container = container.name end
    local con, tabs = get_containers(container)
    if not con then error("GUIframe.addWindow: invalid container name",2) end
    if not name then error("GUIframe.addWindow: name argument required",2) end
    -- remove window from any containers
    for _, tcon in ipairs(container_names) do
        if table.contains(GUIframe[tcon].windows, window.name) then
            GUIframe.removeWindow(name, tcon)
        end
    end
    deselectContainer(con,tabs)
    -- add tab for window, if applicable
    if tabs then
        local showText = not hideText
        window.showText = showText
        local lbl = Geyser.Label:new({name = name.."Tab", x = 0, y = 0, width = 10, height = 10},tabs)
        lbl:setStyleSheet(configs.tabStyle)
        if showText then
            lbl:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
        lbl:setClickCallback("GUIframe.buttonClick", name)
        lbl:setReleaseCallback("GUIframe.buttonRelease", name)
        lbl:setMoveCallback("GUIframe.buttonMove", name)
        GUIframe.tabs[name] = lbl
        adjustTabs(tabs)
    end
    -- add window to container and set size and position
    con:add(window)
    window:resize("100%","100%")
    window:move(0,0)
    window:show()
    GUIframe.windows[name] = window
	raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)
function GUIframe.removeWindow(name, container)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    if not container then container = GUIframe.windows[name].container end
    local con, tabs = get_containers(container)

    if not con or not table.contains(container_names, con.name) then
        error("GUIframe.removeWindow: invalid container name",2)
    end
    if not name then error("GUIframe.removeWindow: name argument required",2) end
    if tabs then
        local lbl = tabs.windowList[name.."Tab"]
        if lbl then
            tabs:remove(lbl)
            adjustTabs(tabs)
            lbl:hide()
        end
    end
    local window = GUIframe.windows[name]
    con:remove(window)
    window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container
function GUIframe.saveSettings()
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
    saveTbl.left = {w = w, h = h}
    w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
    saveTbl.right = {w = w, h = h}
    w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
    saveTbl.top = {w = w, h = h}
    w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
    saveTbl.bottom = {w = w, h = h}

    -- get added windows and containers they are assigned to
    local windows = {}
    local text = {}
    for k,v in pairs(GUIframe.windows) do
        local con = v.container.name
        windows[con] = windows[con] or {}
        table.insert(windows[con], k)
        text[con] = text[con] or {}
        text[con][k] = v.showText
    end
    -- reorder windows to match tab order for tabbed containers
    for con, wins in pairs(windows) do
        if con:find("Left") or con:find("Right") then
            local tabs = GUIframe[con].tabs.windows
            local new = {}
            for k,v in ipairs(tabs) do
                local wname = v:gsub("Tab","")
                table.insert(new, {wname, text[con][wname]})
            end
            windows[con] = new
        end
    end
    saveTbl.windows = windows
    saveTbl.sides = GUIframe.sides
    table.save(getMudletHomeDir() .. "/GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save
function GUIframe.loadSettings(redraw)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
    local saveTbl = {}
    local path = getMudletHomeDir() .. "/GUIframeSave.lua"
    path = path:gsub("\\","/")
    mainW, mainH = getMainWindowSize()
    if not io.exists(path) then debugc("GUIframe.loadSettings: save file doesn't exist.") return end
    table.load(path, saveTbl)
    resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
    resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
    resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
    resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
    for con, wins in pairs(saveTbl.windows) do
        for _,name in ipairs(wins) do
            if type(name) == "string" then
                GUIframe.addWindow(GUIframe.windows[name], name, con)
            else
                local n, s = name[1], not name[2]
                GUIframe.addWindow(GUIframe.windows[n], n, con, s)
            end
        end
    end

    for side, state in pairs(saveTbl.sides) do
        if state == "enabled" then
            GUIframe.enable(side)
        elseif state == "disabled" then
            GUiframe.disable(side,false)
        elseif state == "hidden" then
            GUIframe.disable(side,true)
        end
    end
    -- force redraw of screen
    if redraw then
        setBackgroundColor(1,1,1)
        setBackgroundColor(0,0,0)
    end
end

-- can be called to force the script to run its config function again
function GUIframe.reinitialize()
    config()
end

-- can be called to activate a given tab without clicking on it
function GUIframe.activate(name)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local window = GUIframe.windows[name]
	if window then
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    end
end

-- can be called to apply a style to a given tab
function GUIframe.styleTab(name, style)
    if not GUIframe.initialized then error("GUIframe not initialized",1) end
	local tab = GUIframe.tabs[name]
	if tab then
	    tab:setStyleSheet(style)
    end
end

-- internally used function to handle button click callbacks
function GUIframe.buttonClick(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton" then
	        local lbl = GUIframe[name]
	        lbl.difX, lbl.difY = event.x, event.y
	        lbl.savedX, lbl.savedY = getMousePosition()
            GUIframe[name].isClicked = true
        end
	elseif event.button == "LeftButton" then
        local window = GUIframe.windows[name]
        local con, tabs = get_containers(window.container.name)
        -- hide and unhighlight other windows and tabs
        deselectContainer(con, tabs)
        -- show selected window
        window:show()
        window.active = true
        -- highlight selected tab
        if window.showText then
            GUIframe.tabs[name]:echo(configs.tabEchoStyle.."&lt;b&gt;"..name)
        end
    elseif event.button == "RightButton" then
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        tab.savedX, tab.savedY = getMousePosition()
        tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
        -- force update of coords for all tabs and tab containers
        GUIframe.tabCoords = {}
        for _, name in ipairs(tab_names) do
            get_window_coords(GUIframe[name], true)
            for tname, tab in pairs(GUIframe[name].windowList) do
                get_window_coords(tab, true)
            end
        end
    end
    raiseEvent("GUIframe.buttonClick",name,event)
end

-- internally used function to handle button release callbacks
function GUIframe.buttonRelease(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    if event.button == "RightButton"  then
            local lbl = GUIframe[name]
            lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
        end
	elseif event.button == "RightButton" then
	    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
	    local con, tabs = get_containers(window.container.name)
	    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
	    hideWindow("show_container")
	    for _, tname in ipairs(tab_names) do
	        local info = GUIframe[tname]
	        if info.mouse_over then
	            local pos = info.space_pos
	            info.mouse_over = nil
	            GUIframe.addWindow(window, name, tname:gsub("Tabs",""), not window.showText)
	            if pos then
    	            reorderTabs(info, tab.name, pos)
    	            adjustTabs(info)
    	        end
	        end
	    end
	    adjustTabs(tabs)
	end
	raiseEvent("GUIframe.buttonRelease",name,event)
end

-- internally used function to handle button move callbacks
function GUIframe.buttonMove(name, event)
    if not GUIframe.initialized then error("GUIframe not initialized",2) end
	if table.contains(resizeLabels,name) then
	    lbl = GUIframe[name]
	    if lbl.isClicked then
	        local w, h = getMousePosition()
	        w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
            mainW, mainH = getMainWindowSize()
            local side, cW, cH, rX, rY
            local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
            local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
            local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
            local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
            local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
            local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
	        w, h = max(w, 0), max(h, 0)
            local info = { -- specify position of resize labels and size of containers
                resizeLeft = {side = "left", x = min(w, maxX - rW),
                    y = min(max(h + rH / 2,tabH), mainH - tabH) - rH / 2,
                    w = min(w, maxX - rW), h = min(max(h + rH / 2,tabH), mainH-tabH) },
                resizeRight = {side = "right", x = min(max(w, minX), mainW),
                    y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
                    w = min(max(w, minX), mainW - rW) + rW, h = min(max(h + rH / 2, tabH), mainH - tabH) },
                resizeTop = {side = "top", x = minX + (mid - rW) / 2,
                    y = min(h, maxY - rH), w = maxX - minX, h = min(h, maxY - rH) },
                resizeBottom = {side = "bottom", x = minX + (mid - rW) / 2,
                    y = min(max(h, minY) - rH, mainH), w = maxX - minX, h = min(max(h, minY) + rH, mainH)} }
            info = info[name]
            lbl:move(info.x, info.y)
            resizeContainers(info.side, info.w, info.h)
        end
    else
        local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
        local con, tabs = get_containers(window.container.name)
        local x, y = getMousePosition()
        local over_con, over_tab
        if tab and tab.isClicked then
            moveWindow(tab.name, x - tab.difX, y - tab.difY)
            -- check to see if mouse is over any tab containers
            for _, tcon in ipairs(tab_names) do
                if check_overlap(tcon, x, y) then
                    over_con = tcon
                    GUIframe[tcon].mouse_over = true
                    local info = GUIframe.tabCoords[tcon]
                    local tx, ty, tw, th = info.x, info.y, info.w, info.h
                    createLabel("show_container", 0, 0, 0, 0, 1)
                    moveWindow("show_container", tx, ty)
                    resizeWindow("show_container", tw, th)
                    setLabelStyleSheet("show_container",[[
                        background-color: black;
                        border: 2px solid white;]])
                    showWindow("show_container")
                    lowerWindow("show_container")
                    -- check to see if mouse is over any tabs
                    for tname, info in pairs(GUIframe.tabs) do
                        if tname ~= name and check_overlap(info, x, y) then
                            over_tab = info.name
                            local windows = GUIframe[tcon].windows
                            local index = table.index_of(windows,over_tab)
                            makeSpace(GUIframe[tcon],tab,index)
                            break
                        end
                    end
                    break
                end
            end
            -- remove any unnecessary spaces in tab containers
            for _, name in ipairs(tab_names) do
                if name ~= over_con then
                    adjustTabs(GUIframe[name])
                    GUIframe[name].mouse_over = nil
                end
            end
        end
	end
	raiseEvent("GUIframe.buttonMove",name,event)
end

-- internally used function to handle sysWindowResizeEvent
function GUIframe.eventHandler(event,...)
    if event == "sysWindowResizeEvent" and GUIframe.initialized then
        refresh()
    end
end

--register the event above
registerAnonymousEventHandler("sysWindowResizeEvent","GUIframe.eventHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>md5</name>
				<packageName></packageName>
				<script>md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift

local ok, bit = pcall(require, 'bit')
if ok then
  bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
else
  ok, bit = pcall(require, 'bit32')

  if ok then

    bit_not = bit.bnot

    local tobit = function(n)
      return n &lt;= 0x7fffffff and n or -(bit_not(n) + 1)
    end

    local normalize = function(f)
      return function(a,b) return tobit(f(tobit(a), tobit(b))) end
    end

    bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
    bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)

  else

    local function tbl2number(tbl)
      local result = 0
      local power = 1
      for i = 1, #tbl do
        result = result + tbl[i] * power
        power = power * 2
      end
      return result
    end

    local function expand(t1, t2)
      local big, small = t1, t2
      if(#big &lt; #small) then
        big, small = small, big
      end
      -- expand small
      for i = #small + 1, #big do
        small[i] = 0
      end
    end

    local to_bits -- needs to be declared before bit_not

    bit_not = function(n)
      local tbl = to_bits(n)
      local size = math.max(#tbl, 32)
      for i = 1, size do
        if(tbl[i] == 1) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end
      return tbl2number(tbl)
    end

    -- defined as local above
    to_bits = function (n)
      if(n &lt; 0) then
        -- negative
        return to_bits(bit_not(math.abs(n)) + 1)
      end
      -- to bits table
      local tbl = {}
      local cnt = 1
      local last
      while n &gt; 0 do
        last      = n % 2
        tbl[cnt]  = last
        n         = (n-last)/2
        cnt       = cnt + 1
      end

      return tbl
    end

    bit_or = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 and tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_and = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i]== 0 or tbl_n[i] == 0) then
          tbl[i] = 0
        else
          tbl[i] = 1
        end
      end

      return tbl2number(tbl)
    end

    bit_xor = function(m, n)
      local tbl_m = to_bits(m)
      local tbl_n = to_bits(n)
      expand(tbl_m, tbl_n)

      local tbl = {}
      for i = 1, #tbl_m do
        if(tbl_m[i] ~= tbl_n[i]) then
          tbl[i] = 1
        else
          tbl[i] = 0
        end
      end

      return tbl2number(tbl)
    end

    bit_rshift = function(n, bits)
      local high_bit = 0
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
        high_bit = 0x80000000
      end

      local floor = math.floor

      for i=1, bits do
        n = n/2
        n = bit_or(floor(n), high_bit)
      end
      return floor(n)
    end

    bit_lshift = function(n, bits)
      if(n &lt; 0) then
        -- negative
        n = bit_not(math.abs(n)) + 1
      end

      for i=1, bits do
        n = n*2
      end
      return bit_and(n, 0xFFFFFFFF)
    end
  end
end

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 &gt; 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>TECFunctions</name>
			<packageName></packageName>
			<script>--Functions made by The Eternal Citizens
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>debug</name>
				<packageName></packageName>
				<script>--[[
Debug like functions:


]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setTECDebugMode(tectmpSetDebug)</name>
					<packageName></packageName>
					<script>--opens a debug window.
--triggers system to send debug information to it.

function setTECDebugMode(tectmpSetDebug)
	
	--Set debug mode
	tecSettings.tecDebugMode = tectmpSetDebug or false
	
	if tecSettings.tecDebugMode then --if enabling debug
		openUserWindow("tecDebugWindow")
		--saveWindowLayout() --save floating miniconsole locations
		--loadWindowLayout() --load previously save miniconsole position.
		--tecDebugWindow:addScrollbars(parent, "Vertical")
		echo("Debug mode enabled.\n")
	else --else disabling debug
		echo("Debug mode disabled.\n")
		setTECDisplayDebugMode(tectmpSetDebug)
		setTECMapDebugMode(tectmpSetDebug)
		setTECTimerDebugMode(tectmpSetDebug)
	end -- if tectmpSetDebug
	
end --end function setTecDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDebugMode() 
	return tecSettings.tecDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>debugToDisplay()</name>
					<packageName></packageName>
					<script>--this takes a string from function input, and displays it to the debug screen.

--error("") Test this one.
--debugc("") fairly certain this exports to mudlets debug screen.

--Idealy we would want this function to check if a TECClient debug child window 
--Is open, and create one if it is not. Than send debug code to it rather than 
--main, where users can easily see it or mudlets debug, which is meant for true
--blue errors.
function debugToDisplay(textMessage)
	if getTECDebugMode() then --Is debug mode on?
		local redBG, greenBG, blueBG = getBgColor() --keep track of current screen color
		setBgColor( 255,50,50) --change text background to red
		echo("tecDebugWindow","\n"..textMessage) -- print message to screen
		setBgColor(redBG,greenBG,blueBG) --change text background back to what it was
	end --if debug mode if check
end --end displayToDebug function
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>geyserDebug()</name>
					<packageName></packageName>
					<script>--poll GUIFrame for 
--Geyser API Reference https://www.mudlet.org/geyser/files/geyser/GeyserContainer.html

function Geyser.Container:getDebug ()
	 
 if getTECDisplayDebugMode() then
	 
  	 local string guiLog = ""
  	 
     guiLog ="Name: "..tostring(self.name)..
		 " | Type: "..tostring(self.type)..
		 " | Parent: "..tostring(self.parent.name)..
		 " | X position: "..tostring(self:get_x())..
		 " | Y Position: "..tostring(self:get_y())..
		 " | Width: "..tostring(self:get_width())..
		 " | Height: "..tostring(self:get_height())..
		 "\n"
  	 
		 --just in case we are going to make a infinite loop killer.
		 guiloop = guiloop + 1
		 if guiloop &lt; 100 then
		 
       --Loop through all children of this container
       for k,v in pairs(self.windowList) do
    	 		
          if k ~= self then
    				guiLog = guiLog..v:getDebug() --Collect debug data to string
    					
          end --end if k not = self check
       end --end for loop pair(self windowlist)
		 end --if guiloop is less than 100
		 
		 --Returns debug data for all of the windows we have looped through
		 return guiLog
		 
	end --if getTECDisplayDebugMode()
end --end Geyser.Container:debugMode


function geyserDebug() --geyserWindow needs to be a string with the name of the window.	

	if getTECDisplayDebugMode() then --Is debug mode on?
		local debugOut = ""
		--Send all of the windows information to the debug display.
		guiloop = 0
		debugToDisplay(GUIframe.topLeftContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomLeftContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomContainer:getDebug())
		guiloop = 0
		debugToDisplay(GUIframe.bottomRightContainer:getDebug())
		guiloop = 0
		debugOut =GUIframe.topRightContainer:getDebug()
		debugOut = debugOut:sub(1, -2)
		debugOut = debugOut:sub(2)
		debugToDisplay(debugOut)
		guiloop = 0
		debugOut = GUIframe.topContainer:getDebug()
		debugOut = debugOut:sub(1, -2)
		debugToDisplay(debugOut)
	end --if tecDebugMode is true

end --end geyserDebug() function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecReportIssuesHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>--help user create an issue request
--tecBrief is if screen reporting should be brief
--tecWindow is the string name of the window to send the command help to
function tecReportIssuesHelp(tecBrief, tecWindow) 

	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false

  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug report issue", 
  	[[tecReportIssues()]], 
  	"Report client issues", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, ", Report client issues to developers.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief

end --function tecReportIssues

function tecReportDebugHelp()
	echo("\n---Debug collection helper---\n")
	echo("Please do not follow these steps unless you have opened an issue report and "
		.."were asked to collect debug data from a developer.\n"
		.."The debug modes available are: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on&lt;reset&gt;, ", 
  	[[setTECDebugMode(true)]], 
  	"Enable basic debug", true)
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on&lt;reset&gt;, ", 
  	[[setTECDisplayDebugMode(true)]], 
  	"Enable display debugging", true)
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on&lt;reset&gt;, ", 
  	[[setTECMapDebugMode(true)]], 
  	"Enable map debugging", true)
	echo("and ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timer on&lt;reset&gt;.\n", 
  	[[setTECTimerDebugMode(true)]], 
  	"Enable timer debugging", true)
	echo("After enabling the debug mode or modes requested clear your main window with, ") 
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[tecClearDisplay() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Now cause the issue reported to occur. After you have disable debug mode with ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off.\n", 
  	[[setTECDebugMode(false)]], 
  	"Disable debugging", true)
	echo("Please verify the debug window has text in it than click ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save debug window.\n", 
  	[[tecSaveWindowText("tecDebugWindow")]], 
  	"Save debug window text to file", true)
	echo("Please save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	echo("Open your issue report, at the TEC gitHub ")
	  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	echo("Open the folder that contains the debug window text by clicking ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	cecho("Open main.txt and tecDebugWindow.txt and verify nothing is in it that you would "
		.."not want to be viewed by the public.\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Drag the files tecDebugWindow.txt and main.txt into the comment area of your "
		.."gitHub issues report.&lt;reset&gt;\n"
		.."To update your issue click the green button labeled -Comment-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --function tecReportDebugHelp()

function tecReportStandardIssue()
	echo("\n---Create an issue request helper---\n")
	echo("Go to the client's issue reporting gitHub page: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Issue Page.\n", 
  	[[openUrl("https://github.com/TheEternalCitizens/mudlet-integration/issues")]], 
  	"Goto issues page", true)
	echo("Please view our current open issues to see if your issue was already reported.\n"
		.."If you have not you will need to log into gitHub.\n"
		.."To create an issue report click the green -New Issue- button, on the right side of the page.\n"
		.."A new page will load. In the -Title- section please provide a brief description of your issue\(s\).\n"
		.."In the comment section labeled -Leave a comment-. Fully describe your issue\(s\).\n"
		.."It is highly recommendable to clear you main display and recreate your issue "
		.."before continuing forward.\n"
		.."If you would like to, clear your display with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear\n", 
  [[tecClearDisplay() tecReportDebugHelp()]], 
  "Remove text from main screen", true)
	echo("Save the text in the main window to file by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Save main window.\n", 
  	[[tecSaveWindowText()]], 
  	"Save main window text to file", true)
	echo("This file is called main.txt and can easily found by clicking: ")
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;Open Folder.\n", 
  	[[tecOpenDirectory(tecDebugSaveDir)]], 
  	"Open debug save folder", true)
	cecho("Open main.txt and verify nothing is in it that you would not want to be viewed "
		.."by the public!\n"
		.."&lt;black:red&gt;If for any reason you do not want to make text on your screen publically visable "
		.."please skip the next step highlighted in blue.&lt;reset&gt; "
		.."&lt;:"..tecSettings.helpHighlightColor.."&gt;Now drag the file main.txt into the comment area of the gitHub issues report.&lt;reset&gt;\n"
		.."At this time, please do not attach any other files to the issue report.\n"
		.."To submit your issue click the green button labeled -Submit new issue-\n"
		.."It may take days or weeks to receive a reply to your issue report.\n")
end --end function tecReportMajorIssue

function tecReportIssues()

	cecho("&lt;black:red&gt;\nPlease follow the instructions below.\n")

	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---Start an issue request---\n", 
  	[[tecReportStandardIssue()]], 
  	"Standard issue report tutorial", true)
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;\n---A developer asked you to enable debug---", 
  	[[tecReportDebugHelp()]], 
  	"Debug collection tutorial", true)
		
	echo("\n") --leave this as the last line. cechlink does not autoscroll main display.
	
end --function tecReportIssues</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>function setTECDisplayDebugMode(tmpDebugMode)
	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecDisplayDebugMode = tmpDebugMode or false
	
	if tecSettings.tecDisplayDebugMode then echo("Display debug mode on.\n")
	else echo("Display Debug Off.\n") end
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECDisplayDebugMode</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECDisplayDebugMode() 
	return tecSettings.tecDisplayDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecColorTest()</name>
					<packageName></packageName>
					<script>--Just a simple test outputting colors to screen using three main methods.

function tecColorTest()

  echo("\ndefault text\n")
  cecho("\ncecho: &lt;:"..tecSettings.helpHighlightColor.."&gt;blue background, &lt;red:white&gt;Red text white background.\n")
  decho("\ndecho: &lt;:255,0,0&gt;Red background, &lt;0,0,255:0,255,0&gt;Blue text green background.\n")
  hecho("\nhecho: #ff0000Red text, #3c00ffBlue text.\n")

end --end tecColorTest function</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECMapDebugMode(boolean)</name>
					<packageName></packageName>
					<script>function setTECMapDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode
	
	tecSettings.tecMapDebugMode = tmpDebugMode or false --enable map debug mode
	
	if tecSettings.tecMapDebugMode then echo("Debug map mode on.\n")
	else echo("Map Debug Off.\n") end
	
end --end setTECVideoDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECMapDebugMode()</name>
					<packageName></packageName>
					<script>--Get state of debug mode.
function getTECMapDebugMode()
	return tecSettings.tecMapDebugMode
end --end function getTECdebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECTimerDebugMode(boolean)</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function setTECTimerDebugMode(tmpDebugMode)

	if tmpDebugMode then 
		if not getTECDebugMode() then setTECDebugMode(true) end --debug is not on enable it
	end --if tmpDebugMode

	tecSettings.tecTimerDebugMode = tmpDebugMode or false
	if tecSettings.tecTimerDebugMode then echo("Debug timer mode on.\n")
	else echo("Timer Debug Off.\n") end
end --setTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getTECTimerDebugMode()</name>
					<packageName></packageName>
					<script>--enables or disables debug for timers
function getTECTimerDebugMode()
	return tecSettings.tecTimerDebugMode
end --getTECTimerDebugMode</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>GUI or display</name>
				<packageName></packageName>
				<script>--[[
for funtions that directly affect the clients GUI.

GUI like functions
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>setMainWindowAutoWrap()</name>
					<packageName></packageName>
					<script>--set main window word wrap size.
--Function is called via an alias and in compass.resize
--It is currently in the guiChange event function to be called when gui changes occur
function setMainWindowAutoWrap()

  --get how many characters should appear on a line before word wrapping.
	local wrapAt = getColumnCount()

  --Set updated word wrap for main.
  setWindowWrap("main", wrapAt)
	
	if getTECDebugMode() then --if debug mode is enabled
	
  	--how many pixels thick is our font?
    local mainWidth, mainHeight = getMainWindowSize()
    
    --Get the width of left and right gui bars.
    local leftSideWidth = GUIframe.topLeftContainer:get_width()
    local rightSideWidth = GUIframe.topRightContainer:get_width()
	
  	--displays actual sizes to screen.
  	--display with setTECDebugMode(true)
  	--or command line debug on
  	debugToDisplay("setMainWindowAutoWrap: Font Width: "..tostring(fontWidth).." Left side width: "..tostring(leftSideWidth)
  	.." Right side width: "..tostring(leftSideWidth).." Main screen width: "..tostring(mainWidth)
  	.." Line wrap: "..tostring(wrapAt).." Mains font sie: "..tostring(getFontSize())..".")
	
	end --end if debug is enabled
end --end function setMainWindowAutowrap</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>calcMenuFonts</name>
					<packageName></packageName>
					<script>--This is needed because low resolutions screens even remotely large text will bleed
--off the edges.
--Where high resolution screens small text or even large text like 14 may not be legable.
--Not needed until after 1.0. We can use font size 14 for now

--Calculate tab and other gui fonts base on main screen size.
--Could set variables directly
--Could return a single font while passing a string to determine
--what is being mesured calcMenuFont("tabs") calcMenuFont("menus")
--could also just calculate them all and just return them all always.</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setMenuFonts</name>
					<packageName></packageName>
					<script>--This is needed because low resolutions screens even remotely large text will bleed
--off the edges.
--Where high resolution screens small text or even large text like 14 may not be legable.
--Not needed until after 1.0. We can use font size 14 for now

--Sets the font sizes for menus and tabs.
--Need to echo into all the tabs and labels
--will need to be in guiChange event
--will need to call calcMenuFonts to get sizes. (Scripts-TEC Scripts-GUI)
--Will need to be called in variables to set 
--tabsFontStyle
--Probably just set it to trigger at known screen widths.
--Keep in mind that getMainConsoleWidth is buggy as of v4.03
--4.1.1 theres a new function to get windows of miniconsole in text coloums.</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClearDisplay()</name>
					<packageName></packageName>
					<script>--There is either a bug or clear working as intended.
--If we clear main. geyser objects that adopt it's background color via getBgColor
--it will error out.

function tecClearDisplay()

  --backup background color
	local br,bg,bb = getBgColor()
	
  --clear main
  clearWindow()

  --set mains background to eat it was.
	setBgColor(br,bg,bb)
	echo(" \n") --We need a line of text on the screen for getBgColor to copy from.
	
end --end function tecClearDisplay</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplayReset()</name>
					<packageName></packageName>
					<script>function tecClientDisplayReset()

echo("Display settings reset. You MUST restart mudlet.")

  GUIframe.reinitialize()  --reset window positions to default
	tecClientDisplaySave(true) --save default window positions to file
  send("exit") --disconnect
  send("exit")
  disconnect()

end --function tecClientDisplayReset()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplaySave(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientDisplaySave(displayToScreen)
  GUIframe.saveSettings()
  if displayToScreen then echo("\nDisplay settings saved.\n") end
end --function tecClientDisplaySave</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientDisplayLoad(displayToScreen)</name>
					<packageName></packageName>
					<script>function tecClientDisplayLoad(displayToScreen)

  GUIframe.loadSettings(redraw) --loads display settings from file
  if displayToScreen then 
		echo("\nDisplay settings loaded from last save.\n")
	end --if displayToScreen
	
end --function tecClientDisplayLoad</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setInventoryFormater(setFormater)</name>
					<packageName></packageName>
					<script>function setInventoryFormater(setFormater)
  setFormater = setFormater or false
  tecFormatInventory = setFormater
end --function setInventoryFormater</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>getInventoryFormater()</name>
					<packageName></packageName>
					<script>function getInventoryFormater()
  return tecFormatInventory
end --function getInventoryFormater</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>help</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientFullHelp(tecBrief, tecWindow)</name>
					<packageName></packageName>
					<script>function tecClientFullHelp(tecBrief, tecWindow)
  
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"
	tecBrief = tecBrief or false
	
	if not tecBrief then --if we do not want to be brief
    echo(tecWindow, "There are a number of commands to adjust the game client. "
  		.."They are:\n")	
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient", 
  [[tecClientHelp()]], 
  "Save or load client settings.", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, " Save or load client settings.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
 
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;display", 
  [[tecDisplayHelp()]], 
  "Change display settings.", true)
  if not tecBrief then --if we do not want to be brief
    echo(tecWindow, " Save or load display positions, "
			.."reset display to defaults, "
  		.."and clear text off the display.\n") 
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  cechoLink(tecWindow, "&lt;:"..tecSettings.helpHighlightColor.."&gt;debug", 
  [[tecDebugHelp()]], 
  "Create debug messages", true)
  if not tecBrief then --if we do not want to be brief
  	echo(tecWindow, " Use to get information to report issues.\n")
	else echo(tecWindow, "\n")
  end --end if not tecBrief
  
  echo(tecWindow, "\n")
end --end function tecClientFullHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDebugHelp()</name>
					<packageName></packageName>
					<script>function tecDebugHelp()
  cecho("\n&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug on", 
  [[setTECDebugMode(true)]],
  "Send debug text to debug window", true)
  echo(", Create debug window and send basic info to it.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug off", 
  [[setTECDisplayDebugMode(false) setTECMapDebugMode(false) setTECDebugMode(false)]],
  "Stop all debug messages", true)
  echo(", Stops sending all debug messages.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display on", 
  [[setTECDisplayDebugMode(true)]],
  "Show display messages to debug window", true)
  echo(", Send display information to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug display off", 
  [[setTECDisplayDebugMode(false)]],
  "Stop showing display messages to debug window", true)
  echo(", Disables display debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map on", 
  [[setTECMapDebugMode(true)]],
  "Show map messages to debug window", true)
  echo(", Send map debug messages to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug map off", 
  [[setTECMapDebugMode(false)]],
  "Stop showing map messages to debug window", true)
  echo(", Disables map debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers on", 
  [[setTECTimerDebugMode(true)]],
  "Start showing timmer messages to debug window", true)
  echo(", Send timer debug messages to debug.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug timers off", 
  [[setTECTimerDebugMode(false)]],
  "Stop showing timmer messages to debug window", true)
  echo(", Disables timmer debug messages only.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;debug test colors", 
  [[tecColorTest()]],
  "Send basic colors to screen", true)
  echo(", Sends colored text to screen.\n")
	
	tecReportIssuesHelp(false, "main")
  
  cecho("&lt;black:red&gt;Debug mode is intended for collecting data to report "
		.."issues.&lt;reset&gt;\n")

end --end function tecDebugHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecDisplayHelp()</name>
					<packageName></packageName>
					<script>function tecResizeDisplayHelp() --explains how to resize display
	cecho("\n&lt;black:"..tecSettings.helpHighlightColor.."&gt;\\\/\\\/All windows can be resized! Read Below.\\\/\\\/&lt;reset&gt;\n"
		.."Version one allows this by RIGHT "
		.."clicking one of the four faint blue arrows and dragging it. "
		.."These arrows are on the top, bottom, left and right outer edges "
		.."of the main text window that this text appears in. "
		.."When you move your mouse over the arrows they will "
		.."become bold blue arrows."
		.."\n&lt;black:"..tecSettings.helpHighlightColor.."&gt;\/\\\/\\All windows can be resized! Read Above.\/\\\/\\&lt;reset&gt;\n")
end --function tecResizeDisplayHelp

function tecDisplayHelp()
  
  echo("\nDisplay commands:\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display clear", 
  [[tecClearDisplay()]], 
  "Remove text from main screen", true)
	echo(", clear text from main text console.\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display save", 
  [[tecClientDisplaySave(true)]], 
  "Save window positions", true)
	echo(", save window positions.\n")
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display load", 
  [[tecClientDisplayLoad(true)]], 
  "Load window positions", true)
	echo(", reset window positions to last save.\n")
	
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display reset", 
  [[tecClientDisplayReset()]], 
  "Reset window positions", true)
	echo(", reset window positions to default. "
		.."This WILL require you to restart mudlet.\n")
		
	cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;display refresh settings", 
  [[tecClientDisplayReset()]], 
  "Refresh text in settings", true)
	echo(", clears and reloads text in settings window. ")
			
	tecResizeDisplayHelp() --explains how to resize display
	
end --end tecDisplayHelp()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientHelp()</name>
					<packageName></packageName>
					<script>function tecClientHelp()

  echo("\ntecclient command:\n")
	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient font size", 
  [[printCmdLine("tecclient font size ")]],
  "Change client font size", true)
  echo(", Change font size for all consoles.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient change colors", 
  [[tecClientChangeColors()]],
  "Change client colors", true)
  echo(", Change color scheme for client.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save all", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
  echo(", Save client and display settings to file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  echo(", Save basic client settings to file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient load", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from file", true)
  echo(", Loads client settings from file. You need to run -tecclient"
  	.." save- or -tecclient save all- to create a settings file.\n")
  
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient reset", 
  [[tecClientReset(true);tecFileSaveSettings(true)]],
  "Reset client to default", true)
  echo(", Reset client to default client settings.\n"
  	.."Use -display reset- or -tecclient reset all- to reset display.\n")
  	
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient reset all", 
  [[tecClientResetAll();tecClientSaveAll("true")]],
  "Reset all client settings to default", true)
  echo(", Reset client and display to default settings. "
  	.."Saves default settings to file and disconnects client.\n"
  	.."This command REQUIRES a restart of mudlet!\n")

end --function tecClientHelp</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecClientChangeColors()</name>
					<packageName></packageName>
					<script>function tecClientChangeColors()

  cecho("\nList color names with: ")
  cechoLink("&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient colors\n", 
  [[showColors(3)]],
  "List color names", true)
  
  cecho("Color names in each command can be a hex color also, IE: #FF0000 is red."
    .." If you would like to use hex colors here is a ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;hex color picker.\n", 
  [[openUrl("https://www.w3schools.com/colors/colors_picker.asp")]],
  "Hex color tool", true)
  
  cecho("Change background color of windows that do not have text with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient windows background color colorname", 
  [[printCmdLine("tecclient windows background color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color nontext windows", true)
  cecho("&lt;-Restart required.\n")

  cecho("Change background color of windows that have text in them with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient background colorname ", 
  [[printCmdLine("tecclient background ");
    cecho("You will need to restart for text background to change")]],
  "Change background color of text windows", true)
  cecho("&lt;-Restart required.\n")
  cecho("Command echos must be changed in Options -&gt; Preferences -&gt; Color View -&gt; Command Background.\n")
  
  cecho("Change background color of the client's tabs with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient tabs background color colorname ", 
  [[printCmdLine("tecclient tabs background color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change background color clients tabs", true)
  cecho("&lt;-Restart required.\n")
  
  cecho("Change the color of windows and tabs as your mouse hovers over them: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient hover color colorname ", 
  [[printCmdLine("tecclient hover color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change mouse hover color", true)
  cecho("&lt;-Restart required.\n")
  
  cecho("Change the color help commands are highlighted in: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient helphighlight color colorname\n", 
  [[printCmdLine("tecclient helphighlight color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change help command highlight color", true)

  cecho("Change TEC's primary text color: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient text color colorname\n", 
  [[printCmdLine("tecclient text color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's primary text color", true)
  
  cecho("Change the color of TEC's default green: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient greentext color colorname\n", 
  [[printCmdLine("tecclient greentext color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's green text color", true)
  
  cecho("Change the color of TEC's default blue: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient bluetext color colorname\n", 
  [[printCmdLine("tecclient bluetext color ");
    cecho("\nNow enter the color name at the end of the command and press enter.\n")]],
  "Change TEC's blue text color", true)
  
  cecho("Don't forget to save your changes with: ")
  cechoLink("\n\t&lt;:"..tecSettings.helpHighlightColor.."&gt;tecclient save\n", 
  [[tecFileSaveSettings(true)]],
  "Save client settings", true)
  
  cecho("")

end --function tecClientChangeColors()</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Data Functions</name>
				<packageName></packageName>
				<script>--[[
Due to code order requirements.
Data Functions are in Variables Data themes
]]-- 
</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Map</name>
				<packageName></packageName>
				<script>--Functions used for TEC's map system.</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecMapPixelToPercent</name>
					<packageName></packageName>
					<script>--used to convert a number into what percent it would be on TECs Map 
function tecMapPixelToPercent(tecNumToConvert)
	--converts a size in pixels in reference to TECs map to a percent.
	--TECs map is 240 by 240 pixels.
	--Than adjusts with zoom.
	--Intended for calculating dimmensions of object on the map.
	return ((tonumber(tecNumToConvert) / 240) * 100) * mapZoom
end --end function tecMapPixelToPercent</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecMapIconAdjustment</name>
					<packageName></packageName>
					<script>--position a static icon on the map "probably an exit icon".
--tecIconDimmension is the height or width of the icon being positioned.
--tecMapDimmension is the height or width of the background label of the map.
--Both should be either height or width. One being a height and the other a width may result
--in incorrect icon positioning. Later map release will offer user to not have a square map, if wanted.
function tecMapIconAdjustment(tecIconDimmension, tecMapDimmension)	
	--Turn half the icons size into a percent of what it is on a tecMap 240x240
	tecIconDimmension = tecMapPixelToPercent(tecIconDimmension / 2)
	--Device the entire dimmension of the map by tecMaps 240 size.
	--Than device the % of the icon size by that resulting number.
	return tecIconDimmension / (tecMapDimmension / 240)
end --end tecMapIconAdjustment</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Auto Checks</name>
				<packageName></packageName>
				<script>--[[
Some times you will want to run a command but not display the output of that command 
to the user.
The functions here I untended to work with the triggers that are involved with that.
]]--</script>
				<eventHandlerList />
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Room Characters</name>
					<packageName></packageName>
					<script>--[[
Scripts for working with filtering the approach check command 
]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECRoomCheckActive()</name>
						<packageName></packageName>
						<script>function getTECRoomCheckActive()
	return tecRoomObjects.checkActive
end --end function getRoomCharactersActive</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setTECRoomCheckActive(boolean)</name>
						<packageName></packageName>
						<script>function setTECRoomCheckActive(tecRoomCheckActive)
	tecRoomObjects.checkActive = tecRoomCheckActive
end --end function setRoomCharactersActive</script>
						<eventHandlerList />
					</Script>
					<Script isActive="no" isFolder="no">
						<name>clearTECRoomObjects()</name>
						<packageName></packageName>
						<script>--Moved to variables Data Themese - Variables script</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>runTECRoomObjectCheck()</name>
						<packageName></packageName>
						<script>--used for functions that track objects in the current room.
function runTECRoomObjectCheck()

	--clear room data before running check 
	clearTECRoomObjects()

	--clear the character window.
	clearWindow("roomCharacters.console")
	
	--set a room check to true.
	setTECRoomCheckActive(true)

	--send an ac . command to list characters in the room.
	send("ac .", false)

end --function runRoomCharacterCheck()</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>setRoomCharacterCheck(boolean)</name>
						<packageName></packageName>
						<script>--Used to tell a Room Character Check timer if a check for characters
--in the room should be run 

function setRoomCharacterCheck(booleanRoomCheck)
	doRoomCharacterCheck = booleanRoomCheck
end --function setRoomCheck</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>getRoomCharacterCheck()</name>
						<packageName></packageName>
						<script>--Used to tell a Room Character Check timer if a check for characters
--in the room should be run 

function getRoomCharacterCheck()
	return doRoomCharacterCheck
end --end function getRoomCharacterCheck</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>clearRoomCharacterWindow()</name>
						<packageName></packageName>
						<script>function clearRoomCharacterWindow()
	clearWindow("roomCharacters.console")
end --clearRoomCharacterWindow</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>stopRoomCharacterCheck()</name>
						<packageName></packageName>
						<script>--disables the once a second check if a roomCharacterCheck is needed
function stopRoomCharacterCheck()
disableTimer("Room Character Check")
end --stopRoomCharacterCheck()

stopRoomCharacterCheck() --run it now. As system starts.
--so the timmer doesn't run at login.</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>startRoomCharacterCheck()</name>
						<packageName></packageName>
						<script>--enables the once a second check if a roomCharacterCheck is needed
function startRoomCharacterCheck()
	enableTimer("Room Character Check")
end --startRoomCharacterCheck()</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Settings Window</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecRefreshSettingsWindow()</name>
					<packageName></packageName>
					<script>function tecRefreshSettingsWindow()

	clearWindow("tecSettingsConsole")

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Save\n", 
  [[tecClientSaveAll(true)]],
  "Save all client settings", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Load\n", 
  [[tecFileLoadSettings(true)]],
  "Load client settings from last save", true)
  
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Update\n", 
  [[tecUpdate.checkVersion()]],
  "Check for updates", true)
	
  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Font Size\n", 
  [[printCmdLine("tecclient font size ")]],
  "Change client font size", true)
	
  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Resize Windows\n", 
  [[tecResizeDisplayHelp()]],
  "Change client font size", true)

  cechoLink("tecSettingsConsole", "&lt;:"..tecSettings.helpHighlightColor.."&gt;Change Colors\n", 
  [[tecClientChangeColors()]],
  "Change client colors", true)

  cechoLink("tecSettingsConsole", "&lt;black:SkyBlue&gt;Report Issues\n", 
  [[tecReportIssues()]],
  "Report issues or bugs", true)
  
  cechoLink("tecSettingsConsole", "\n&lt;:"..tecSettings.helpHighlightColor.."&gt;Reset\n", 
  [[tecClientResetAll()]],
  "Reset all changes to default", true)
  
	echo("tecSettingsConsole","\nFull Lists:\n")
	--run the client help command. It is a function so it can be clicked.
	tecClientFullHelp(true, "tecSettingsConsole")

end --function tecRefreshSettingsWindow</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>TEC Client</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>tecClientResetAll()</name>
					<packageName></packageName>
					<script>--Resets all client settings
function tecClientResetAll()

  --reset client settings
  tecClientReset(true)
  tecFileSaveSettings(true)
  
  --reset display settings
  tecClientDisplayReset()
  tecClientDisplaySave(true)

end --function tecClientResetAll()</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Font</name>
					<packageName></packageName>
					<script>--[[
Functions that work with the font.
All windows

font like functions
setMainWindowAutoWrap() sets main windows autowrap character count, is in scripts - GUI

]]--</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>getTECFont</name>
						<packageName></packageName>
						<script>--Currently returns the font size.
--later hope to return font type also.
function getTECFont()
	return tecSettings.tecFontSize
end</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecClientSetFontSize(numbertemp)</name>
						<packageName></packageName>
						<script>--sets the font for all console displays.
--A different function should be made for geyser labels.

function tecClientSetFontSize(numbertemp)--set font settings with this function

	echo("\nSetting font to: "..numbertemp.."\n")

	--if somethings is attempting to set the font below 8, tell them no.
	--It sets the font size for main and the editor window. very frustrating
	--when font is 1...
	if numbertemp &lt; 8 then
		numbertemp = 8
		echo("\nFonts below 8 are not supported, setting font to 8.\n")
	end --end if numbertemp is below 8
	
	tecSettings.tecFontSize = numbertemp or tecDefaultFontSize --set it to size passed OR default on fail
	setFontSize(tecSettings.tecFontSize) --Set main window font size &amp; creates a resize event
	setFontSize("Communication", tecSettings.tecFontSize) --resize font in communication window &amp; creates a resize event
	setFontSize("Thoughts", tecSettings.tecFontSize) --resize font in Thoughts window &amp; creates a resize event
	setFontSize("Speech", tecSettings.tecFontSize) --resize font in Speech window &amp; creates a resize event
	--Each font adjustment WILL trigger a screen resize event.
	
	if getTECDebugMode() then --if debug mode is enabled
  	debugToDisplay("tecClientSetFontSize was sent: "..tostring(numbertemp)..
  		". tecSettings.tecFontSize is currently: "..tostring(tecSettings.tecFontSize)..
  		". Communication console font size: "..tostring(getFontSize(Communication)))		
	end --end if debug mode is on
end --end tecClientSetFontSize</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
				<Script isActive="yes" isFolder="no">
					<name>tecSaveWindowText(tecWindow, tecDirectory)</name>
					<packageName></packageName>
					<script>--copy text in a window to clip board
function tecSaveWindowText(tecWindow, tecDirectory)
	
	--if directory not specified default to debug folder.
	tecDirectory = tecDirectory or tecDebugSaveDir
	--if a window was forgotten default to main
	tecWindow = tecWindow or "main"

	--get total number of lines in window
	local tecWinLineCount = getLastLineNumber(tecWindow)
	--create a table with windows contents
	local windowDataToCopy = getLines(tecWindow, 1, tecWinLineCount)

	--Create a table to save to file. Has to be a file because a string can not be saved
	--to a file we specify.
	local tecWindowBufferString = "INFO: Text shown from latest line to oldest."
	--Loop through all the lines in the table created from the lines in the window.
	for i = tecWinLineCount, 1, -1 do
		--check if a password or login ID may be in the line
		if string.find(tostring(windowDataToCopy[i]), "LOGIN") 
		or string.find(tostring(windowDataToCopy[i]), "Login")
		or string.find(tostring(windowDataToCopy[i]), "login")
		or string.find(tostring(windowDataToCopy[i]), "PASSWORD")
		or string.find(tostring(windowDataToCopy[i]), "Password")
		or string.find(tostring(windowDataToCopy[i]), "password")
		then --replace them with a notice if they are
			tecWindowBufferString = tecWindowBufferString.."A login event was on this line.\n"
		else
			--Put all the lines into one easy to read string.
			tecWindowBufferString = tecWindowBufferString..tostring(windowDataToCopy[i]).."\n"
		end --if else tecWindowBufferString contains login or password
	end --for tecWinLineCount


	--Checking if folder user requested exists.
	--If it does not, then create the folder.
	--if folder created without error write the buffer string to file.
	--If a folder can not be created, output an error
  local lfs = require( "lfs" ) --load lfs module www.tutorialspoint.com/lua/lua_modules.htm
  --Attempt to change current working directory
  local tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
  if ( tecFolderExists ) then --if folder exists, can be cd into...
  	--Save window contents to file.
    io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
    io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
    io.output():close() --Close the file
		echo("Window saved\n")
  else --if the folder does not exist.
  	lfs.mkdir( tecDirectory ) --make the directory.
		tecFolderExists = nil --clear the folder check
    tecFolderExists = lfs.chdir( tecDirectory )  --returns true on success
    if ( tecFolderExists ) then --if folder exists or can be cd into.
    	--Save window to file.
      io.output( tecDirectory..tecWindow..".txt" ) --Open new file in text mode
      io.write( tecWindowBufferString ) --Write the string used as a buffer to file.
      io.output():close() --Close the file
			echo("Window saved\n")
		else --the folder could not be created.
			echo("unable to create folder"..tecDirectory)
			debugToDisplay("unable to create folder"..tecDirectory)
		end --if tecFolderExists
  end --if tecFolderExists else
		
end --function tecSaveWindowText</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecOpenDirectory(tecTMPDir)</name>
					<packageName></packageName>
					<script>--opens a directory in the local browser.
--This will need to have code added to detect linux and mac.

function tecOpenDirectory(tecTMPDir)
	if getOS() == "windows" then
		os.execute("start \"\" \""..tecTMPDir.."\"") --opens explorer to the folder requested
	elseif getOS() == "mac" then
		echo("Sorry mac is currently not supported. Please open finder and go to: "
			..tecTMPDir)
	elseif getOS() == "linux" then
		echo("Sorry linux is currently not supported. Please open a file browser and go to: "
			..tecTMPDir)
	end --if os version
end --tecOpenDirectory</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>techreplace</name>
					<packageName></packageName>
					<script>function techreplace(window, text)
    if not text then text, window = window, nil end
    window = window or "main"
    local str, start, stop = getSelection(window)
    if window ~= "main" then
				selectCurrentLine(window)
				replace(window, "")
				hinsertText(window, text)
				deselect()
    else
				selectCurrentLine()
        replace("")
				hinsertText(text)
				deselect()
    end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecLastLineEqualCheck(tecConsoleName, tecLineToCheck)</name>
					<packageName></packageName>
					<script>function tecLastLineEqualCheck(tecConsoleName, tecLineToCheck)
  moveCursorEnd(tecConsoleName)
  selectCurrentLine(tecConsoleName) --select most likely last line in console.
  local tecLastLine, _, _ = getSelection(tecConsoleName) --pull the text from it
  deselect(tecConsoleName) --Don't forget your deselects!
  if tecLastLine == tecLineToCheck then
    debugToDisplay("String Comparison: "..tecLastLine.." == "..tecLineToCheck)
    return true --if the last line = what was passed
  else
    debugToDisplay("String Comparison: "..tecLastLine.." not == "..tecLineToCheck)
    return false --if the last line does not equal what was passed
  end --if lastline is not tecLineToCheck
end --function tecLastLineEqualCheck</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--[[
Scripts for working with filtering the approach check command 
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>getTECRoomCheckActive()</name>
					<packageName></packageName>
					<script>function getTECRoomCheckActive()
	return tecRoomObjects.checkActive
end --end function getRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)</name>
					<packageName></packageName>
					<script>function setTECRoomCheckActive(tecRoomCheckActive, displayToScreen)
  displayToScreen = displayToScreen or false
	tecRoomObjects.checkActive = tecRoomCheckActive
  tecRoomObjects.displayToScreen = displayToScreen --will ac . display to main
end --end function setRoomCharactersActive</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearTECRoomObjects()</name>
					<packageName></packageName>
					<script>--Moved to variables Data Themese - Variables script</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>runTECRoomObjectCheck(displayToScreen)</name>
					<packageName></packageName>
					<script>--used for functions that track objects in the current room.
function runTECRoomObjectCheck(displayToScreen)

  displayToScreen = displayToScreen or false --if not declared default is false

	--clear room data before running check 
	clearTECRoomObjects()

	--clear the character window.
	clearWindow("roomCharacters.console")
	
	--set a room check to true.
	setTECRoomCheckActive(true,displayToScreen)

	--send an ac . command to list characters in the room.
  send("ac .", false)

end --function runRoomCharacterCheck()</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>clearRoomCharacterWindow()</name>
					<packageName></packageName>
					<script>function clearRoomCharacterWindow()
	clearWindow("roomCharacters.console")
  tecRoomObjects.refreshMessageDisplayed =false
end --clearRoomCharacterWindow</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tecRoomCharRefreshNotification()</name>
					<packageName></packageName>
					<script>local function tecRoomCharRefreshMessage()
  cecho("roomCharacters.console", "Refresh Room Characters by:\n")
  cecho("roomCharacters.console", "Runing command, ")
  cechoLink("roomCharacters.console","&lt;:maroon&gt;room check", 
    [[runTECRoomObjectCheck()]],
    "Populate Room Character window.", true)
  cecho("roomCharacters.console", ".\n")
  cecho("roomCharacters.console", "Pressing ctrl+R.\n")
  cecho("roomCharacters.console", "Refresh Recommended")
end --function tecRoomCharRefreshMessage()

function tecRoomCharRefreshNotification()

  if not tecRoomObjects.refreshMessageDisplayed then
    tecRoomCharRefreshMessage()
    tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed
  end --if tecRefreshNotification is needed
  
end --function recRoomCharRefreshNotification()</script>
					<eventHandlerList />
				</Script>
					<name>tec Auto Updates</name>
					<packageName></packageName>
					<script>--Script to handle downloading updates.

tecUpdate = {}

function tecUpdate.config() --Create variables used for updates
  tecUpdate.versionsFile = "tecClientVersions.lua" --name of file containing versions
  tecUpdate.scriptNamesFile = "tecClientScriptNames.lua" --name of file containing script names
  tecUpdate.versionsRespitory = getMudletHomeDir().."/settings/" --local folder save files in
  if not io.exists(tecUpdate.versionsRespitory) then --if folder does not exists
    lfs.mkdir(tecUpdate.versionsRespitory) --create the folder
  end --if tecUpdate.versionsRespitory not exist
  tecUpdate.version = ".01" --current client version
  tecUpdate.versions = {".01",".02"} --List of all versions, old and current
  tecUpdate.download_path = "https://raw.githubusercontent.com/TheEternalCitizens/mudlet-integration/AutomatedUpdates/src/"
  tecUpdate.aliasName = "tecclient update" --Name of alias user runs to process update
  
  --The script that contains the update function must be at the end of this table!
  tecUpdate.scriptNames = {[[TEC Client Aliases.xml]], [[TEC Client KeyBindings.xml]]
    ,[[imgs.mpackage]], [[TEC Client Timers.xml]], [[TEC Client Triggers.xml]]
    ,[[TEC Client Scripts.xml]]}
end --function tecUpdate.config
tecUpdate.config() --run it on startup so data is configured.

--From this point until function tecUpdate.eventHandler the functions are in the 
--same logical order they will be processed in. The only reason for this is to 
--make it more simple to understand.
--As you are following this, keep in mind that we do not know how long a file will
--take to download. So we have to use tecUpdate.eventHandler to run the next function
--after a download has completed.

--Download file used to check version. Called on automatically on startup
--or by clicking update in settings box.
function tecUpdate.checkVersion()
  if tecUpdate.update_timer then --if the timer exists
    killTimer(tecUpdate.update_timer) --stop the timer
    tecUpdate.update_timer = nil --set the timer to nil
  end -- if tecUpdate.update_timer exists
  debugToDisplay(
    "\nUpdate: Version file Downloading from: "
      ..tecUpdate.download_path .. tecUpdate.versionsFile
      .."\nUpdate: downloading version file to: "..tecUpdate.versionsRespitory
      ..tecUpdate.versionsFile
  ) --end debugToDisplay
  downloading = true --Used during sysDownloadDone event handler in this script
  --download the latest version file to the users profile
  downloadFile(tecUpdate.versionsRespitory .. tecUpdate.versionsFile, 
    tecUpdate.download_path .. tecUpdate.versionsFile) --second half of downloadFile
end --tecUpdate.checkVersion

--Called when downloadDone event finds version file downloaded.
--This function checks it latest version is installed. Prompts the user to update if it is.
local function check_version()
  downloading = false --Used during sysDownloadDone event handler in this script
  local path = tecUpdate.versionsRespitory .. tecUpdate.versionsFile --folder and file names
  debugToDisplay("Update: Loading version file: "..path)
  tecUpdate.versions = {} --will hold the versions table that contains current list of versions.
  table.load(path, tecUpdate.versions) --load the versions file.
  --Find the currently used version's position in the versions master file.
  local pos = table.index_of(tecUpdate.versions, tecUpdate.version) or 0
  debugToDisplay("Update: Current client version: "..tecUpdate.version
    .."\n\tfound in versions file at position: "..tostring(pos))
  if pos ~= #tecUpdate.versions then --if the current version is the not last in the version file.
    debugToDisplay("Update: An update is available")
    enableAlias(tecUpdate.aliasName) --enable alias so user can run update with command
    cecho(string.format("&lt;:maroon&gt;TEC Client is currently %s versions behind.\n",#tecUpdate.versions - pos))
    cecho("&lt;:maroon&gt;To update now, please run: ")
    cechoLink("&lt;:blue&gt;tecclient update", --link text to display
      [[tecUpdate.downloadScriptsNames()]], --link command to run
      "Update game client", true) --link tool tip for mouse hover
    echo("\n") --cechoLinks don't cause the window to autoscroll.
  else --if an update is not needed.
    cecho("You are using the latest TEC Client.\n")
    --restart the check timer that forces the version check in an hour.
    tecUpdate.update_timer = tempTimer(3600, [[tecUpdate.checkVersion()]])
  end --if current version is latest
end --function check_version

--At this point the user has a prompt on screen asking to update.

--Run when user clicks tecclient update, on update prompt from end of check_version
--or when user runs command tecclient update after check_version found an update was needed.
--Downloads a file that contains a table listing all script files used in this project.
--Doing this via downloaded file so scripts can be added in the future.
function tecUpdate.downloadScriptsNames()
  disableAlias(tecUpdate.aliasName) --so user does not start symotanious downloads
  downloading = true --Used during sysDownloadDone event handler in this script
  debugToDisplay("Update: Downloading "..tecUpdate.download_path..tecUpdate.scriptNamesFile
    .."\n\t To folder: "..tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile)
  downloadFile(tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile, tecUpdate.download_path..tecUpdate.scriptNamesFile)
end --function tecUpdate.downloadScriptNames

--Called when downloadDone event finds scriptsNames file downloaded.
--loads scripts file into tecUpdates.scriptNames table.
--Than runs the update.
local function loadScriptsNames()
  downloading = false --Used during sysDownloadDone event handler in this script
  tecUpdate.scriptNames = {} --clear out script names
  debugToDisplay("Update: Loading "..tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile
    .."\n\tTo table: tecUpdate.scriptNames")
  --Load script names from file to tec
  table.load(tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile, tecUpdate.scriptNames)
  --Run updates now that we have a full list of script names.
  tecUpdate.updateVersion()
end --function tecUpdate.loadScripts

--runs once loadScripsName completes. These are two functions due to formating only.
--Downloads the packages needed for the update.
function tecUpdate.updateVersion() --Download the new client
  for index, scriptName in ipairs(tecUpdate.scriptNames) do --Loop through all scripts
    local path, file = tecUpdate.versionsRespitory , scriptName
    downloading = true --Used during sysDownloadDone event handler in this script
    debugToDisplay(
      "Update Downloading from: "..tecUpdate.download_path..file
      .."\nUpdate: downloading file to: "..path..file
      ) --end debugToDisplay
    downloadFile(path..file, tecUpdate.download_path..file) --download the new client scripts
  end --for tecUpdate.scriptNames
end --functyion tecUpdate.updateVersion()

--Runs when sysDownloadDone event finds the LAST file in tecUpdate.scriptNames has downloaded
local function update_version() --install the new client after download was completed
  downloading = false --Used during sysDownloadDone event handler in this script
  debugToDisplay("Update: Disabling alias: "..tecUpdate.aliasName)
  for index, scriptName in ipairs(tecUpdate.scriptNames) do --loop through scripts, and install them
    debugToDisplay("Update: Uninstalling package: "..scriptName:match("(.*)%."))
    uninstallPackage(scriptName:match("(.*)%.")) --remove old package
    debugToDisplay("Update: Installing package: "..tecUpdate.versionsRespitory..scriptName)
    installPackage(tecUpdate.versionsRespitory..scriptName) --install new package
  end --for tecUpdate.scriptNames
  cecho("Updates completed.\n")
end --function update_version

--Make it easy for devs to create and manage scriptNames files.
function tecUpdate.saveScriptNames()
  tecUpdate.config() --Creates the script names table
  --Save the script names table to file.
  table.save(tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile, tecUpdate.scriptNames) 
  cecho("Save script to: "..tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile.."\n")
  cechoLink("&lt;:blue&gt;Open Directory", 
  [[tecOpenDirectory(tecUpdate.versionsRespitory)]],
  "Open folder "..tecUpdate.scriptNamesFile.." is in", true)
  cecho(" "..tecUpdate.scriptNamesFile.." is in.\n")
end --function tecUpdate.saveScriptNames

--Make it easy for devs to create and manage versions files.
function tecUpdate.saveVersions()
  tecUpdate.config() --Creates the versions table
  --Save the versions table to file.
  table.save(tecUpdate.versionsRespitory..tecUpdate.versionsFile, tecUpdate.versions)
  cecho("Save script to: "..tecUpdate.versionsRespitory..tecUpdate.versionsFile.."\n")
  cechoLink("&lt;:blue&gt;Open Directory", 
  [[tecOpenDirectory(tecUpdate.versionsRespitory)]],
  "Open folder "..tecUpdate.versionsFile.." is in", true)
  cecho(" "..tecUpdate.versionsFile.." is in.\n")
end --function tecUpdate.saveScriptNames

function tecUpdate.eventHandler(event, ...)
  if event == "sysDownloadDone" and downloading then
    local file = arg[1] -- in this case name of file downloaded
    if string.ends(file,tecUpdate.versionsFile) then --download is version check  file
      debugToDisplay("Update sysDownloadDone Event: Download: "..file
        .."\n\tdownloaded, check_version() called.")
      check_version() --Use downloaded version file to check if latest version is installed
    elseif string.ends(file,tecUpdate.scriptNames[(#tecUpdate.scriptNames)]) then --if download is LAST downloaded script
      debugToDisplay("Update sysDownloadDone Event: Download: "..file
        .."\n\tdownloaded, update_version() called.")
      update_version() --install the new client after download was completed
    --elseif string.ends(file,tecUpdate.scriptNamesFile) then
    elseif file == tecUpdate.versionsRespitory..tecUpdate.scriptNamesFile then
      debugToDisplay("Update sysDownloadDone Event: Download: "..file
        .."\n\tdownloaded, loadScriptsNames() called.")
      loadScriptsNames() --loads scripts names into table tecUpdate.scriptNames
    else
      debugToDisplay("Update sysDownloadDone Event: Downloaded file: "..file
        .."\n\tWas NOT caught by event handler.")
    end --elseif file downloaded is new script
  end --if event == elseif
end --function tecUpdate.eventHandler()

registerAnonymousEventHandler("sysDownloadDone", "tecUpdate.eventHandler")
</script>
					<eventHandlerList />
				</Script>
				<ScriptGroup isActive="yes" isFolder="yes">
					<name>Colors</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>tecLabelBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>function tecLabelBackgroundColor(tecColor)
  tecSettings.labelBackgroundColor = tecColor
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecTabsBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>function tecTabsBackgroundColor(tecColor)
  tecSettings.tabsBackgroundColor = tecColor
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetMouseHoverColor(tecColor)</name>
						<packageName></packageName>
						<script>function tecSetMouseHoverColor(tecColor)
  tecSettings.hoverColor = tecColor
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetHelpHighlightColor(tecColor)</name>
						<packageName></packageName>
						<script>function tecSetHelpHighlightColor(tecColor)
  tecSettings.helpHighlightColor = tecColor
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetGreenTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetGreenTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.GreenTextColor = Geyser.Color.hex(tecColor)
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBlueTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetBlueTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.BlueTextColor = Geyser.Color.hex(tecColor)
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetTextColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetTextColor(tecColor)
  --Reference: https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  tecSettings.tecTextColor = Geyser.Color.hex(tecColor)
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
					<Script isActive="yes" isFolder="no">
						<name>tecSetBackgroundColor(tecColor)</name>
						<packageName></packageName>
						<script>--set the color that tec will use for green text.
function tecSetBackgroundColor(tecColor)
  --reference: https://wiki.mudlet.org/w/Manual:Lua_Functions#setBackgroundColor
  --https://www.mudlet.org/geyser/files/geyser/GeyserColor.html
  --https://wiki.mudlet.org/w/Manual:Lua_Functions#setBgColor
  
  for index, windowName in ipairs(tecTextWindowNames) do
    cecho(index..". "..windowName.."\n")
    setBackgroundColor(windowName, Geyser.Color.parse(tecColor)) --change background color
    --setBgColor(windowName, Geyser.Color.parse(tecColor)) --change background color
    --bg(windowName, tecColor) --change background color
  end
end --function tecLabelBackgroundColor</script>
						<eventHandlerList />
					</Script>
				</ScriptGroup>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>GUI</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>status bar</name>
				<packageName></packageName>
				<script>status_bar = Geyser.Container:new({
  name = "status_bar",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(status_bar,"status_bar","bottom")</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Health Bar</name>
					<packageName></packageName>
					<script>hpbar = Geyser.Gauge:new({
  name="hpbar",
  x=0, y=0,
  width="50%", height="50%",
},status_bar)
hpbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ffdcdc, stop: 0.1 #ff8c8c, stop: 0.49 #ff4c4c, stop: 0.5 #ff4c4c, stop: 1 #ff6666);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]]) --                                                                           
hpbar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ff6666, stop: 0.1 #F05050, stop: 0.49 #E03030, stop: 0.5 #E03030, stop: 1 #E03030);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

hpbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Health&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Fatigue Bar</name>
					<packageName></packageName>
					<script>fatiguebar = Geyser.Gauge:new({
  name="fatiguebar",
  x=0, y="50%",
  width="50%", height="50%",
},status_bar)
fatiguebar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0fff0, stop: 0.1 #f0ffca, stop: 0.49 #f0d09a, stop: 0.5 #f0d09a, stop: 1 #f0d09a);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
fatiguebar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #f0d09a, stop: 0.1 #e0c08a, stop: 0.49 #d0b07a, stop: 0.5 #d0b07a, stop: 1 #d0b07a);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

fatiguebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Fatigue&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Hunger Bar</name>
					<packageName></packageName>
					<script>hungerbar = Geyser.Gauge:new({
  name="hungerbar",
  x="50%", y=0,
  width="50%", height="50%",
},status_bar)
hungerbar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FEe0, stop: 0.1 #E6FDe0, stop: 0.49 #A0E070, stop: 0.5 #A0E070, stop: 1 #A0E070);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
hungerbar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #A0E070, stop: 0.1 #99d869, stop: 0.49 #60c830, stop: 0.5 #60c830, stop: 1 #60c830);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

hungerbar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Hunger&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Encumbrance Bar</name>
					<packageName></packageName>
					<script>encumbrancebar = Geyser.Gauge:new({
  name="encumbrancebar",
  x="50%", y="50%",
  width="50%", height="50%",
},status_bar)
encumbrancebar.front:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #F0FBFE, stop: 0.1 #E6F8FD, stop: 0.49 #AFDDED, stop: 0.5 #AFDDED, stop: 1 #AFDDED);
    border-top: 1px black solid;
    border-left: 1px black solid;
    border-bottom: 1px black solid;
    border-radius: 7;
    padding: 3px;]])
encumbrancebar.back:setStyleSheet([[background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #AFDDED, stop: 0.1 #A7D7E9, stop: 0.49 #80AEC7, stop: 0.5 #80AEC7, stop: 1 #80AEC7);
    border-width: 1px;
    border-color: black;
    border-style: solid;
    border-radius: 7;
    padding: 3px;]])

encumbrancebar:setValue(50,100,[[&lt;p style="font-size:18px"&gt;&lt;b&gt;&lt;left&gt;&lt;font color="black"&gt;Encumbrance&lt;/font&gt;&lt;/left&gt;&lt;/b&gt;&lt;/p&gt;]])</script>
					<eventHandlerList />
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>compasbar</name>
				<packageName></packageName>
				<script>--Reference https://wiki.mudlet.org/w/Manual:Geyser#Create_a_Clickable_Compass

--create compass object
--dirs directory
tecCompass = tecCompass or {
  dirs = {"nw","n","ne","w","up","down","e","sw","s","se"},
} --end tecCompass object declaration

--main container for tecCompass
tecCompass.window = Geyser.Container:new({
  name = "tecCompass",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--back label for tecCompass
tecCompass.back = Geyser.Label:new({
  name = "tecCompass.back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecCompass.window) --The parent of this label. Main is main window.

tecCompass.back:setStyleSheet(labelsStyle)

--Horizontal box
tecCompass.hbox = Geyser.HBox:new({
    name = "tecCompass.box",
    x = 0, --horizonal position in parent
    y = 0, --vertical position in parent
    width = "100%", --How wide box is, % of parent
    height = "100%", --How tall box is, % of parent
  },tecCompass.back) --parent of this Hbox

--create 3 vertical rows
--in parent object compas.box
tecCompass.row1 = Geyser.VBox:new({name = "tecCompass.row1",},tecCompass.hbox)
tecCompass.row2 = Geyser.VBox:new({name = "tecCompass.row2",},tecCompass.hbox)
tecCompass.row3 = Geyser.VBox:new({name = "tecCompass.row3",},tecCompass.hbox)

--create labels to hold compas images
--Each parent is the row that were 
--created with VBox above.
--row1 left row2 center row3 right
tecCompass.nw = Geyser.Label:new({
  name = "tecCompass.nw",
},tecCompass.row1)

tecCompass.w = Geyser.Label:new({
  name = "tecCompass.w",
},tecCompass.row1)

tecCompass.sw = Geyser.Label:new({
  name = "tecCompass.sw",
},tecCompass.row1)

tecCompass.n = Geyser.Label:new({
  name = "tecCompass.n",
},tecCompass.row2)
        
tecCompass.center = Geyser.VBox:new({
  name = "tecCompass.center",
},tecCompass.row2)

tecCompass.up = Geyser.Label:new({
  name = "tecCompass.up",
},tecCompass.center)

tecCompass.down = Geyser.Label:new({
  name = "tecCompass.down",
},tecCompass.center)

tecCompass.s = Geyser.Label:new({
  name = "tecCompass.s",
},tecCompass.row2)

tecCompass.ne = Geyser.Label:new({
  name = "tecCompass.ne",
},tecCompass.row3)
    
tecCompass.e = Geyser.Label:new({
  name = "tecCompass.e",
},tecCompass.row3)
  
tecCompass.se = Geyser.Label:new({
  name = "tecCompass.se",
},tecCompass.row3)
--end of compas labels

--when a label is clicked we want to
--go in that direction
function tecCompass.click(name)
  send(name)
end

--Function that will put images to direction labels. name will be n nw so on in tecCompass under triggers
function tecCompass.lit(name)
  tecCompass[name]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"..[[/]].."compass"..[[/]]..name..[[hover.png");
    margin: 5px;
  ]])
end
--when the space should be unlit change it back to white.
function tecCompass.unlit(name)
  tecCompass[name]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"..[[/]].."compass"..[[/]]..name..[[.png");
    margin: 5px;
  ]])
end

--Each of the 9 labels need an image of an arrow.
--Rather than setting each individually, we'll
--iterate over the tecCompass.dirs table we made 
--awhile back and add the respective image to each.
--The names of images are a reflection of the tecCompass.dirs 
--table. This keeps it consistent and easy to refer to.
--During the iteration, the callback, setLabelOnEnter and
--setLabelOnLeave are also set for each label.

--loop through dirs in table tecCompass
for k,v in pairs(tecCompass.dirs) do
  tecCompass[v]:setStyleSheet([[
    border-image: url("]]..getMudletHomeDir()..[[/]].."imgs"
		..[[/]].."compass"..[[/]]..v..[[.png");
    margin: 5px;]]) --apply pictures to directions on compass
  
	--if tecCompass is clicked, go in that direction
	tecCompass[v]:setClickCallback("tecCompass.click",v)  
end --end loop through tecCompass.dirs

--keeps the tecCompass square as the windows are adjusted.
function tecCompass.drawKeepSquare()

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_width() &lt; tecCompass.window:get_height() then
  	tecCompass.back:resize(tecCompass.window:get_width(), tecCompass.window:get_width())
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecCompass.window:get_height() &lt; tecCompass.window:get_width() then
  	tecCompass.back:resize(tecCompass.window:get_height(), tecCompass.window.height)
	end --end if height is less than width
	
end --end function keep square.

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecCompass.window,"Compass","topleft")

--Now that we created the window. Make certain it is drawn correctly.
tecCompass.drawKeepSquare() --function at the bottom of this script.</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Settings bar</name>
				<packageName></packageName>
				<script>tecSettingsBar = Geyser.Container:new({
  name = "Settings",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--box that will store the miniconsoles
tecSettingsBack = Geyser.Label:new({
  name = "tecSettingsBack",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},tecSettingsBar)

tecSettingsBack:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
tecSettingsConsole = Geyser.MiniConsole:new({
  name = "tecSettingsConsole",
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},tecSettingsBack)
tecSettingsConsole:setColor(getBgColor()) --set miniconsoles to main consol BG color
tecSettingsConsole:raise()

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecSettingsBar,"Settings","bottomleft")

function tecSettingsWindowResize()
	
	--Resize the back label by 6. We want a 3px border around the entire window
	tecSettingsBack:resize(tostring(tecSettingsBar:get_width() - 6)
		, tostring(tecSettingsBar:get_height() - 6))
	tecSettingsBack:move (3, 3) --left and top borders
	
	--Resize the room character window by 6. We want a 3px border around the entire window
	tecSettingsConsole:resize(tostring(tecSettingsBack:get_width() - 6)
		, tostring(tecSettingsBack:get_height() - 6))
	tecSettingsConsole:move (3, 3) --left and top borders
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." tecSettingsBack width: "..tecSettingsBack:get_width()
			.." tecSettingsBack Height: "..tecSettingsBack:get_height()
			.." tecSettingsConsole Width: "..tecSettingsConsole:get_width()
			.." tecSettingsConsole Height: "..tecSettingsConsole:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecSettingsWindowResize()

tecRefreshSettingsWindow() --Refreshes text in settings window.
tecSettingsWindowResize() --resize the Room Character window now</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>tec map</name>
				<packageName></packageName>
				<script>--creates tec's 2d getAllMapUserData
--future ideas. create a zoom scroll with --tecMap_back:addScrollbars(tecMap, "RV")
--will probably need to complete that function for mudlet...

--Don't forget. Creating room and exit labels ahead of time reduces the time it takes to draw
--rooms while the user is playing. Do not create a system where we create labels as they play.

tecMap = Geyser.Container:new({
  name = "TEC Map",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecMap,"TEC Map","bottomright")

--Creating the background for the 2d tec map.
tecMap_back = Geyser.Label:new({
  name = "tecMap_back",
  x = "0%", --%horizontally position in parent
  y = "0%", --%vertical position in parent
  width = "100%", --% of parent
  height = "100%", --% of parent
},tecMap) --The parent of this label.

--set the appearance of what is behind the map
tecMap_back:setStyleSheet(labelsStyle)

--rgba(25, 50, 150)

mapRoom = {} --Table to hold labels we will draw the rooms with
mapExit = {} --Table to hold labels we will draw the exits with.
--Creating empty rooms for our map system.
for i = 1, 150 do
	--Create empty room and exit labels. Hide them so no junk is on screen.
  mapRoom[i] = Geyser.Label:new({name = "mapRoom"..tostring(i),},tecMap_back) 
  mapExit[i] = Geyser.Label:new({name = "mapExit"..tostring(i),},tecMap_back) 
  mapRoom[i]:hide() --Hide the tab so they don't layer
	mapExit[i]:hide() --Hide the tab so they don't layer
end --end loop create tabs and consoles

function tecMapdrawKeepSquare()

	--if the width of the parent label is less than the height.
	--Resize the background label itself keeping the width and height the equal.
	if tecMap:get_width() &lt; tecMap:get_height() then
  	tecMap_back:resize(tecMap:get_width(), tecMap:get_width())
	end --en if width is less than height.
	
	--if the height of the parent label is less than the width.
	--Resize the background label itself keeping the width and height equal.
	if tecMap:get_height() &lt; tecMap:get_width() then
  	tecMap_back:resize(tecMap:get_height(), tecMap:get_height())
	end --en if width is less than height.
	
	echo("tecMap_back","Exits may be slightly\noff until you walk.")
	
end --end function keep square.

tecMapdrawKeepSquare() --call it to size the map properly</script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>3d map</name>
				<packageName></packageName>
				<script>--[[
threed_map = Geyser.Container:new({
  name = "3d Map",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(threed_map,"3d Map","bottomright")
]]--</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room Characters</name>
				<packageName></packageName>
				<script>--Creates an interactive list of PC and NPCs in players current room.

roomCharacters = Geyser.Container:new({
  name = "Room Characters",    -- give it a unique name here
  x=0, y=0,                   -- I am uncertain if adjusting this will move it within the GUIframe box it will be in
  width = 0, height=0, -- width and height of 0 because it will be passed to GUIframe
})

--box that will store the miniconsoles
roomCharacters.back = Geyser.Label:new({
  name = "roomCharacters.back",
  x = 0, --horizontal position
	y = 0, --adjusted for tabs
  width = "100%",
	height = "100%"
},roomCharacters)

roomCharacters.back:setStyleSheet(labelsStyle) --set to default label style

--This are the miniconsoles that will hold the text
roomCharacters.console = Geyser.MiniConsole:new({ --menu v will be a tab name.
  name = "roomCharacters.console", --Issues experienced if I attempt to name them v.."Console"
	x = 0, --%horizontally position in parent
	y = 0, --%vertical position in parent
	width = "100%", --% of parent
	height = "100%", --% of parent
	autoWrap = true, --allows text to wrap if too long
	fontSize = getTECFont(), --in variables
	font = getFont(), --get font type from main
	--scrollBar = true,
},roomCharacters.back)
roomCharacters.console:setColor(getBgColor()) --set miniconsoles to main consol BG color
roomCharacters.console:raise()

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(roomCharacters,"Room Characters","topright")

function tecCRWindowResize()
	
	--Resize the back label by 6. We want a 3px border around the entire window
	roomCharacters.back:resize(tostring(roomCharacters:get_width() - 6)
		, tostring(roomCharacters:get_height() - 6))
	roomCharacters.back:move (3, 3) --left and top borders
	
	--Resize the room character window by 6. We want a 3px border around the entire window
	roomCharacters.console:resize(tostring(roomCharacters.back:get_width() - 6)
		, tostring(roomCharacters.back:get_height() - 6))
	roomCharacters.console:move (3, 3) --left and top borders
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Room Character Window,"
			.." roomCharacters.back width: "..roomCharacters.back:get_width()
			.." roomCharacters.back Height: "..roomCharacters.back:get_height()
			.." roomCharacters.console Width: "..tecResizedCRHeight:get_width()
			.." roomCharacters.console Height: "..roomCharacters.console:get_height()
			)--end debugToDisplay
	end --end if display debug is enabled.

end --tecCRWindowResize()

tecCRWindowResize() --resize the Room Character window now
cecho("roomCharacters.console", "Populate the Room Characters window by:\n")
cecho("roomCharacters.console", "Runing command, ")
cechoLink("roomCharacters.console","&lt;:maroon&gt;room check", 
  [[runTECRoomObjectCheck()]],
  "Populate Room Character window.", true)
cecho("roomCharacters.console", ".\n")
cecho("roomCharacters.console", "Pressing ctrl+R.\n")
cecho("roomCharacters.console", "\nWe can not automate this because TEC can only receive "
  .."one command per second.\nUsing current methods auto filling this list can prevent you "
  .."from sending commands.")
tecRoomObjects.refreshMessageDisplayed = true --tell client no further refreshes needed</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Communications Menu</name>
				<packageName></packageName>
				<script>--Communications windows at the top of the screen.

--ideas for future
--When click a tab is stays dark to show that is the active tab.
--fix the minor resizing issue with the back label not having a right margin.
--take tabs out of that damn tecComWindows table
--create the option for a combat bar. Only shows combat text...

--Origional menu from the tabs tutorial.
--Only kept it because using a lone table caused issues.
--Feelfree to take the tabs table out of the menu table.
--For me it is a logic not I just didn't feel like unting.
--menu has to be global.
tecComWindows = tecComWindows or {tabs = {"Communication","Thoughts","Speech"},}
tecComWindows.current = tecComWindows.current or tecComWindows.tabs[1]

--A container for everything to be in.
--No size or position because that is handled
--In GUIframe
tecComWindows.container = Geyser.Container:new({
  name = "tecComWindows.container",
})

--Add the status bar to the screen. On the bottom
GUIframe.addWindow(tecComWindows.container,"tecComWindows.container","top")

--box that will hold the tabs
tecComWindows.header = Geyser.HBox:new({
  name = "tecComWindows.header",
  x = 0, --horizontal
	y = 0, --vertical position 
  width = "100%",
  height = tabsHeight, --for now using % rather than pixel math
},tecComWindows.container)

--box that will store the miniconsoles
tecComWindows.footer = Geyser.Label:new({
  name = "tecComWindows.footer",
  x = 0, --horizontal position
	y = tabsHeight, --adjusted for tabs
  width = "100%",
	height = tecSettings.comTextWindowHeight - 3
},tecComWindows.container)
tecComWindows.footer:setStyleSheet(labelsStyle) --set to default label style

--Create the tabs
for k,v in pairs(tecComWindows.tabs) do
  tecComWindows[v.."tab"] = Geyser.Label:new({
    name = "tecComWindows."..v.."tab",
		x = 3, --horizontal position 
		y = 0, --vertical position
		width = "100%",
		height = tabsHeight,
  },tecComWindows.header)
	
  tecComWindows[v.."tab"]:setStyleSheet(tabsStyle) --set style in themes
	
	tecComWindows[v.."tab"]:echo(tabsFontStyle..v) --lable the tabs, set style in themes

	tecComWindows[v.."tab"]:setClickCallback("tecComWindows.click",v) --for charing tabs

	--These are the miniconsoles that will hold the text
  tecComWindows[v] = Geyser.MiniConsole:new({ --tecComWindows v will be a tab name.
    name = v, --Issues experienced if I attempt to name them v.."Console"
  	x = 3, --%horizontally position in parent
  	y = 0, --%vertical position in parent
  	width = "100%", --% of parent
  	height = tecSettings.comTextWindowHeight -3, --% of parent
		autoWrap = true, --allows text to wrap if too long
		fontSize = getTECFont(), --in variables
		font = getFont(), --get font type from main
		scrollBar = true,
  },tecComWindows.footer) --attach to footer show they show below tabs
	tecComWindows[v]:setColor(getBgColor()) --set miniconsoles to main consol BG color 
  tecComWindows[v]:hide() --Hide the tab so they don't layer
end --end loop create tabs and consoles

function tecComWindows.click(tab) --Choose what happens when a tab is clicked.
  tecComWindows[tecComWindows.current]:hide() --Hide the current tab
  tecComWindows.current = tab --Make the clicked tab the current one.
  tecComWindows[tecComWindows.current]:show() --Show the current tab.
end --end tecComWindows.click(tab) function

--A tecComWindows has to be selected otherwise on startup it will just show.
--The label behind the tecComWindows, becuase they are hidden directly after creation.
tecComWindows[tecComWindows.current]:show()

function tecComWindowResize()
	
	--subtract GUIframe.defaults.resizeHeight from tecComWindows.footer.height 
	local tecResizedFooterHeight = tecComWindows.container:get_height() - GUIframe.defaults.resizeHeight 
	local tecResizedFooterWidth = tecComWindows.container:get_width() - 2 --6 the width 2 borders
	tecComWindows.footer:resize(tecResizedFooterWidth, tecResizedFooterHeight) --resize the footer
	tecComWindows.footer:move(1,(tabsHeight + 1))
	
	--reflect changes in tecSettings so there is a chance to save the size.
	tecSettings.comTextWindowHeight = tecResizedFooterHeight
	
	
	--resize all of the miniconsoles so we have the 3px border on the bottom.
	for k,v in pairs(tecComWindows.tabs) do 
  	tecComWindows[v]:move(1, 1)
  	tecComWindows[v]:resize(tecResizedFooterWidth - 2, tecResizedFooterHeight - 2)
	end --for tecComWindows.tabs
	
	if getTECDisplayDebugMode() then --if display debug mode is on
		debugToDisplay("Communication Window, tecComWindows.footer Height: "..tecComWindows.footer:get_height()
			.." tecComWindows.ctainer Height: "..tecComWindows.container:get_height()
			.." New tecComWindows.footer Height: "..tecResizedFooterHeight
			.." mini consoles width: "..(tecResizedFooterWidth - 2).."%"
			)--end debugToDisplay
	end --end if display debug is enabled.

end --resizeKeepTabsStatis

tecComWindowResize() --resize com window</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Macro Menu</name>
				<packageName></packageName>
				<script>--[[
Tec uses a macro system that players can set within the game.
The command they use is @macro.
To avoid additional time for now we can piggy back of their system.
They support 15 gui buttons that can be macroed in the game.
All we need to do, is when the button is clicked it sends command fe#
so button 1 send("fe1")
After that TECs macro system will take over.
For formating you could set the grid style setup for labels in compasbar
I recommend having this at GUIframe location bottom left.
In 5 rows of 3 columns.
Normally does 5 columns of 3 rows. Tec has a combat rotation that requires three unique moves 
in a row or if you are attacking a person you receive a major debuff.
The 5 is while training. You need to do 5 unique moves to get the most skill points.
I like the 3 columns because it gives us big chunky buttons that will work well with touch
screens.
]]--

--Create a global table or namespace
--Creating a global table will make each of our variables unique. Our namespace will be called
--macroMenu and everything we make from here on out will be stored within the macroMenu table.

macroMenu = macroMenu or {}

--Create the container
--Containers are windows that can contain other windows. Actually, since all other Geyser windows
--subclass container, every window can do that. But containers do not have any visible content by
--themselves. Our tabbed "Macros" window will need a container. This will be the bottom layer.
--Containers are invisible, so no need to set a stylesheet. At the end of the file, we will add this
--container as a "window", which the "GUIframe" library to render for us.
macroMenu.container = Geyser.Container:new({
  name = "macroMenu",
})

--Create the parent label
--The 'parent label' refers to the label on the bottom layer. The entire macro menu will be created 
--within this label.
macroMenu.back = Geyser.Label:new({
  name = "macroMenu.back",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.container)

--Create a 3x5 grid
--The macro menu is split into 15 sections, one for each macro. This 3x5 grid is created by 5 HBoxes
--that sit within a single VBox (or vice versa, it doesn't matter). So first off, we create the VBox.
--It will be the same size as its parent, macroMenu.back.

macroMenu.box = Geyser.VBox:new({
  name = "macroMenu.box",
  x = 0,
  y = 0,
  width = "100%",
}, macroMenu.back)

--Next, we create our 5 HBoxes. We don't need to specify position or size because these are placed
--within macroMenu.box, a VBox.
macroMenu.row1 = Geyser.HBox:new({
  name = "macroMenu.row1",
}, macroMenu.box)
macroMenu.row2 = Geyser.HBox:new({
  name = "macroMenu.row2",
},macroMenu.box)
macroMenu.row3 = Geyser.HBox:new({
  name = "macroMenu.row3",
}, macroMenu.box)
macroMenu.row4 = Geyser.HBox:new({
  name = "macroMenu.row4",
}, macroMenu.box)
macroMenu.row5 = Geyser.HBox:new({
  name = "macroMenu.row5",
}, macroMenu.box)

--Finally, we add our 15 labels. Take note that they are split up into five groups of three. Each group
--is placed into a different "macroMenu.row" number.
local mappings = {
  {
    name = "fe1", --name of label that will be created. Will be passed to setClickCallBack function
    label = "I", --What will be on the label
    row = macroMenu.row1, --the geyser box we want this label to go in
  },
  {
    name = "fe2",
    label = "II",
    row = macroMenu.row1,
  },
  {
    name = "fe3",
    label = "III",
    row = macroMenu.row1,
  },
  {
    name = "fe4",
    label = "IV",
    row = macroMenu.row2,
  },
  {
    name = "fe5",
    label = "V",
    row = macroMenu.row2,
  },
  {
    name = "fe6",
    label = "VI",
    row = macroMenu.row2,
  },
  {
    name = "fe7",
    label = "VII",
    row = macroMenu.row3,
  },
  {
    name = "fe8",
    label = "VIII",
    row = macroMenu.row3,
  },
  {
    name = "fe9",
    label = "IX",
    row = macroMenu.row3,
  },
  {
    name = "fe10",
    label = "X",
    row = macroMenu.row4,
  },
  {
    name = "fe11",
    label = "XI",
    row = macroMenu.row4,
  },
  {
    name = "fe12",
    label = "XII",
    row = macroMenu.row4,
  },
  {
    name = "fe13",
    label = "XIII",
    row = macroMenu.row5,
  },
  {
    name = "fe14",
    label = "XIV",
    row = macroMenu.row5,
  },
  {
    name = "fe15",
    label = "XV",
    row = macroMenu.row5,
  },
}

--add onto standard label. We want a small margin for this label.								
--macroLabelStyle = labelsStyle.."margin: 1px\n";
macroLabelStyle = labelsStyle

for _, mapping in pairs(mappings) do --loop trough mappings table using data within
  macroMenu[mapping.name] = Geyser.Label:new({
    name = "macroMenu." .. mapping.name, --name label fe# so it is easy to pass
	  message = "&lt;center&gt;" .. mapping.label .. "&lt;/center&gt;", --puts roman numerals on label
  }, mapping.row) --parent is gettings passed via mapping table row reference
  macroMenu[mapping.name]:setClickCallback("onMacroClick", mapping.name)
  macroMenu[mapping.name]:setStyleSheet(macroLabelStyle) --create window layout
end

--Create a callback function
--When the user clicks a macro button, this function will send the button name to the server. For
--example, when the user clicks the first button, we will send "fe1" to the server.
function onMacroClick(name)
  send(name, false)
end

--Add the macro menu to the top left of the screen
GUIframe.addWindow(macroMenu.container, "Macros", "bottomleft")

GUIframe.activate("Macros") --Make the macros bar the active bar on bottom left.</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Events</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>guiChange()</name>
				<packageName></packageName>
				<script>--calls events that are needed when a window change occurs.
--Do NOT put any function that changes the GUI here!!!

--I am suspicious that calling multiple functions in one event is a no no
--I did this though because creating multiple AnonymousEvents caused issues.
--If I Recall the last event would not occur.

function guiChange()
	setMainWindowAutoWrap() --adjusts word wrap for user.
	if getTECDisplayDebugMode() then geyserDebug() end --if displaydebug is on
	tecCompass.drawKeepSquare()
	tecMapdrawKeepSquare()
	tecComWindowResize() --resize commmunications window
	tecCRWindowResize() --resize the Room Character window now
	tecSettingsWindowResize() --resize the Room Character window now
end --end function guiChange

--whenever event sysWindowReizeEvent occurs run setMainWindowAutowrap.
--In otherwords when any window geyser or main is CHANGED, run setMainWindowAutoWrap.
--That is NOT just resizing.
registerAnonymousEventHandler("sysWindowResizeEvent", "guiChange")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>controlInput(_, command)</name>
				<packageName></packageName>
				<script>--use bool checks to control user input.
--Use this when you do not know what will be entered but DO know a trigger that will
--occur before the command that will be sent.
function controlInput(_, tecPassword) 
  if tecPasswordEntry then --if password entry is set, we expect a password.
  	tecPasswordEntry = false --set this if check to false to it doesn't occur every input.
    --Log into the game. md5.sumhexa converts user ID and password to md5 hash.
    sendAll("USER " .. tecUsername .. "\n", "SECRET NONE", "HASH "
  	 .. md5.sumhexa(tecUsername .. tecPassword .. "NONE") .. "\n", false)
    tecUsername = nil --Clear out the username.
    clearCmdLine() --clear password from command input bar.
    denyCurrentSend() --Deny the origional command, in this case the password.
    
    --clear the password off the screen.
    local tecMainLastLine = (getLastLineNumber("main") - 1)
    moveCursor(1,tecMainLastLine) --Move cursor to second from the newest line in main console
    selectString(tecPassword,1) --Select the password in main.
    replace("Password Entered\n") --Replaced the selected password with.
    deselect() --Don't forget your deselects!
    
    tecPassword = nil --Just in case, lets make certain the password is cleared out.
    command = nil --
	end --tecPasswordEntry
end --function tecPasswordPrompt

--https://wiki.mudlet.org/w/Manual:Event_Engine#sysDataSendRequest
registerAnonymousEventHandler("sysDataSendRequest", "controlInput")</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
